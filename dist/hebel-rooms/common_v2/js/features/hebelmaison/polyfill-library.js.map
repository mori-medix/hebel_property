{"version":3,"file":"features/hebelmaison/polyfill-library.js","mappings":";;UAAA;UACA;;;;;WCDA;WACA;WACA;WACA,uDAAuD,iBAAiB;WACxE;WACA,gDAAgD,aAAa;WAC7D,E;;;;;;;;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4EAA4E,sFAAsF;AAClK;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA,wIAAwI;AACxI;AACA,6DAA6D;AAC7D;AACA,gEAAgE;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D;AAC/D,sFAAsF;AACtF;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2EAA2E;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD;AACxD;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,iBAAiB,wBAAwB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,IAAI;AAChD,uCAAuC,SAAS,KAAK,SAAS,UAAU;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA,8CAA8C,gFAAgF;AAC9H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC;AACA;AACA,6CAA6C,gFAAgF;AAC7H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uEAAuE;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,iBAAiB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4EAA4E,uCAAuC;AACnH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C;AAC9C,8DAA8D;AAC9D;AACA;AACA,iDAAiD;AACjD,uEAAuE;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,0GAA0G,IAAI,4DAA4D,SAAS,UAAU;AAC7L;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ,IAAI;AACJ;AACA;AACA,EAAE;AACF;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA,+BAA+B,gBAAgB;AAC/C;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF,CAAC;AACD;AACA;AACA;AACA,kCAAkC,yCAAyC,kBAAkB,IAAI,0BAA0B,SAAS,UAAU;AAC9I;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,gBAAgB;AAC3D,4DAA4D;AAC5D;AACA;AACA;AACA;AACA,gCAAgC;AAChC,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,mBAAmB;AACtC;AACA;AACA;AACA;AACA;AACA,mBAAmB,mBAAmB;AACtC;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,sBAAsB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,yBAAyB;AAC3C;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,sBAAsB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,iBAAiB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,wBAAwB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,kBAAkB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6EAA6E;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,iDAAiD,IAAI,wCAAwC,SAAS,UAAU;AAChH;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,mCAAmC;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,aAAa;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,cAAc,cAAc;AACpE;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA,EAAE;AACF;AACA;AACA;AACA,yDAAyD,SAAS,UAAU,SAAS;AACrF;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,gCAAgC;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,oEAAoE;AACzG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,0BAA0B;AACrE;AACA;AACA;AACA,gCAAgC,IAAI;AACpC,kHAAkH,SAAS,UAAU;AACrI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,gCAAgC;AAC5C,cAAc,cAAc;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,KAAK;AACjB,YAAY,+BAA+B;AAC3C,cAAc,cAAc;AAC5B;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACA;AACA,2CAA2C;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,KAAK;AACjB,YAAY,+BAA+B;AAC3C,cAAc,cAAc;AAC5B;AACA;AACA;AACA,kBAAkB,sBAAsB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,KAAK;AACjB,YAAY,+BAA+B;AAC3C,YAAY,aAAa;AACzB,cAAc,MAAM;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,gFAAgF;AACnH;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,gBAAgB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,qEAAqE;AAC5G;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,GAAG;AACH,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,oBAAoB;AAC9C,mBAAmB,oBAAoB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,oBAAoB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD;AAClD;AACA;AACA;AACA;AACA;AACA,0BAA0B,oBAAoB;AAC9C,mBAAmB,oBAAoB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,oBAAoB;AAC9C;AACA;AACA;AACA;AACA,6CAA6C;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,oBAAoB;AAC9C;AACA;AACA;AACA;AACA,6CAA6C;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,oBAAoB;AAC9C;AACA,8BAA8B,+BAA+B;AAC7D;AACA;AACA;AACA;AACA;AACA,6CAA6C;AAC7C;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,oBAAoB;AAC/C;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,oEAAoE;AAC3G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,oBAAoB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,oEAAoE;AAC3G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,+BAA+B,IAAI;AACnC,8HAA8H,SAAS,UAAU;AACjJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,gBAAgB;AACpC;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,qEAAqE;AAC5G;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,GAAG;AACH,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,oBAAoB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,oBAAoB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,oBAAoB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD;AAClD;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,oBAAoB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,oBAAoB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,oBAAoB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,oEAAoE;AAC3G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA,uCAAuC,oEAAoE;AAC3G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,iCAAiC,IAAI,mBAAmB,iBAAiB,gGAAgG,SAAS,UAAU;AAC5L;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC,mCAAmC;AACnC;AACA;AACA;AACA;AACA,4FAA4F;AAC5F;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,kDAAkD;AAClD;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,gFAAgF;AACnH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF,CAAC;AACD;AACA;AACA;AACA,CAAC;AACD,uHAAuH","sources":["webpack://my-package/webpack/bootstrap","webpack://my-package/webpack/runtime/make namespace object","webpack://my-package/./src/assets/ts/common_v2/features/hebelmaison/polyfill-library.js"],"sourcesContent":["// The require scope\nvar __webpack_require__ = {};\n\n","// define __esModule on exports\n__webpack_require__.r = function(exports) {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","/* Polyfill service DEVELOPMENT MODE - for live use set NODE_ENV to 'production'\r\n * For detailed credits and licence information see https://github.com/financial-times/polyfill-service.\r\n * \r\n * Features requested: Array.from,Object.assign\r\n * \r\n * - _ESAbstract.ArrayCreate, License: CC0 (required by \"Array.from\", \"Set\", \"Symbol\", \"Array.prototype.map\", \"_ESAbstract.ArraySpeciesCreate\")\r\n * - _ESAbstract.Call, License: CC0 (required by \"Array.from\", \"_ESAbstract.ToString\", \"_ESAbstract.ToPrimitive\", \"_ESAbstract.OrdinaryToPrimitive\")\r\n * - _ESAbstract.Get, License: CC0 (required by \"Array.from\", \"Set\", \"Symbol\", \"Object.getOwnPropertyNames\", \"Array.prototype.indexOf\")\r\n * - _ESAbstract.HasOwnProperty, License: CC0 (required by \"Object.assign\", \"Object.getOwnPropertyDescriptor\")\r\n * - _ESAbstract.HasProperty, License: CC0 (required by \"Array.from\", \"Set\", \"Symbol\", \"Object.getOwnPropertyNames\", \"Array.prototype.indexOf\")\r\n * - _ESAbstract.IsArray, License: CC0 (required by \"Array.from\", \"Set\", \"Symbol\", \"Array.prototype.map\", \"_ESAbstract.ArraySpeciesCreate\")\r\n * - _ESAbstract.IsCallable, License: CC0 (required by \"Array.from\", \"_ESAbstract.ToString\", \"_ESAbstract.ToPrimitive\", \"_ESAbstract.OrdinaryToPrimitive\")\r\n * - _ESAbstract.SameValueNonNumber, License: CC0 (required by \"Array.from\", \"Set\", \"_ESAbstract.SameValueZero\")\r\n * - _ESAbstract.ToBoolean, License: CC0 (required by \"Array.from\", \"Set\", \"Symbol\", \"Array.prototype.filter\")\r\n * - _ESAbstract.ToObject, License: CC0 (required by \"Array.from\", \"Set\", \"Symbol\", \"Object.getOwnPropertyNames\", \"Array.prototype.indexOf\")\r\n * - _ESAbstract.GetV, License: CC0 (required by \"Array.from\", \"_ESAbstract.GetIterator\")\r\n * - _ESAbstract.GetMethod, License: CC0 (required by \"Array.from\", \"_ESAbstract.ToString\", \"_ESAbstract.ToPrimitive\")\r\n * - _ESAbstract.Type, License: CC0 (required by \"Array.from\", \"Set\", \"Symbol\", \"Array.prototype.map\", \"_ESAbstract.ArraySpeciesCreate\")\r\n * - _ESAbstract.GetPrototypeFromConstructor, License: CC0 (required by \"Array.from\", \"Set\", \"_ESAbstract.OrdinaryCreateFromConstructor\")\r\n * - _ESAbstract.IsConstructor, License: CC0 (required by \"Array.from\", \"Set\", \"Symbol\", \"Array.prototype.map\", \"_ESAbstract.ArraySpeciesCreate\")\r\n * - _ESAbstract.IteratorClose, License: CC0 (required by \"Array.from\", \"Set\")\r\n * - _ESAbstract.IteratorComplete, License: CC0 (required by \"Array.from\", \"Set\")\r\n * - _ESAbstract.IteratorNext, License: CC0 (required by \"Array.from\", \"Set\")\r\n * - _ESAbstract.IteratorStep, License: CC0 (required by \"Array.from\", \"Set\")\r\n * - _ESAbstract.IteratorValue, License: CC0 (required by \"Array.from\", \"Set\")\r\n * - _ESAbstract.OrdinaryToPrimitive, License: CC0 (required by \"Array.from\", \"_ESAbstract.ToString\", \"_ESAbstract.ToPrimitive\")\r\n * - _ESAbstract.SameValueZero, License: CC0 (required by \"Array.from\", \"Set\", \"Symbol\", \"Object.getOwnPropertyNames\", \"Array.prototype.includes\")\r\n * - _ESAbstract.ToInteger, License: CC0 (required by \"Array.from\", \"Set\", \"Symbol\", \"Object.getOwnPropertyNames\", \"Array.prototype.indexOf\")\r\n * - _ESAbstract.ToLength, License: CC0 (required by \"Array.from\", \"Set\", \"Symbol\", \"Object.getOwnPropertyNames\", \"Array.prototype.indexOf\")\r\n * - _ESAbstract.ToPrimitive, License: CC0 (required by \"Object.assign\", \"Object.getOwnPropertyDescriptor\", \"_ESAbstract.ToPropertyKey\")\r\n * - _ESAbstract.ToString, License: CC0 (required by \"Array.from\", \"Set\", \"Symbol\", \"Object.getOwnPropertyNames\", \"Array.prototype.indexOf\")\r\n * - _ESAbstract.ToPropertyKey, License: CC0 (required by \"Object.assign\", \"Object.getOwnPropertyDescriptor\")\r\n * - Object.defineProperty, License: CC0 (required by \"Array.from\", \"Set\", \"_ESAbstract.OrdinaryCreateFromConstructor\", \"Object.create\", \"Object.defineProperties\")\r\n * - _ESAbstract.CreateDataProperty, License: CC0 (required by \"Array.from\", \"Set\", \"_ESAbstract.CreateIterResultObject\")\r\n * - _ESAbstract.CreateDataPropertyOrThrow, License: CC0 (required by \"Array.from\", \"Set\", \"Symbol\", \"Array.prototype.map\")\r\n * - _ESAbstract.CreateIterResultObject, License: CC0 (required by \"Array.from\", \"Set\")\r\n * - _ESAbstract.CreateMethodProperty, License: CC0 (required by \"Array.from\", \"Set\", \"Symbol\", \"Object.getOwnPropertyNames\", \"Array.prototype.indexOf\")\r\n * - Array.isArray, License: CC0 (required by \"Array.from\", \"Set\")\r\n * - Array.prototype.forEach, License: CC0 (required by \"Array.from\", \"Set\", \"Symbol\")\r\n * - Array.prototype.includes, License: MIT (required by \"Array.from\", \"Set\", \"Symbol\", \"Object.getOwnPropertyNames\")\r\n * - Array.prototype.indexOf, License: CC0 (required by \"Array.from\", \"Set\", \"Symbol\", \"Object.getOwnPropertyNames\")\r\n * - Function.prototype.bind, License: MIT (required by \"Object.assign\", \"Object.getOwnPropertyDescriptor\")\r\n * - Object.freeze, License: CC0 (required by \"Array.from\", \"Set\", \"Symbol\")\r\n * - Object.getOwnPropertyDescriptor, License: CC0 (required by \"Array.from\", \"Set\", \"_ESAbstract.OrdinaryCreateFromConstructor\", \"Object.create\", \"Object.defineProperties\")\r\n * - Object.getPrototypeOf, License: CC0 (required by \"Array.from\", \"Set\", \"_ESAbstract.OrdinaryCreateFromConstructor\")\r\n * - Object.isExtensible, License: CC0 (required by \"Array.from\", \"Map\")\r\n * - Object.keys, License: MIT (required by \"Array.from\", \"Set\", \"_ESAbstract.OrdinaryCreateFromConstructor\", \"Object.create\", \"Object.defineProperties\")\r\n * - Object.assign, License: CC0\r\n * - Object.defineProperties, License: CC0 (required by \"Array.from\", \"Set\", \"_ESAbstract.OrdinaryCreateFromConstructor\", \"Object.create\")\r\n * - Object.create, License: CC0 (required by \"Array.from\", \"Set\", \"_ESAbstract.OrdinaryCreateFromConstructor\")\r\n * - _ESAbstract.OrdinaryCreateFromConstructor, License: CC0 (required by \"Array.from\", \"Set\")\r\n * - _ESAbstract.Construct, License: CC0 (required by \"Array.from\", \"Set\", \"Symbol\", \"Array.prototype.map\", \"_ESAbstract.ArraySpeciesCreate\")\r\n * - _ESAbstract.ArraySpeciesCreate, License: CC0 (required by \"Array.from\", \"Set\", \"Symbol\", \"Array.prototype.map\")\r\n * - Array.prototype.filter, License: CC0 (required by \"Array.from\", \"Set\", \"Symbol\")\r\n * - Array.prototype.map, License: CC0 (required by \"Array.from\", \"Set\", \"Symbol\")\r\n * - Object.getOwnPropertyNames, License: CC0 (required by \"Array.from\", \"Set\", \"Symbol\")\r\n * - Symbol, License: MIT (required by \"Array.from\", \"Set\", \"Symbol.species\")\r\n * - Symbol.iterator, License: MIT (required by \"Array.from\", \"Set\")\r\n * - _ESAbstract.GetIterator, License: CC0 (required by \"Array.from\", \"Set\")\r\n * - Symbol.species, License: MIT (required by \"Array.from\", \"Set\")\r\n * - Map, License: CC0 (required by \"Array.from\")\r\n * - Set, License: CC0 (required by \"Array.from\")\r\n * - Array.from, License: CC0 */\r\n\r\n(function(self, undefined) {\r\n\r\n// _ESAbstract.ArrayCreate\r\n// 9.4.2.2. ArrayCreate ( length [ , proto ] )\r\nfunction ArrayCreate(length /* [, proto] */) { // eslint-disable-line no-unused-vars\r\n\t// 1. Assert: length is an integer Number ≥ 0.\r\n\t// 2. If length is -0, set length to +0.\r\n\tif (1 / length === -Infinity) {\r\n\t\tlength = 0;\r\n\t}\r\n\t// 3. If length>2^32-1, throw a RangeError exception.\r\n\tif (length > (Math.pow(2, 32) - 1)) {\r\n\t\tthrow new RangeError('Invalid array length');\r\n\t}\r\n\t// 4. If proto is not present, set proto to the intrinsic object %ArrayPrototype%.\r\n\t// 5. Let A be a newly created Array exotic object.\r\n\tvar A = [];\r\n\t// 6. Set A's essential internal methods except for [[DefineOwnProperty]] to the default ordinary object definitions specified in 9.1.\r\n\t// 7. Set A.[[DefineOwnProperty]] as specified in 9.4.2.1.\r\n\t// 8. Set A.[[Prototype]] to proto.\r\n\t// 9. Set A.[[Extensible]] to true.\r\n\t// 10. Perform ! OrdinaryDefineOwnProperty(A, \"length\", PropertyDescriptor{[[Value]]: length, [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: false}).\r\n\tA.length = length;\r\n\t// 11. Return A.\r\n\treturn A;\r\n}\r\n\r\n// _ESAbstract.Call\r\n/* global IsCallable */\r\n// 7.3.12. Call ( F, V [ , argumentsList ] )\r\nfunction Call(F, V /* [, argumentsList] */) { // eslint-disable-line no-unused-vars\r\n\t// 1. If argumentsList is not present, set argumentsList to a new empty List.\r\n\tvar argumentsList = arguments.length > 2 ? arguments[2] : [];\r\n\t// 2. If IsCallable(F) is false, throw a TypeError exception.\r\n\tif (IsCallable(F) === false) {\r\n\t\tthrow new TypeError(Object.prototype.toString.call(F) + 'is not a function.');\r\n\t}\r\n\t// 3. Return ? F.[[Call]](V, argumentsList).\r\n\treturn F.apply(V, argumentsList);\r\n}\r\n\r\n// _ESAbstract.Get\r\n// 7.3.1. Get ( O, P )\r\nfunction Get(O, P) { // eslint-disable-line no-unused-vars\r\n\t// 1. Assert: Type(O) is Object.\r\n\t// 2. Assert: IsPropertyKey(P) is true.\r\n\t// 3. Return ? O.[[Get]](P, O).\r\n\treturn O[P];\r\n}\r\n\r\n// _ESAbstract.HasOwnProperty\r\n// 7.3.11 HasOwnProperty (O, P)\r\nfunction HasOwnProperty(o, p) { // eslint-disable-line no-unused-vars\r\n\t// 1. Assert: Type(O) is Object.\r\n\t// 2. Assert: IsPropertyKey(P) is true.\r\n\t// 3. Let desc be ? O.[[GetOwnProperty]](P).\r\n\t// 4. If desc is undefined, return false.\r\n\t// 5. Return true.\r\n\t// Polyfill.io - As we expect user agents to support ES3 fully we can skip the above steps and use Object.prototype.hasOwnProperty to do them for us.\r\n\treturn Object.prototype.hasOwnProperty.call(o, p);\r\n}\r\n\r\n// _ESAbstract.HasProperty\r\n// 7.3.10. HasProperty ( O, P )\r\nfunction HasProperty(O, P) { // eslint-disable-line no-unused-vars\r\n\t// Assert: Type(O) is Object.\r\n\t// Assert: IsPropertyKey(P) is true.\r\n\t// Return ? O.[[HasProperty]](P).\r\n\treturn P in O;\r\n}\r\n\r\n// _ESAbstract.IsArray\r\n// 7.2.2. IsArray ( argument )\r\nfunction IsArray(argument) { // eslint-disable-line no-unused-vars\r\n\t// 1. If Type(argument) is not Object, return false.\r\n\t// 2. If argument is an Array exotic object, return true.\r\n\t// 3. If argument is a Proxy exotic object, then\r\n\t\t// a. If argument.[[ProxyHandler]] is null, throw a TypeError exception.\r\n\t\t// b. Let target be argument.[[ProxyTarget]].\r\n\t\t// c. Return ? IsArray(target).\r\n\t// 4. Return false.\r\n\r\n\t// Polyfill.io - We can skip all the above steps and check the string returned from Object.prototype.toString().\r\n\treturn Object.prototype.toString.call(argument) === '[object Array]';\r\n}\r\n\r\n// _ESAbstract.IsCallable\r\n// 7.2.3. IsCallable ( argument )\r\nfunction IsCallable(argument) { // eslint-disable-line no-unused-vars\r\n\t// 1. If Type(argument) is not Object, return false.\r\n\t// 2. If argument has a [[Call]] internal method, return true.\r\n\t// 3. Return false.\r\n\r\n\t// Polyfill.io - Only function objects have a [[Call]] internal method. This means we can simplify this function to check that the argument has a type of function.\r\n\treturn typeof argument === 'function';\r\n}\r\n\r\n// _ESAbstract.SameValueNonNumber\r\n// 7.2.12. SameValueNonNumber ( x, y )\r\nfunction SameValueNonNumber(x, y) { // eslint-disable-line no-unused-vars\r\n\t// 1. Assert: Type(x) is not Number.\r\n\t// 2. Assert: Type(x) is the same as Type(y).\r\n\t// 3. If Type(x) is Undefined, return true.\r\n\t// 4. If Type(x) is Null, return true.\r\n\t// 5. If Type(x) is String, then\r\n\t\t// a. If x and y are exactly the same sequence of code units (same length and same code units at corresponding indices), return true; otherwise, return false.\r\n\t// 6. If Type(x) is Boolean, then\r\n\t\t// a. If x and y are both true or both false, return true; otherwise, return false.\r\n\t// 7. If Type(x) is Symbol, then\r\n\t\t// a. If x and y are both the same Symbol value, return true; otherwise, return false.\r\n\t// 8. If x and y are the same Object value, return true. Otherwise, return false.\r\n\r\n\t// Polyfill.io - We can skip all above steps because the === operator does it all for us.\r\n\treturn x === y;\r\n}\r\n\r\n// _ESAbstract.ToBoolean\r\n// 7.1.2. ToBoolean ( argument )\r\n// The abstract operation ToBoolean converts argument to a value of type Boolean according to Table 9:\r\n/*\r\n--------------------------------------------------------------------------------------------------------------\r\n| Argument Type | Result                                                                                     |\r\n--------------------------------------------------------------------------------------------------------------\r\n| Undefined     | Return false.                                                                              |\r\n| Null          | Return false.                                                                              |\r\n| Boolean       | Return argument.                                                                           |\r\n| Number        | If argument is +0, -0, or NaN, return false; otherwise return true.                        |\r\n| String        | If argument is the empty String (its length is zero), return false; otherwise return true. |\r\n| Symbol        | Return true.                                                                               |\r\n| Object        | Return true.                                                                               |\r\n--------------------------------------------------------------------------------------------------------------\r\n*/\r\nfunction ToBoolean(argument) { // eslint-disable-line no-unused-vars\r\n\treturn Boolean(argument);\r\n}\r\n\r\n// _ESAbstract.ToObject\r\n// 7.1.13 ToObject ( argument )\r\n// The abstract operation ToObject converts argument to a value of type Object according to Table 12:\r\n// Table 12: ToObject Conversions\r\n/*\r\n|----------------------------------------------------------------------------------------------------------------------------------------------------|\r\n| Argument Type | Result                                                                                                                             |\r\n|----------------------------------------------------------------------------------------------------------------------------------------------------|\r\n| Undefined     | Throw a TypeError exception.                                                                                                       |\r\n| Null          | Throw a TypeError exception.                                                                                                       |\r\n| Boolean       | Return a new Boolean object whose [[BooleanData]] internal slot is set to argument. See 19.3 for a description of Boolean objects. |\r\n| Number        | Return a new Number object whose [[NumberData]] internal slot is set to argument. See 20.1 for a description of Number objects.    |\r\n| String        | Return a new String object whose [[StringData]] internal slot is set to argument. See 21.1 for a description of String objects.    |\r\n| Symbol        | Return a new Symbol object whose [[SymbolData]] internal slot is set to argument. See 19.4 for a description of Symbol objects.    |\r\n| Object        | Return argument.                                                                                                                   |\r\n|----------------------------------------------------------------------------------------------------------------------------------------------------|\r\n*/\r\nfunction ToObject(argument) { // eslint-disable-line no-unused-vars\r\n\tif (argument === null || argument === undefined) {\r\n\t\tthrow TypeError();\r\n\t}\r\n\treturn Object(argument);\r\n}\r\n\r\n// _ESAbstract.GetV\r\n/* global ToObject */\r\n// 7.3.2 GetV (V, P)\r\nfunction GetV(v, p) { // eslint-disable-line no-unused-vars\r\n\t// 1. Assert: IsPropertyKey(P) is true.\r\n\t// 2. Let O be ? ToObject(V).\r\n\tvar o = ToObject(v);\r\n\t// 3. Return ? O.[[Get]](P, V).\r\n\treturn o[p];\r\n}\r\n\r\n// _ESAbstract.GetMethod\r\n/* global GetV, IsCallable */\r\n// 7.3.9. GetMethod ( V, P )\r\nfunction GetMethod(V, P) { // eslint-disable-line no-unused-vars\r\n\t// 1. Assert: IsPropertyKey(P) is true.\r\n\t// 2. Let func be ? GetV(V, P).\r\n\tvar func = GetV(V, P);\r\n\t// 3. If func is either undefined or null, return undefined.\r\n\tif (func === null || func === undefined) {\r\n\t\treturn undefined;\r\n\t}\r\n\t// 4. If IsCallable(func) is false, throw a TypeError exception.\r\n\tif (IsCallable(func) === false) {\r\n\t\tthrow new TypeError('Method not callable: ' + P);\r\n\t}\r\n\t// 5. Return func.\r\n\treturn func;\r\n}\r\n\r\n// _ESAbstract.Type\r\n// \"Type(x)\" is used as shorthand for \"the type of x\"...\r\nfunction Type(x) { // eslint-disable-line no-unused-vars\r\n\tswitch (typeof x) {\r\n\t\tcase 'undefined':\r\n\t\t\treturn 'undefined';\r\n\t\tcase 'boolean':\r\n\t\t\treturn 'boolean';\r\n\t\tcase 'number':\r\n\t\t\treturn 'number';\r\n\t\tcase 'string':\r\n\t\t\treturn 'string';\r\n\t\tcase 'symbol':\r\n\t\t\treturn 'symbol';\r\n\t\tdefault:\r\n\t\t\t// typeof null is 'object'\r\n\t\t\tif (x === null) return 'null';\r\n\t\t\t// Polyfill.io - This is here because a Symbol polyfill will have a typeof `object`.\r\n\t\t\tif ('Symbol' in self && (x instanceof self.Symbol || x.constructor === self.Symbol)) return 'symbol';\r\n\r\n\t\t\treturn 'object';\r\n\t}\r\n}\r\n\r\n// _ESAbstract.GetPrototypeFromConstructor\r\n/* global Get, Type */\r\n// 9.1.14. GetPrototypeFromConstructor ( constructor, intrinsicDefaultProto )\r\nfunction GetPrototypeFromConstructor(constructor, intrinsicDefaultProto) { // eslint-disable-line no-unused-vars\r\n\t// 1. Assert: intrinsicDefaultProto is a String value that is this specification's name of an intrinsic object. The corresponding object must be an intrinsic that is intended to be used as the [[Prototype]] value of an object.\r\n\t// 2. Assert: IsCallable(constructor) is true.\r\n\t// 3. Let proto be ? Get(constructor, \"prototype\").\r\n\tvar proto = Get(constructor, \"prototype\");\r\n\t// 4. If Type(proto) is not Object, then\r\n\tif (Type(proto) !== 'object') {\r\n\t\t// a. Let realm be ? GetFunctionRealm(constructor).\r\n\t\t// b. Set proto to realm's intrinsic object named intrinsicDefaultProto.\r\n\t\tproto = intrinsicDefaultProto;\r\n\t}\r\n\t// 5. Return proto.\r\n\treturn proto;\r\n}\r\n\r\n// _ESAbstract.IsConstructor\r\n/* global Type */\r\n// 7.2.4. IsConstructor ( argument )\r\nfunction IsConstructor(argument) { // eslint-disable-line no-unused-vars\r\n\t// 1. If Type(argument) is not Object, return false.\r\n\tif (Type(argument) !== 'object') {\r\n\t\treturn false;\r\n\t}\r\n\t// 2. If argument has a [[Construct]] internal method, return true.\r\n\t// 3. Return false.\r\n\r\n\t// Polyfill.io - `new argument` is the only way  to truly test if a function is a constructor.\r\n\t// We choose to not use`new argument` because the argument could have side effects when called.\r\n\t// Instead we check to see if the argument is a function and if it has a prototype.\r\n\t// Arrow functions do not have a [[Construct]] internal method, nor do they have a prototype.\r\n\treturn typeof argument === 'function' && !!argument.prototype;\r\n}\r\n\r\n// _ESAbstract.IteratorClose\r\n/* global GetMethod, Type, Call */\r\n// 7.4.6. IteratorClose ( iteratorRecord, completion )\r\nfunction IteratorClose(iteratorRecord, completion) { // eslint-disable-line no-unused-vars\r\n\t// 1. Assert: Type(iteratorRecord.[[Iterator]]) is Object.\r\n\tif (Type(iteratorRecord['[[Iterator]]']) !== 'object') {\r\n\t\tthrow new Error(Object.prototype.toString.call(iteratorRecord['[[Iterator]]']) + 'is not an Object.');\r\n\t}\r\n\t// 2. Assert: completion is a Completion Record.\r\n\t// Polyfill.io - Ignoring this step as there is no way to check if something is a Completion Record in userland JavaScript.\r\n\r\n\t// 3. Let iterator be iteratorRecord.[[Iterator]].\r\n\tvar iterator = iteratorRecord['[[Iterator]]'];\r\n\t// 4. Let return be ? GetMethod(iterator, \"return\").\r\n\t// Polyfill.io - We name it  returnMethod because return is a keyword and can not be used as an identifier (E.G. variable name, function name etc).\r\n\tvar returnMethod = GetMethod(iterator, \"return\");\r\n\t// 5. If return is undefined, return Completion(completion).\r\n\tif (returnMethod === undefined) {\r\n\t\treturn completion;\r\n\t}\r\n\t// 6. Let innerResult be Call(return, iterator, « »).\r\n\ttry {\r\n\t\tvar innerResult = Call(returnMethod, iterator);\r\n\t} catch (error) {\r\n\t\tvar innerException = error;\r\n\t}\r\n\t// 7. If completion.[[Type]] is throw, return Completion(completion).\r\n\tif (completion) {\r\n\t\treturn completion;\r\n\t}\r\n\t// 8. If innerResult.[[Type]] is throw, return Completion(innerResult).\r\n\tif (innerException) {\r\n\t\tthrow innerException;\r\n\t}\r\n\t// 9. If Type(innerResult.[[Value]]) is not Object, throw a TypeError exception.\r\n\tif (Type(innerResult) !== 'object') {\r\n\t\tthrow new TypeError(\"Iterator's return method returned a non-object.\");\r\n\t}\r\n\t// 10. Return Completion(completion).\r\n\treturn completion;\r\n}\r\n\r\n// _ESAbstract.IteratorComplete\r\n/* global Type, ToBoolean, Get */\r\n// 7.4.3 IteratorComplete ( iterResult )\r\nfunction IteratorComplete(iterResult) { // eslint-disable-line no-unused-vars\r\n\t// 1. Assert: Type(iterResult) is Object.\r\n\tif (Type(iterResult) !== 'object') {\r\n\t\tthrow new Error(Object.prototype.toString.call(iterResult) + 'is not an Object.');\r\n\t}\r\n\t// 2. Return ToBoolean(? Get(iterResult, \"done\")).\r\n\treturn ToBoolean(Get(iterResult, \"done\"));\r\n}\r\n\r\n// _ESAbstract.IteratorNext\r\n/* global Call, Type */\r\n// 7.4.2. IteratorNext ( iteratorRecord [ , value ] )\r\nfunction IteratorNext(iteratorRecord /* [, value] */) { // eslint-disable-line no-unused-vars\r\n\t// 1. If value is not present, then\r\n\tif (arguments.length < 2) {\r\n\t\t// a. Let result be ? Call(iteratorRecord.[[NextMethod]], iteratorRecord.[[Iterator]], « »).\r\n\t\tvar result = Call(iteratorRecord['[[NextMethod]]'], iteratorRecord['[[Iterator]]']);\r\n\t// 2. Else,\r\n\t} else {\r\n\t\t// a. Let result be ? Call(iteratorRecord.[[NextMethod]], iteratorRecord.[[Iterator]], « value »).\r\n\t\tresult = Call(iteratorRecord['[[NextMethod]]'], iteratorRecord['[[Iterator]]'], [arguments[1]]);\r\n\t}\r\n\t// 3. If Type(result) is not Object, throw a TypeError exception.\r\n\tif (Type(result) !== 'object') {\r\n\t\tthrow new TypeError('bad iterator');\r\n\t}\r\n\t// 4. Return result.\r\n\treturn result;\r\n}\r\n\r\n// _ESAbstract.IteratorStep\r\n/* global IteratorNext, IteratorComplete */\r\n// 7.4.5. IteratorStep ( iteratorRecord )\r\nfunction IteratorStep(iteratorRecord) { // eslint-disable-line no-unused-vars\r\n\t// 1. Let result be ? IteratorNext(iteratorRecord).\r\n\tvar result = IteratorNext(iteratorRecord);\r\n\t// 2. Let done be ? IteratorComplete(result).\r\n\tvar done = IteratorComplete(result);\r\n\t// 3. If done is true, return false.\r\n\tif (done === true) {\r\n\t\treturn false;\r\n\t}\r\n\t// 4. Return result.\r\n\treturn result;\r\n}\r\n\r\n// _ESAbstract.IteratorValue\r\n/* global Type, Get */\r\n// 7.4.4 IteratorValue ( iterResult )\r\nfunction IteratorValue(iterResult) { // eslint-disable-line no-unused-vars\r\n\t// Assert: Type(iterResult) is Object.\r\n\tif (Type(iterResult) !== 'object') {\r\n\t\tthrow new Error(Object.prototype.toString.call(iterResult) + 'is not an Object.');\r\n\t}\r\n\t// Return ? Get(iterResult, \"value\").\r\n\treturn Get(iterResult, \"value\");\r\n}\r\n\r\n// _ESAbstract.OrdinaryToPrimitive\r\n/* global Get, IsCallable, Call, Type */\r\n// 7.1.1.1. OrdinaryToPrimitive ( O, hint )\r\nfunction OrdinaryToPrimitive(O, hint) { // eslint-disable-line no-unused-vars\r\n\t// 1. Assert: Type(O) is Object.\r\n\t// 2. Assert: Type(hint) is String and its value is either \"string\" or \"number\".\r\n\t// 3. If hint is \"string\", then\r\n\tif (hint === 'string') {\r\n\t\t// a. Let methodNames be « \"toString\", \"valueOf\" ».\r\n\t\tvar methodNames = ['toString', 'valueOf'];\r\n\t\t// 4. Else,\r\n\t} else {\r\n\t\t// a. Let methodNames be « \"valueOf\", \"toString\" ».\r\n\t\tmethodNames = ['valueOf', 'toString'];\r\n\t}\r\n\t// 5. For each name in methodNames in List order, do\r\n\tfor (var i = 0; i < methodNames.length; ++i) {\r\n\t\tvar name = methodNames[i];\r\n\t\t// a. Let method be ? Get(O, name).\r\n\t\tvar method = Get(O, name);\r\n\t\t// b. If IsCallable(method) is true, then\r\n\t\tif (IsCallable(method)) {\r\n\t\t\t// i. Let result be ? Call(method, O).\r\n\t\t\tvar result = Call(method, O);\r\n\t\t\t// ii. If Type(result) is not Object, return result.\r\n\t\t\tif (Type(result) !== 'object') {\r\n\t\t\t\treturn result;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t// 6. Throw a TypeError exception.\r\n\tthrow new TypeError('Cannot convert to primitive.');\r\n}\r\n\r\n// _ESAbstract.SameValueZero\r\n/* global Type, SameValueNonNumber */\r\n// 7.2.11. SameValueZero ( x, y )\r\nfunction SameValueZero (x, y) { // eslint-disable-line no-unused-vars\r\n\t// 1. If Type(x) is different from Type(y), return false.\r\n\tif (Type(x) !== Type(y)) {\r\n\t\treturn false;\r\n\t}\r\n\t// 2. If Type(x) is Number, then\r\n\tif (Type(x) === 'number') {\r\n\t\t// a. If x is NaN and y is NaN, return true.\r\n\t\tif (isNaN(x) && isNaN(y)) {\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\t// b. If x is +0 and y is -0, return true.\r\n\t\tif (1/x === Infinity && 1/y === -Infinity) {\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\t// c. If x is -0 and y is +0, return true.\r\n\t\tif (1/x === -Infinity && 1/y === Infinity) {\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\t// d. If x is the same Number value as y, return true.\r\n\t\tif (x === y) {\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\t// e. Return false.\r\n\t\treturn false;\r\n\t}\r\n\t// 3. Return SameValueNonNumber(x, y).\r\n\treturn SameValueNonNumber(x, y);\r\n}\r\n\r\n// _ESAbstract.ToInteger\r\n/* global Type */\r\n// 7.1.4. ToInteger ( argument )\r\nfunction ToInteger(argument) { // eslint-disable-line no-unused-vars\r\n\tif (Type(argument) === 'symbol') {\r\n\t\tthrow new TypeError('Cannot convert a Symbol value to a number');\r\n\t}\r\n\r\n\t// 1. Let number be ? ToNumber(argument).\r\n\tvar number = Number(argument);\r\n\t// 2. If number is NaN, return +0.\r\n\tif (isNaN(number)) {\r\n\t\treturn 0;\r\n\t}\r\n\t// 3. If number is +0, -0, +∞, or -∞, return number.\r\n\tif (1/number === Infinity || 1/number === -Infinity || number === Infinity || number === -Infinity) {\r\n\t\treturn number;\r\n\t}\r\n\t// 4. Return the number value that is the same sign as number and whose magnitude is floor(abs(number)).\r\n\treturn ((number < 0) ? -1 : 1) * Math.floor(Math.abs(number));\r\n}\r\n\r\n// _ESAbstract.ToLength\r\n/* global ToInteger */\r\n// 7.1.15. ToLength ( argument )\r\nfunction ToLength(argument) { // eslint-disable-line no-unused-vars\r\n\t// 1. Let len be ? ToInteger(argument).\r\n\tvar len = ToInteger(argument);\r\n\t// 2. If len ≤ +0, return +0.\r\n\tif (len <= 0) {\r\n\t\treturn 0;\r\n\t}\r\n\t// 3. Return min(len, 253-1).\r\n\treturn Math.min(len, Math.pow(2, 53) -1);\r\n}\r\n\r\n// _ESAbstract.ToPrimitive\r\n/* global Type, GetMethod, Call, OrdinaryToPrimitive */\r\n// 7.1.1. ToPrimitive ( input [ , PreferredType ] )\r\nfunction ToPrimitive(input /* [, PreferredType] */) { // eslint-disable-line no-unused-vars\r\n\tvar PreferredType = arguments.length > 1 ? arguments[1] : undefined;\r\n\t// 1. Assert: input is an ECMAScript language value.\r\n\t// 2. If Type(input) is Object, then\r\n\tif (Type(input) === 'object') {\r\n\t\t// a. If PreferredType is not present, let hint be \"default\".\r\n\t\tif (arguments.length < 2) {\r\n\t\t\tvar hint = 'default';\r\n\t\t\t// b. Else if PreferredType is hint String, let hint be \"string\".\r\n\t\t} else if (PreferredType === String) {\r\n\t\t\thint = 'string';\r\n\t\t\t// c. Else PreferredType is hint Number, let hint be \"number\".\r\n\t\t} else if (PreferredType === Number) {\r\n\t\t\thint = 'number';\r\n\t\t}\r\n\t\t// d. Let exoticToPrim be ? GetMethod(input, @@toPrimitive).\r\n\t\tvar exoticToPrim = typeof self.Symbol === 'function' && typeof self.Symbol.toPrimitive === 'symbol' ? GetMethod(input, self.Symbol.toPrimitive) : undefined;\r\n\t\t// e. If exoticToPrim is not undefined, then\r\n\t\tif (exoticToPrim !== undefined) {\r\n\t\t\t// i. Let result be ? Call(exoticToPrim, input, « hint »).\r\n\t\t\tvar result = Call(exoticToPrim, input, [hint]);\r\n\t\t\t// ii. If Type(result) is not Object, return result.\r\n\t\t\tif (Type(result) !== 'object') {\r\n\t\t\t\treturn result;\r\n\t\t\t}\r\n\t\t\t// iii. Throw a TypeError exception.\r\n\t\t\tthrow new TypeError('Cannot convert exotic object to primitive.');\r\n\t\t}\r\n\t\t// f. If hint is \"default\", set hint to \"number\".\r\n\t\tif (hint === 'default') {\r\n\t\t\thint = 'number';\r\n\t\t}\r\n\t\t// g. Return ? OrdinaryToPrimitive(input, hint).\r\n\t\treturn OrdinaryToPrimitive(input, hint);\r\n\t}\r\n\t// 3. Return input\r\n\treturn input;\r\n}\r\n\r\n// _ESAbstract.ToString\r\n/* global Type, ToPrimitive */\r\n// 7.1.12. ToString ( argument )\r\n// The abstract operation ToString converts argument to a value of type String according to Table 11:\r\n// Table 11: ToString Conversions\r\n/*\r\n|---------------|--------------------------------------------------------|\r\n| Argument Type | Result                                                 |\r\n|---------------|--------------------------------------------------------|\r\n| Undefined     | Return \"undefined\".                                    |\r\n|---------------|--------------------------------------------------------|\r\n| Null\t        | Return \"null\".                                         |\r\n|---------------|--------------------------------------------------------|\r\n| Boolean       | If argument is true, return \"true\".                    |\r\n|               | If argument is false, return \"false\".                  |\r\n|---------------|--------------------------------------------------------|\r\n| Number        | Return NumberToString(argument).                       |\r\n|---------------|--------------------------------------------------------|\r\n| String        | Return argument.                                       |\r\n|---------------|--------------------------------------------------------|\r\n| Symbol        | Throw a TypeError exception.                           |\r\n|---------------|--------------------------------------------------------|\r\n| Object        | Apply the following steps:                             |\r\n|               | Let primValue be ? ToPrimitive(argument, hint String). |\r\n|               | Return ? ToString(primValue).                          |\r\n|---------------|--------------------------------------------------------|\r\n*/\r\nfunction ToString(argument) { // eslint-disable-line no-unused-vars\r\n\tswitch(Type(argument)) {\r\n\t\tcase 'symbol':\r\n\t\t\tthrow new TypeError('Cannot convert a Symbol value to a string');\r\n\t\tcase 'object':\r\n\t\t\tvar primValue = ToPrimitive(argument, String);\r\n\t\t\treturn ToString(primValue); // eslint-disable-line no-unused-vars\r\n\t\tdefault:\r\n\t\t\treturn String(argument);\r\n\t}\r\n}\r\n\r\n// _ESAbstract.ToPropertyKey\r\n/* globals ToPrimitive, Type, ToString */\r\n// 7.1.14. ToPropertyKey ( argument )\r\nfunction ToPropertyKey(argument) { // eslint-disable-line no-unused-vars\r\n\t// 1. Let key be ? ToPrimitive(argument, hint String).\r\n\tvar key = ToPrimitive(argument, String);\r\n\t// 2. If Type(key) is Symbol, then\r\n\tif (Type(key) === 'symbol') {\r\n\t\t// a. Return key.\r\n\t\treturn key;\r\n\t}\r\n\t// 3. Return ! ToString(key).\r\n\treturn ToString(key);\r\n}\r\nif (!(\"defineProperty\"in Object&&function(){try{var e={}\r\nreturn Object.defineProperty(e,\"test\",{value:42}),!0}catch(t){return!1}}()\r\n)) {\r\n\r\n// Object.defineProperty\r\n(function (nativeDefineProperty) {\r\n\r\n\tvar supportsAccessors = Object.prototype.hasOwnProperty.call(Object.prototype, '__defineGetter__');\r\n\tvar ERR_ACCESSORS_NOT_SUPPORTED = 'Getters & setters cannot be defined on this javascript engine';\r\n\tvar ERR_VALUE_ACCESSORS = 'A property cannot both have accessors and be writable or have a value';\r\n\r\n\t// Polyfill.io - This does not use CreateMethodProperty because our CreateMethodProperty function uses Object.defineProperty.\r\n\tObject.defineProperty = function defineProperty(object, property, descriptor) {\r\n\r\n\t\t// Where native support exists, assume it\r\n\t\tif (nativeDefineProperty && (object === window || object === document || object === Element.prototype || object instanceof Element)) {\r\n\t\t\treturn nativeDefineProperty(object, property, descriptor);\r\n\t\t}\r\n\r\n\t\tif (object === null || !(object instanceof Object || typeof object === 'object')) {\r\n\t\t\tthrow new TypeError('Object.defineProperty called on non-object');\r\n\t\t}\r\n\r\n\t\tif (!(descriptor instanceof Object)) {\r\n\t\t\tthrow new TypeError('Property description must be an object');\r\n\t\t}\r\n\r\n\t\tvar propertyString = String(property);\r\n\t\tvar hasValueOrWritable = 'value' in descriptor || 'writable' in descriptor;\r\n\t\tvar getterType = 'get' in descriptor && typeof descriptor.get;\r\n\t\tvar setterType = 'set' in descriptor && typeof descriptor.set;\r\n\r\n\t\t// handle descriptor.get\r\n\t\tif (getterType) {\r\n\t\t\tif (getterType === undefined) {\r\n\t\t\t\treturn object;\r\n\t\t\t}\r\n\t\t\tif (getterType !== 'function') {\r\n\t\t\t\tthrow new TypeError('Getter must be a function');\r\n\t\t\t}\r\n\t\t\tif (!supportsAccessors) {\r\n\t\t\t\tthrow new TypeError(ERR_ACCESSORS_NOT_SUPPORTED);\r\n\t\t\t}\r\n\t\t\tif (hasValueOrWritable) {\r\n\t\t\t\tthrow new TypeError(ERR_VALUE_ACCESSORS);\r\n\t\t\t}\r\n\t\t\tObject.__defineGetter__.call(object, propertyString, descriptor.get);\r\n\t\t} else {\r\n\t\t\tobject[propertyString] = descriptor.value;\r\n\t\t}\r\n\r\n\t\t// handle descriptor.set\r\n\t\tif (setterType) {\r\n\t\t\tif (setterType === undefined) {\r\n\t\t\t\treturn object;\r\n\t\t\t}\r\n\t\t\tif (setterType !== 'function') {\r\n\t\t\t\tthrow new TypeError('Setter must be a function');\r\n\t\t\t}\r\n\t\t\tif (!supportsAccessors) {\r\n\t\t\t\tthrow new TypeError(ERR_ACCESSORS_NOT_SUPPORTED);\r\n\t\t\t}\r\n\t\t\tif (hasValueOrWritable) {\r\n\t\t\t\tthrow new TypeError(ERR_VALUE_ACCESSORS);\r\n\t\t\t}\r\n\t\t\tObject.__defineSetter__.call(object, propertyString, descriptor.set);\r\n\t\t}\r\n\r\n\t\t// OK to define value unconditionally - if a getter has been specified as well, an error would be thrown above\r\n\t\tif ('value' in descriptor) {\r\n\t\t\tobject[propertyString] = descriptor.value;\r\n\t\t}\r\n\r\n\t\treturn object;\r\n\t};\r\n}(Object.defineProperty));\r\n\r\n}\r\n\r\n\r\n// _ESAbstract.CreateDataProperty\r\n// 7.3.4. CreateDataProperty ( O, P, V )\r\n// NOTE\r\n// This abstract operation creates a property whose attributes are set to the same defaults used for properties created by the ECMAScript language assignment operator.\r\n// Normally, the property will not already exist. If it does exist and is not configurable or if O is not extensible, [[DefineOwnProperty]] will return false.\r\nfunction CreateDataProperty(O, P, V) { // eslint-disable-line no-unused-vars\r\n\t// 1. Assert: Type(O) is Object.\r\n\t// 2. Assert: IsPropertyKey(P) is true.\r\n\t// 3. Let newDesc be the PropertyDescriptor{ [[Value]]: V, [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: true }.\r\n\tvar newDesc = {\r\n\t\tvalue: V,\r\n\t\twritable: true,\r\n\t\tenumerable: true,\r\n\t\tconfigurable: true\r\n\t};\r\n\t// 4. Return ? O.[[DefineOwnProperty]](P, newDesc).\r\n\ttry {\r\n\t\tObject.defineProperty(O, P, newDesc);\r\n\t\treturn true;\r\n\t} catch (e) {\r\n\t\treturn false;\r\n\t}\r\n}\r\n\r\n// _ESAbstract.CreateDataPropertyOrThrow\r\n/* global CreateDataProperty */\r\n// 7.3.6. CreateDataPropertyOrThrow ( O, P, V )\r\nfunction CreateDataPropertyOrThrow(O, P, V) { // eslint-disable-line no-unused-vars\r\n\t// 1. Assert: Type(O) is Object.\r\n\t// 2. Assert: IsPropertyKey(P) is true.\r\n\t// 3. Let success be ? CreateDataProperty(O, P, V).\r\n\tvar success = CreateDataProperty(O, P, V);\r\n\t// 4. If success is false, throw a TypeError exception.\r\n\tif (!success) {\r\n\t\tthrow new TypeError('Cannot assign value `' + Object.prototype.toString.call(V) + '` to property `' + Object.prototype.toString.call(P) + '` on object `' + Object.prototype.toString.call(O) + '`');\r\n\t}\r\n\t// 5. Return success.\r\n\treturn success;\r\n}\r\n\r\n// _ESAbstract.CreateIterResultObject\r\n/* global Type, CreateDataProperty */\r\n// 7.4.7. CreateIterResultObject ( value, done )\r\nfunction CreateIterResultObject(value, done) { // eslint-disable-line no-unused-vars\r\n\t// 1. Assert: Type(done) is Boolean.\r\n\tif (Type(done) !== 'boolean') {\r\n\t\tthrow new Error();\r\n\t}\r\n\t// 2. Let obj be ObjectCreate(%ObjectPrototype%).\r\n\tvar obj = {};\r\n\t// 3. Perform CreateDataProperty(obj, \"value\", value).\r\n\tCreateDataProperty(obj, \"value\", value);\r\n\t// 4. Perform CreateDataProperty(obj, \"done\", done).\r\n\tCreateDataProperty(obj, \"done\", done);\r\n\t// 5. Return obj.\r\n\treturn obj;\r\n}\r\n\r\n// _ESAbstract.CreateMethodProperty\r\n// 7.3.5. CreateMethodProperty ( O, P, V )\r\nfunction CreateMethodProperty(O, P, V) { // eslint-disable-line no-unused-vars\r\n\t// 1. Assert: Type(O) is Object.\r\n\t// 2. Assert: IsPropertyKey(P) is true.\r\n\t// 3. Let newDesc be the PropertyDescriptor{[[Value]]: V, [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: true}.\r\n\tvar newDesc = {\r\n\t\tvalue: V,\r\n\t\twritable: true,\r\n\t\tenumerable: false,\r\n\t\tconfigurable: true\r\n\t};\r\n\t// 4. Return ? O.[[DefineOwnProperty]](P, newDesc).\r\n\tObject.defineProperty(O, P, newDesc);\r\n}\r\nif (!(\"isArray\"in Array\r\n)) {\r\n\r\n// Array.isArray\r\n/* global CreateMethodProperty, IsArray */\r\n// 22.1.2.2. Array.isArray ( arg )\r\nCreateMethodProperty(Array, 'isArray', function isArray(arg) {\r\n\t// 1. Return ? IsArray(arg).\r\n\treturn IsArray(arg);\r\n});\r\n\r\n}\r\n\r\nif (!(\"forEach\"in Array.prototype\r\n)) {\r\n\r\n// Array.prototype.forEach\r\n/* global Call, CreateMethodProperty, Get, HasProperty, IsCallable, ToLength, ToObject, ToString */\r\n// 22.1.3.10. Array.prototype.forEach ( callbackfn [ , thisArg ] )\r\nCreateMethodProperty(Array.prototype, 'forEach', function forEach(callbackfn /* [ , thisArg ] */) {\r\n\t// 1. Let O be ? ToObject(this value).\r\n\tvar O = ToObject(this);\r\n\t// Polyfill.io - If O is a String object, split it into an array in order to iterate correctly.\r\n\t// We will use arrayLike in place of O when we are iterating through the list.\r\n\tvar arraylike = O instanceof String ? O.split('') : O;\r\n\t// 2. Let len be ? ToLength(? Get(O, \"length\")).\r\n\tvar len = ToLength(Get(O, \"length\"));\r\n\t// 3. If IsCallable(callbackfn) is false, throw a TypeError exception.\r\n\tif (IsCallable(callbackfn) === false) {\r\n\t\tthrow new TypeError(callbackfn + ' is not a function');\r\n\t}\r\n\t// 4. If thisArg is present, let T be thisArg; else let T be undefined.\r\n\tvar T = arguments.length > 1 ? arguments[1] : undefined;\r\n\t// 5. Let k be 0.\r\n\tvar k = 0;\r\n\t// 6. Repeat, while k < len\r\n\twhile (k < len) {\r\n\t\t// a. Let Pk be ! ToString(k).\r\n\t\tvar Pk = ToString(k);\r\n\t\t// b. Let kPresent be ? HasProperty(O, Pk).\r\n\t\tvar kPresent = HasProperty(arraylike, Pk);\r\n\t\t// c. If kPresent is true, then\r\n\t\tif (kPresent) {\r\n\t\t\t// i. Let kValue be ? Get(O, Pk).\r\n\t\t\tvar kValue = Get(arraylike, Pk);\r\n\t\t\t// ii. Perform ? Call(callbackfn, T, « kValue, k, O »).\r\n\t\t\tCall(callbackfn, T, [kValue, k, O]);\r\n\t\t}\r\n\t\t// d. Increase k by 1.\r\n\t\tk = k + 1;\r\n\t}\r\n\t// 7. Return undefined.\r\n\treturn undefined;\r\n});\r\n\r\n}\r\n\r\nif (!(\"includes\"in Array.prototype\r\n)) {\r\n\r\n// Array.prototype.includes\r\n/* global CreateMethodProperty, Get, SameValueZero, ToInteger, ToLength, ToObject, ToString */\r\n// 22.1.3.11. Array.prototype.includes ( searchElement [ , fromIndex ] )\r\nCreateMethodProperty(Array.prototype, 'includes', function includes(searchElement /* [ , fromIndex ] */) {\r\n\t'use strict';\r\n\t// 1. Let O be ? ToObject(this value).\r\n\tvar O = ToObject(this);\r\n\t// 2. Let len be ? ToLength(? Get(O, \"length\")).\r\n\tvar len = ToLength(Get(O, \"length\"));\r\n\t// 3. If len is 0, return false.\r\n\tif (len === 0) {\r\n\t\treturn false;\r\n\t}\r\n\t// 4. Let n be ? ToInteger(fromIndex). (If fromIndex is undefined, this step produces the value 0.)\r\n\tvar n = ToInteger(arguments[1]);\r\n\t// 5. If n ≥ 0, then\r\n\tif (n >= 0) {\r\n\t\t// a. Let k be n.\r\n\t\tvar k = n;\r\n\t\t// 6. Else n < 0,\r\n\t} else {\r\n\t\t// a. Let k be len + n.\r\n\t\tk = len + n;\r\n\t\t// b. If k < 0, let k be 0.\r\n\t\tif (k < 0) {\r\n\t\t\tk = 0;\r\n\t\t}\r\n\t}\r\n\t// 7. Repeat, while k < len\r\n\twhile (k < len) {\r\n\t\t// a. Let elementK be the result of ? Get(O, ! ToString(k)).\r\n\t\tvar elementK = Get(O, ToString(k));\r\n\t\t// b. If SameValueZero(searchElement, elementK) is true, return true.\r\n\t\tif (SameValueZero(searchElement, elementK)) {\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\t// c. Increase k by 1.\r\n\t\tk = k + 1;\r\n\t}\r\n\t// 8. Return false.\r\n\treturn false;\r\n});\r\n\r\n}\r\n\r\nif (!(\"indexOf\"in Array.prototype\r\n)) {\r\n\r\n// Array.prototype.indexOf\r\n/* global CreateMethodProperty, Get, HasProperty, ToInteger, ToLength, ToObject, ToString */\r\n// 22.1.3.12. Array.prototype.indexOf ( searchElement [ , fromIndex ] )\r\nCreateMethodProperty(Array.prototype, 'indexOf', function indexOf(searchElement /* [ , fromIndex ] */) {\r\n\t// 1. Let O be ? ToObject(this value).\r\n\tvar O = ToObject(this);\r\n\t// 2. Let len be ? ToLength(? Get(O, \"length\")).\r\n\tvar len = ToLength(Get(O, \"length\"));\r\n\t// 3. If len is 0, return -1.\r\n\tif (len === 0) {\r\n\t\treturn -1;\r\n\t}\r\n\t// 4. Let n be ? ToInteger(fromIndex). (If fromIndex is undefined, this step produces the value 0.)\r\n\tvar n = ToInteger(arguments[1]);\r\n\t// 5. If n ≥ len, return -1.\r\n\tif (n >= len) {\r\n\t\treturn -1;\r\n\t}\r\n\t// 6. If n ≥ 0, then\r\n\tif (n >= 0) {\r\n\t\t// a. If n is -0, let k be +0; else let k be n.\r\n\t\tvar k = 1/n === -Infinity ? 0 : n;\r\n\t\t// 7. Else n < 0,\r\n\t} else {\r\n\t\t// a. Let k be len + n.\r\n\t\tk = len + n;\r\n\t\t// b. If k < 0, let k be 0.\r\n\t\tif (k < 0) {\r\n\t\t\tk = 0;\r\n\t\t}\r\n\t}\r\n\t// 8. Repeat, while k < len\r\n\twhile (k < len) {\r\n\t\t// a. Let kPresent be ? HasProperty(O, ! ToString(k)).\r\n\t\tvar kPresent = HasProperty(O, ToString(k));\r\n\t\t// b. If kPresent is true, then\r\n\t\tif (kPresent) {\r\n\t\t\t// i. Let elementK be ? Get(O, ! ToString(k)).\r\n\t\t\tvar elementK = Get(O, ToString(k));\r\n\t\t\t// ii. Let same be the result of performing Strict Equality Comparison searchElement === elementK.\r\n\t\t\tvar same = searchElement === elementK;\r\n\t\t\t// iii. If same is true, return k.\r\n\t\t\tif (same) {\r\n\t\t\t\treturn k;\r\n\t\t\t}\r\n\t\t}\r\n\t\t// c. Increase k by 1.\r\n\t\tk = k + 1;\r\n\t}\r\n\t// 9. Return -1.\r\n\treturn -1;\r\n});\r\n\r\n}\r\n\r\nif (!(\"bind\"in Function.prototype\r\n)) {\r\n\r\n// Function.prototype.bind\r\n/* global CreateMethodProperty, IsCallable */\r\n// 19.2.3.2. Function.prototype.bind ( thisArg, ...args )\r\n// https://github.com/es-shims/es5-shim/blob/d6d7ff1b131c7ba14c798cafc598bb6780d37d3b/es5-shim.js#L182\r\nCreateMethodProperty(Function.prototype, 'bind', function bind(that) { // .length is 1\r\n\t// add necessary es5-shim utilities\r\n\tvar $Array = Array;\r\n\tvar $Object = Object;\r\n\tvar ArrayPrototype = $Array.prototype;\r\n\tvar Empty = function Empty() { };\r\n\tvar array_slice = ArrayPrototype.slice;\r\n\tvar array_concat = ArrayPrototype.concat;\r\n\tvar array_push = ArrayPrototype.push;\r\n\tvar max = Math.max;\r\n\t// /add necessary es5-shim utilities\r\n\r\n\t// 1. Let Target be the this value.\r\n\tvar target = this;\r\n\t// 2. If IsCallable(Target) is false, throw a TypeError exception.\r\n\tif (!IsCallable(target)) {\r\n\t\tthrow new TypeError('Function.prototype.bind called on incompatible ' + target);\r\n\t}\r\n\t// 3. Let A be a new (possibly empty) internal list of all of the\r\n\t//   argument values provided after thisArg (arg1, arg2 etc), in order.\r\n\t// XXX slicedArgs will stand in for \"A\" if used\r\n\tvar args = array_slice.call(arguments, 1); // for normal call\r\n\t// 4. Let F be a new native ECMAScript object.\r\n\t// 11. Set the [[Prototype]] internal property of F to the standard\r\n\t//   built-in Function prototype object as specified in 15.3.3.1.\r\n\t// 12. Set the [[Call]] internal property of F as described in\r\n\t//   15.3.4.5.1.\r\n\t// 13. Set the [[Construct]] internal property of F as described in\r\n\t//   15.3.4.5.2.\r\n\t// 14. Set the [[HasInstance]] internal property of F as described in\r\n\t//   15.3.4.5.3.\r\n\tvar bound;\r\n\tvar binder = function () {\r\n\r\n\t\tif (this instanceof bound) {\r\n\t\t\t// 15.3.4.5.2 [[Construct]]\r\n\t\t\t// When the [[Construct]] internal method of a function object,\r\n\t\t\t// F that was created using the bind function is called with a\r\n\t\t\t// list of arguments ExtraArgs, the following steps are taken:\r\n\t\t\t// 1. Let target be the value of F's [[TargetFunction]]\r\n\t\t\t//   internal property.\r\n\t\t\t// 2. If target has no [[Construct]] internal method, a\r\n\t\t\t//   TypeError exception is thrown.\r\n\t\t\t// 3. Let boundArgs be the value of F's [[BoundArgs]] internal\r\n\t\t\t//   property.\r\n\t\t\t// 4. Let args be a new list containing the same values as the\r\n\t\t\t//   list boundArgs in the same order followed by the same\r\n\t\t\t//   values as the list ExtraArgs in the same order.\r\n\t\t\t// 5. Return the result of calling the [[Construct]] internal\r\n\t\t\t//   method of target providing args as the arguments.\r\n\r\n\t\t\tvar result = target.apply(\r\n\t\t\t\tthis,\r\n\t\t\t\tarray_concat.call(args, array_slice.call(arguments))\r\n\t\t\t);\r\n\t\t\tif ($Object(result) === result) {\r\n\t\t\t\treturn result;\r\n\t\t\t}\r\n\t\t\treturn this;\r\n\r\n\t\t} else {\r\n\t\t\t// 15.3.4.5.1 [[Call]]\r\n\t\t\t// When the [[Call]] internal method of a function object, F,\r\n\t\t\t// which was created using the bind function is called with a\r\n\t\t\t// this value and a list of arguments ExtraArgs, the following\r\n\t\t\t// steps are taken:\r\n\t\t\t// 1. Let boundArgs be the value of F's [[BoundArgs]] internal\r\n\t\t\t//   property.\r\n\t\t\t// 2. Let boundThis be the value of F's [[BoundThis]] internal\r\n\t\t\t//   property.\r\n\t\t\t// 3. Let target be the value of F's [[TargetFunction]] internal\r\n\t\t\t//   property.\r\n\t\t\t// 4. Let args be a new list containing the same values as the\r\n\t\t\t//   list boundArgs in the same order followed by the same\r\n\t\t\t//   values as the list ExtraArgs in the same order.\r\n\t\t\t// 5. Return the result of calling the [[Call]] internal method\r\n\t\t\t//   of target providing boundThis as the this value and\r\n\t\t\t//   providing args as the arguments.\r\n\r\n\t\t\t// equiv: target.call(this, ...boundArgs, ...args)\r\n\t\t\treturn target.apply(\r\n\t\t\t\tthat,\r\n\t\t\t\tarray_concat.call(args, array_slice.call(arguments))\r\n\t\t\t);\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\t// 15. If the [[Class]] internal property of Target is \"Function\", then\r\n\t//     a. Let L be the length property of Target minus the length of A.\r\n\t//     b. Set the length own property of F to either 0 or L, whichever is\r\n\t//       larger.\r\n\t// 16. Else set the length own property of F to 0.\r\n\r\n\tvar boundLength = max(0, target.length - args.length);\r\n\r\n\t// 17. Set the attributes of the length own property of F to the values\r\n\t//   specified in 15.3.5.1.\r\n\tvar boundArgs = [];\r\n\tfor (var i = 0; i < boundLength; i++) {\r\n\t\tarray_push.call(boundArgs, '$' + i);\r\n\t}\r\n\r\n\t// XXX Build a dynamic function with desired amount of arguments is the only\r\n\t// way to set the length property of a function.\r\n\t// In environments where Content Security Policies enabled (Chrome extensions,\r\n\t// for ex.) all use of eval or Function costructor throws an exception.\r\n\t// However in all of these environments Function.prototype.bind exists\r\n\t// and so this code will never be executed.\r\n\tbound = Function('binder', 'return function (' + boundArgs.join(',') + '){ return binder.apply(this, arguments); }')(binder);\r\n\r\n\tif (target.prototype) {\r\n\t\tEmpty.prototype = target.prototype;\r\n\t\tbound.prototype = new Empty();\r\n\t\t// Clean up dangling references.\r\n\t\tEmpty.prototype = null;\r\n\t}\r\n\r\n\t// TODO\r\n\t// 18. Set the [[Extensible]] internal property of F to true.\r\n\r\n\t// TODO\r\n\t// 19. Let thrower be the [[ThrowTypeError]] function Object (13.2.3).\r\n\t// 20. Call the [[DefineOwnProperty]] internal method of F with\r\n\t//   arguments \"caller\", PropertyDescriptor {[[Get]]: thrower, [[Set]]:\r\n\t//   thrower, [[Enumerable]]: false, [[Configurable]]: false}, and\r\n\t//   false.\r\n\t// 21. Call the [[DefineOwnProperty]] internal method of F with\r\n\t//   arguments \"arguments\", PropertyDescriptor {[[Get]]: thrower,\r\n\t//   [[Set]]: thrower, [[Enumerable]]: false, [[Configurable]]: false},\r\n\t//   and false.\r\n\r\n\t// TODO\r\n\t// NOTE Function objects created using Function.prototype.bind do not\r\n\t// have a prototype property or the [[Code]], [[FormalParameters]], and\r\n\t// [[Scope]] internal properties.\r\n\t// XXX can't delete prototype in pure-js.\r\n\r\n\t// 22. Return F.\r\n\treturn bound;\r\n});\r\n\r\n}\r\n\r\nif (!(\"freeze\"in Object\r\n)) {\r\n\r\n// Object.freeze\r\n/* global CreateMethodProperty */\r\n// 19.1.2.6. Object.freeze ( O )\r\nCreateMethodProperty(Object, 'freeze', function freeze(O) {\r\n\t// This feature cannot be implemented fully as a polyfill.\r\n\t// We choose to silently fail which allows \"securable\" code\r\n\t// to \"gracefully\" degrade to working but insecure code.\r\n\treturn O;\r\n});\r\n\r\n}\r\n\r\nif (!(\"getOwnPropertyDescriptor\"in Object&&\"function\"==typeof Object.getOwnPropertyDescriptor&&function(){try{return\"3\"===Object.getOwnPropertyDescriptor(\"13.7\",1).value}catch(t){return!1}}()\r\n)) {\r\n\r\n// Object.getOwnPropertyDescriptor\r\n/* global CreateMethodProperty, ToObject, ToPropertyKey, HasOwnProperty, Type */\r\n(function () {\r\n\tvar nativeGetOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\r\n\r\n\tvar supportsDOMDescriptors = (function () {\r\n\t\ttry {\r\n\t\t\treturn Object.defineProperty(document.createElement('div'), 'one', {\r\n\t\t\t\tget: function () {\r\n\t\t\t\t\treturn 1;\r\n\t\t\t\t}\r\n\t\t\t}).one === 1;\r\n\t\t} catch (e) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t});\r\n\r\n\tvar toString = ({}).toString;\r\n\tvar split = ''.split;\r\n\r\n\t// 19.1.2.8 Object.getOwnPropertyDescriptor ( O, P )\r\n\tCreateMethodProperty(Object, 'getOwnPropertyDescriptor', function getOwnPropertyDescriptor(O, P) {\r\n\t\t// 1. Let obj be ? ToObject(O).\r\n\t\tvar obj = ToObject(O);\r\n\t\t// Polyfill.io fallback for non-array-like strings which exist in some ES3 user-agents (IE 8)\r\n\t\tobj = (Type(obj) === 'string' || obj instanceof String) && toString.call(O) == '[object String]' ? split.call(O, '') : Object(O);\r\n\r\n\t\t// 2. Let key be ? ToPropertyKey(P).\r\n\t\tvar key = ToPropertyKey(P);\r\n\r\n\t\t// 3. Let desc be ? obj.[[GetOwnProperty]](key).\r\n\t\t// 4. Return FromPropertyDescriptor(desc).\r\n\t\t// Polyfill.io Internet Explorer 8 natively supports property descriptors only on DOM objects.\r\n\t\t// We will fallback to the polyfill implementation if the native implementation throws an error.\r\n\t\tif (supportsDOMDescriptors) {\r\n\t\t\ttry {\r\n\t\t\t\treturn nativeGetOwnPropertyDescriptor(obj, key);\r\n\t\t\t// eslint-disable-next-line no-empty\r\n\t\t\t} catch (error) {}\r\n\t\t}\r\n\t\tif (HasOwnProperty(obj, key)) {\r\n\t\t\treturn {\r\n\t\t\t\tenumerable: true,\r\n\t\t\t\tconfigurable: true,\r\n\t\t\t\twritable: true,\r\n\t\t\t\tvalue: obj[key]\r\n\t\t\t};\r\n\t\t}\r\n\t});\r\n}());\r\n\r\n}\r\n\r\nif (!(\"getPrototypeOf\"in Object\r\n)) {\r\n\r\n// Object.getPrototypeOf\r\n/* global CreateMethodProperty */\r\n// Based on: https://github.com/es-shims/es5-shim/blob/master/es5-sham.js\r\n\r\n// https://github.com/es-shims/es5-shim/issues#issue/2\r\n// http://ejohn.org/blog/objectgetprototypeof/\r\n// recommended by fschaefer on github\r\n//\r\n// sure, and webreflection says ^_^\r\n// ... this will nerever possibly return null\r\n// ... Opera Mini breaks here with infinite loops\r\nCreateMethodProperty(Object, 'getPrototypeOf', function getPrototypeOf(object) {\r\n\tif (object !== Object(object)) {\r\n\t\tthrow new TypeError('Object.getPrototypeOf called on non-object');\r\n\t}\r\n\tvar proto = object.__proto__;\r\n\tif (proto || proto === null) {\r\n\t\treturn proto;\r\n\t} else if (typeof object.constructor == 'function' && object instanceof object.constructor) {\r\n\t\treturn object.constructor.prototype;\r\n\t} else if (object instanceof Object) {\r\n\t\treturn Object.prototype;\r\n\t} else {\r\n\t\t// Correctly return null for Objects created with `Object.create(null)`\r\n\t\t// (shammed or native) or `{ __proto__: null}`.  Also returns null for\r\n\t\t// cross-realm objects on browsers that lack `__proto__` support (like\r\n\t\t// IE <11), but that's the best we can do.\r\n\t\treturn null;\r\n\t}\r\n});\r\n\r\n}\r\n\r\nif (!(\"isExtensible\"in Object\r\n)) {\r\n\r\n// Object.isExtensible\r\n/* global CreateMethodProperty, Type */\r\n\r\n(function (nativeIsExtensible) {\r\n\t// 19.1.2.13 Object.isExtensible ( O )\r\n\tCreateMethodProperty(Object, 'isExtensible', function isExtensible(O) {\r\n\t\t// 1. If Type(O) is not Object, return false.\r\n\t\tif (Type(O) !== \"object\") {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\t// 2. Return ? IsExtensible(O).\r\n\t\treturn nativeIsExtensible ? nativeIsExtensible(O) : true;\r\n\t});\r\n}(Object.isExtensible));\r\n\r\n}\r\n\r\nif (!(\"keys\"in Object&&function(){return 2===Object.keys(arguments).length}(1,2)&&function(){try{return Object.keys(\"\"),!0}catch(t){return!1}}()\r\n)) {\r\n\r\n// Object.keys\r\n/* global CreateMethodProperty */\r\nCreateMethodProperty(Object, \"keys\", (function() {\r\n\t'use strict';\r\n\r\n\t// modified from https://github.com/es-shims/object-keys\r\n\r\n\tvar has = Object.prototype.hasOwnProperty;\r\n\tvar toStr = Object.prototype.toString;\r\n\tvar isEnumerable = Object.prototype.propertyIsEnumerable;\r\n\tvar hasDontEnumBug = !isEnumerable.call({ toString: null }, 'toString');\r\n\tvar hasPrototypeEnumBug = isEnumerable.call(function () { }, 'prototype');\r\n\tfunction hasProtoEnumBug() {\r\n\t\t// Object.create polyfill creates an enumerable __proto__\r\n\t\tvar createdObj;\r\n\t\ttry {\r\n\t\t\tcreatedObj = Object.create({});\r\n\t\t} catch (e) {\r\n\t\t\t// If this fails the polyfil isn't loaded yet, but will be.\r\n\t\t\t// Can't add it to depedencies because of it would create a circular depedency.\r\n\t\t\treturn true;\r\n\t\t}\r\n\r\n\t\treturn isEnumerable.call(createdObj, '__proto__')\r\n\t}\r\n\r\n\tvar dontEnums = [\r\n\t\t'toString',\r\n\t\t'toLocaleString',\r\n\t\t'valueOf',\r\n\t\t'hasOwnProperty',\r\n\t\t'isPrototypeOf',\r\n\t\t'propertyIsEnumerable',\r\n\t\t'constructor'\r\n\t];\r\n\tvar equalsConstructorPrototype = function (o) {\r\n\t\tvar ctor = o.constructor;\r\n\t\treturn ctor && ctor.prototype === o;\r\n\t};\r\n\tvar excludedKeys = {\r\n\t\t$console: true,\r\n\t\t$external: true,\r\n\t\t$frame: true,\r\n\t\t$frameElement: true,\r\n\t\t$frames: true,\r\n\t\t$innerHeight: true,\r\n\t\t$innerWidth: true,\r\n\t\t$outerHeight: true,\r\n\t\t$outerWidth: true,\r\n\t\t$pageXOffset: true,\r\n\t\t$pageYOffset: true,\r\n\t\t$parent: true,\r\n\t\t$scrollLeft: true,\r\n\t\t$scrollTop: true,\r\n\t\t$scrollX: true,\r\n\t\t$scrollY: true,\r\n\t\t$self: true,\r\n\t\t$webkitIndexedDB: true,\r\n\t\t$webkitStorageInfo: true,\r\n\t\t$window: true\r\n\t};\r\n\tvar hasAutomationEqualityBug = (function () {\r\n\t\tif (typeof window === 'undefined') { return false; }\r\n\t\tfor (var k in window) {\r\n\t\t\ttry {\r\n\t\t\t\tif (!excludedKeys['$' + k] && has.call(window, k) && window[k] !== null && typeof window[k] === 'object') {\r\n\t\t\t\t\ttry {\r\n\t\t\t\t\t\tequalsConstructorPrototype(window[k]);\r\n\t\t\t\t\t} catch (e) {\r\n\t\t\t\t\t\treturn true;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t} catch (e) {\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn false;\r\n\t}());\r\n\tvar equalsConstructorPrototypeIfNotBuggy = function (o) {\r\n\t\tif (typeof window === 'undefined' || !hasAutomationEqualityBug) {\r\n\t\t\treturn equalsConstructorPrototype(o);\r\n\t\t}\r\n\t\ttry {\r\n\t\t\treturn equalsConstructorPrototype(o);\r\n\t\t} catch (e) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t};\r\n\r\n\tfunction isArgumentsObject(value) {\r\n\t\tvar str = toStr.call(value);\r\n\t\tvar isArgs = str === '[object Arguments]';\r\n\t\tif (!isArgs) {\r\n\t\t\tisArgs = str !== '[object Array]' &&\r\n\t\t\t\tvalue !== null &&\r\n\t\t\t\ttypeof value === 'object' &&\r\n\t\t\t\ttypeof value.length === 'number' &&\r\n\t\t\t\tvalue.length >= 0 &&\r\n\t\t\t\ttoStr.call(value.callee) === '[object Function]';\r\n\t\t}\r\n\t\treturn isArgs;\r\n\t}\r\n\r\n\treturn function keys(object) {\r\n\t\tvar isFunction = toStr.call(object) === '[object Function]';\r\n\t\tvar isArguments = isArgumentsObject(object);\r\n\t\tvar isString = toStr.call(object) === '[object String]';\r\n\t\tvar theKeys = [];\r\n\r\n\t\tif (object === undefined || object === null) {\r\n\t\t\tthrow new TypeError('Cannot convert undefined or null to object');\r\n\t\t}\r\n\r\n\t\tvar skipPrototype = hasPrototypeEnumBug && isFunction;\r\n\t\tif (isString && object.length > 0 && !has.call(object, 0)) {\r\n\t\t\tfor (var i = 0; i < object.length; ++i) {\r\n\t\t\t\ttheKeys.push(String(i));\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (isArguments && object.length > 0) {\r\n\t\t\tfor (var j = 0; j < object.length; ++j) {\r\n\t\t\t\ttheKeys.push(String(j));\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tfor (var name in object) {\r\n\t\t\t\tif (!(hasProtoEnumBug() && name === '__proto__') && !(skipPrototype && name === 'prototype') && has.call(object, name)) {\r\n\t\t\t\t\ttheKeys.push(String(name));\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (hasDontEnumBug) {\r\n\t\t\tvar skipConstructor = equalsConstructorPrototypeIfNotBuggy(object);\r\n\r\n\t\t\tfor (var k = 0; k < dontEnums.length; ++k) {\r\n\t\t\t\tif (!(skipConstructor && dontEnums[k] === 'constructor') && has.call(object, dontEnums[k])) {\r\n\t\t\t\t\ttheKeys.push(dontEnums[k]);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn theKeys;\r\n\t};\r\n}()));\r\n\r\n}\r\n\r\nif (!(\"assign\"in Object\r\n)) {\r\n\r\n// Object.assign\r\n/* global CreateMethodProperty, Get, ToObject */\r\n// 19.1.2.1 Object.assign ( target, ...sources )\r\nCreateMethodProperty(Object, 'assign', function assign(target, source) { // eslint-disable-line no-unused-vars\r\n\t// 1. Let to be ? ToObject(target).\r\n\tvar to = ToObject(target);\r\n\r\n\t// 2. If only one argument was passed, return to.\r\n\tif (arguments.length === 1) {\r\n\t\treturn to;\r\n\t}\r\n\r\n\t// 3. Let sources be the List of argument values starting with the second argument\r\n\tvar sources = Array.prototype.slice.call(arguments, 1);\r\n\r\n\t// 4. For each element nextSource of sources, in ascending index order, do\r\n\tvar index1;\r\n\tvar index2;\r\n\tvar keys;\r\n\tvar from;\r\n\tfor (index1 = 0; index1 < sources.length; index1++) {\r\n\t\tvar nextSource = sources[index1];\r\n\t\t// a. If nextSource is undefined or null, let keys be a new empty List.\r\n\t\tif (nextSource === undefined || nextSource === null) {\r\n\t\t\tkeys = [];\r\n\t\t\t// b. Else,\r\n\t\t} else {\r\n\t\t\t// Polyfill.io - In order to get strings in ES3 and old V8 working correctly we need to split them into an array ourselves.\r\n\t\t\t// i. Let from be ! ToObject(nextSource).\r\n\t\t\tfrom = Object.prototype.toString.call(nextSource) === '[object String]' ? String(nextSource).split('') : ToObject(nextSource);\r\n\t\t\t// ii. Let keys be ? from.[[OwnPropertyKeys]]().\r\n\t\t\t/*\r\n\t\t\t\tThis step in our polyfill is not complying with the specification.\r\n\t\t\t\t[[OwnPropertyKeys]] is meant to return ALL keys, including non-enumerable and symbols.\r\n\t\t\t\tTODO: When we have Reflect.ownKeys, use that instead as it is the userland equivalent of [[OwnPropertyKeys]].\r\n\t\t\t*/\r\n\t\t\tkeys = Object.keys(from);\r\n\t\t}\r\n\r\n\t\t// c. For each element nextKey of keys in List order, do\r\n\t\tfor (index2 = 0; index2 < keys.length; index2++) {\r\n\t\t\tvar nextKey = keys[index2];\r\n\t\t\tvar enumerable;\r\n\t\t\ttry {\r\n\t\t\t\t// i. Let desc be ? from.[[GetOwnProperty]](nextKey).\r\n\t\t\t\tvar desc = Object.getOwnPropertyDescriptor(from, nextKey);\r\n\t\t\t\t// ii. If desc is not undefined and desc.[[Enumerable]] is true, then\r\n\t\t\t\tenumerable = desc !== undefined && desc.enumerable === true;\r\n\t\t\t} catch (e) {\r\n\t\t\t\t// Polyfill.io - We use Object.prototype.propertyIsEnumerable as a fallback\r\n\t\t\t\t// because `Object.getOwnPropertyDescriptor(window.location, 'hash')` causes Internet Explorer 11 to crash.\r\n\t\t\t\tenumerable = Object.prototype.propertyIsEnumerable.call(from, nextKey);\r\n\t\t\t}\r\n\t\t\tif (enumerable) {\r\n\t\t\t\t// 1. Let propValue be ? Get(from, nextKey).\r\n\t\t\t\tvar propValue = Get(from, nextKey);\r\n\t\t\t\t// 2. Perform ? Set(to, nextKey, propValue, true).\r\n\t\t\t\tto[nextKey] = propValue;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t// 5. Return to.\r\n\treturn to;\r\n});\r\n\r\n}\r\n\r\nif (!(\"defineProperties\"in Object\r\n)) {\r\n\r\n// Object.defineProperties\r\n/* global CreateMethodProperty, Get, ToObject, Type */\r\n// 19.1.2.3. Object.defineProperties ( O, Properties )\r\nCreateMethodProperty(Object, 'defineProperties', function defineProperties(O, Properties) {\r\n\t// 1. If Type(O) is not Object, throw a TypeError exception.\r\n\tif (Type(O) !== 'object') {\r\n\t\tthrow new TypeError('Object.defineProperties called on non-object');\r\n\t}\r\n\t// 2. Let props be ? ToObject(Properties).\r\n\tvar props = ToObject(Properties);\r\n\t// 3. Let keys be ? props.[[OwnPropertyKeys]]().\r\n\t/*\r\n\t\tPolyfill.io - This step in our polyfill is not complying with the specification.\r\n\t\t[[OwnPropertyKeys]] is meant to return ALL keys, including non-enumerable and symbols.\r\n\t\tTODO: When we have Reflect.ownKeys, use that instead as it is the userland equivalent of [[OwnPropertyKeys]].\r\n\t*/\r\n\tvar keys = Object.keys(props);\r\n\t// 4. Let descriptors be a new empty List.\r\n\tvar descriptors = [];\r\n\t// 5. For each element nextKey of keys in List order, do\r\n\tfor (var i = 0; i < keys.length; i++) {\r\n\t\tvar nextKey = keys[i];\r\n\t\t// a. Let propDesc be ? props.[[GetOwnProperty]](nextKey).\r\n\t\tvar propDesc = Object.getOwnPropertyDescriptor(props, nextKey);\r\n\t\t// b. If propDesc is not undefined and propDesc.[[Enumerable]] is true, then\r\n\t\tif (propDesc !== undefined && propDesc.enumerable) {\r\n\t\t\t// i. Let descObj be ? Get(props, nextKey).\r\n\t\t\tvar descObj = Get(props, nextKey);\r\n\t\t\t// ii. Let desc be ? ToPropertyDescriptor(descObj).\r\n\t\t\t// Polyfill.io - We skip this step because Object.defineProperty deals with it.\r\n\t\t\t// TODO: Implement this step?\r\n\t\t\tvar desc = descObj;\r\n\t\t\t// iii. Append the pair (a two element List) consisting of nextKey and desc to the end of descriptors.\r\n\t\t\tdescriptors.push([nextKey, desc]);\r\n\t\t}\r\n\t}\r\n\t// 6. For each pair from descriptors in list order, do\r\n\tfor (var j = 0; j < descriptors.length; j++){\r\n\t\t// a. Let P be the first element of pair.\r\n\t\tvar P = descriptors[j][0];\r\n\t\t// b. Let desc be the second element of pair.\r\n\t\tdesc = descriptors[j][1];\r\n\t\t// c. Perform ? DefinePropertyOrThrow(O, P, desc).\r\n\t\tObject.defineProperty(O, P, desc);\r\n\t}\r\n\t// 7. Return O.\r\n\treturn O;\r\n});\r\n\r\n}\r\n\r\nif (!(\"create\"in Object\r\n)) {\r\n\r\n// Object.create\r\n/* global CreateMethodProperty, Type */\r\n(function () {\r\n\tvar supportsProto = !({ __proto__: null } instanceof Object);\r\n\tif (supportsProto) {\r\n\t\tvar createEmpty = function () {\r\n\t\t\treturn {\r\n\t\t\t\t__proto__: null\r\n\t\t\t};\r\n\t\t};\r\n\t} else {\r\n\t\t// Taken from https://github.com/es-shims/es5-shim/blob/a265a136d6220146cfbb09026c2de1fa42e220ec/es5-sham.js#L247\r\n\t\t// In old IE __proto__ can't be used to manually set `null`, nor does\r\n\t\t// any other method exist to make an object that inherits from nothing,\r\n\t\t// aside from Object.prototype itself. Instead, create a new global\r\n\t\t// object and *steal* its Object.prototype and strip it bare. This is\r\n\t\t// used as the prototype to create nullary objects.\r\n\t\tcreateEmpty = function () {\r\n\t\t\t// Determine which approach to use\r\n\t\t\t// see https://github.com/es-shims/es5-shim/issues/150\r\n\t\t\tvar iframe = document.createElement('iframe');\r\n\t\t\tiframe.style.display = 'none';\r\n\t\t\tvar parent = document.body || document.documentElement;\r\n\t\t\tparent.appendChild(iframe);\r\n\t\t\tiframe.src = 'javascript:';\r\n\t\t\tvar empty = iframe.contentWindow.Object.prototype;\r\n\t\t\tparent.removeChild(iframe);\r\n\t\t\tiframe = null;\r\n\t\t\tdelete empty.constructor;\r\n\t\t\tdelete empty.hasOwnProperty;\r\n\t\t\tdelete empty.propertyIsEnumerable;\r\n\t\t\tdelete empty.isPrototypeOf;\r\n\t\t\tdelete empty.toLocaleString;\r\n\t\t\tdelete empty.toString;\r\n\t\t\tdelete empty.valueOf;\r\n\t\t\tvar Empty = function Empty() {};\r\n\t\t\tEmpty.prototype = empty;\r\n\t\t\t// short-circuit future calls\r\n\t\t\tcreateEmpty = function () {\r\n\t\t\t\treturn new Empty();\r\n\t\t\t};\r\n\t\t\treturn new Empty();\r\n\t\t};\r\n\t}\r\n\r\n\tfunction T() {}\r\n\r\n\tCreateMethodProperty(Object, 'create', function create(O, properties) {\r\n\t\t// 1. If Type(O) is neither Object nor Null, throw a TypeError exception.\r\n\t\tif (Type(O) !== 'object' && Type(O) !== 'null') {\r\n\t\t\tthrow new TypeError('Object prototype may only be an Object or null');\r\n\t\t}\r\n\t\tif (Type(O) === 'null') {\r\n\t\t\tvar obj = createEmpty();\r\n\t\t} else {\r\n\t\t\t// 2. Let obj be ObjectCreate(O).\r\n\t\t\tT.prototype = O;\r\n\t\t\tobj = new T();\r\n\t\t\tobj.__proto__ = O;\r\n\r\n\r\n\t\t\tobj.constructor.prototype = O;\r\n\t\t\tobj.__proto__ = O;\r\n\t\t}\r\n\r\n\t\t// 3. If Properties is not undefined, then\r\n\t\tif (1 in arguments) {\r\n\t\t\t// a. Return ? ObjectDefineProperties(obj, Properties).\r\n\t\t\treturn Object.defineProperties(obj, properties);\r\n\t\t}\r\n\r\n\t\treturn obj;\r\n\t});\r\n}());\r\n\r\n}\r\n\r\n\r\n// _ESAbstract.OrdinaryCreateFromConstructor\r\n/* global GetPrototypeFromConstructor */\r\n// 9.1.13. OrdinaryCreateFromConstructor ( constructor, intrinsicDefaultProto [ , internalSlotsList ] )\r\nfunction OrdinaryCreateFromConstructor(constructor, intrinsicDefaultProto) { // eslint-disable-line no-unused-vars\r\n\tvar internalSlotsList = arguments[2] || {};\r\n\t// 1. Assert: intrinsicDefaultProto is a String value that is this specification's name of an intrinsic object.\r\n\t// The corresponding object must be an intrinsic that is intended to be used as the[[Prototype]] value of an object.\r\n\r\n\t// 2. Let proto be ? GetPrototypeFromConstructor(constructor, intrinsicDefaultProto).\r\n\tvar proto = GetPrototypeFromConstructor(constructor, intrinsicDefaultProto);\r\n\r\n\t// 3. Return ObjectCreate(proto, internalSlotsList).\r\n\t// Polyfill.io - We do not pass internalSlotsList to Object.create because Object.create does not use the default ordinary object definitions specified in 9.1.\r\n\tvar obj = Object.create(proto);\r\n\tfor (var name in internalSlotsList) {\r\n\t\tif (Object.prototype.hasOwnProperty.call(internalSlotsList, name)) {\r\n\t\t\tObject.defineProperty(obj, name, {\r\n\t\t\t\tconfigurable: true,\r\n\t\t\t\tenumerable: false,\r\n\t\t\t\twritable: true,\r\n\t\t\t\tvalue: internalSlotsList[name]\r\n\t\t\t});\r\n\t\t}\r\n\t}\r\n\treturn obj;\r\n}\r\n\r\n// _ESAbstract.Construct\r\n/* global IsConstructor, OrdinaryCreateFromConstructor, Call */\r\n// 7.3.13. Construct ( F [ , argumentsList [ , newTarget ]] )\r\nfunction Construct(F /* [ , argumentsList [ , newTarget ]] */) { // eslint-disable-line no-unused-vars\r\n\t// 1. If newTarget is not present, set newTarget to F.\r\n\tvar newTarget = arguments.length > 2 ? arguments[2] : F;\r\n\r\n\t// 2. If argumentsList is not present, set argumentsList to a new empty List.\r\n\tvar argumentsList = arguments.length > 1 ? arguments[1] : [];\r\n\r\n\t// 3. Assert: IsConstructor(F) is true.\r\n\tif (!IsConstructor(F)) {\r\n\t\tthrow new TypeError('F must be a constructor.');\r\n\t}\r\n\r\n\t// 4. Assert: IsConstructor(newTarget) is true.\r\n\tif (!IsConstructor(newTarget)) {\r\n\t\tthrow new TypeError('newTarget must be a constructor.');\r\n\t}\r\n\r\n\t// 5. Return ? F.[[Construct]](argumentsList, newTarget).\r\n\t// Polyfill.io - If newTarget is the same as F, it is equivalent to new F(...argumentsList).\r\n\tif (newTarget === F) {\r\n\t\treturn new (Function.prototype.bind.apply(F, [null].concat(argumentsList)))();\r\n\t} else {\r\n\t\t// Polyfill.io - This is mimicking section 9.2.2 step 5.a.\r\n\t\tvar obj = OrdinaryCreateFromConstructor(newTarget, Object.prototype);\r\n\t\treturn Call(F, obj, argumentsList);\r\n\t}\r\n}\r\n\r\n// _ESAbstract.ArraySpeciesCreate\r\n/* global IsArray, ArrayCreate, Get, Type, IsConstructor, Construct */\r\n// 9.4.2.3. ArraySpeciesCreate ( originalArray, length )\r\nfunction ArraySpeciesCreate(originalArray, length) { // eslint-disable-line no-unused-vars\r\n\t// 1. Assert: length is an integer Number ≥ 0.\r\n\t// 2. If length is -0, set length to +0.\r\n\tif (length === 0 && 1/length === -Infinity) {\r\n\t\tlength = 0;\r\n\t}\r\n\r\n\t// 3. Let isArray be ? IsArray(originalArray).\r\n\tvar isArray = IsArray(originalArray);\r\n\r\n\t// 4. If isArray is false, return ? ArrayCreate(length).\r\n\tif (isArray === false) {\r\n\t\treturn ArrayCreate(length);\r\n\t}\r\n\r\n\t// 5. Let C be ? Get(originalArray, \"constructor\").\r\n\tvar C = Get(originalArray, 'constructor');\r\n\r\n\t// Polyfill.io - We skip this section as not sure how to make a cross-realm normal Array, a same-realm Array.\r\n\t// 6. If IsConstructor(C) is true, then\r\n\t// if (IsConstructor(C)) {\r\n\t\t// a. Let thisRealm be the current Realm Record.\r\n\t\t// b. Let realmC be ? GetFunctionRealm(C).\r\n\t\t// c. If thisRealm and realmC are not the same Realm Record, then\r\n\t\t\t// i. If SameValue(C, realmC.[[Intrinsics]].[[%Array%]]) is true, set C to undefined.\r\n\t// }\r\n\t// 7. If Type(C) is Object, then\r\n\tif (Type(C) === 'object') {\r\n\t\t// a. Set C to ? Get(C, @@species).\r\n\t\tC = 'Symbol' in self && 'species' in self.Symbol ? Get(C, self.Symbol.species) : undefined;\r\n\t\t// b. If C is null, set C to undefined.\r\n\t\tif (C === null) {\r\n\t\t\tC = undefined;\r\n\t\t}\r\n\t}\r\n\t// 8. If C is undefined, return ? ArrayCreate(length).\r\n\tif (C === undefined) {\r\n\t\treturn ArrayCreate(length);\r\n\t}\r\n\t// 9. If IsConstructor(C) is false, throw a TypeError exception.\r\n\tif (!IsConstructor(C)) {\r\n\t\tthrow new TypeError('C must be a constructor');\r\n\t}\r\n\t// 10. Return ? Construct(C, « length »).\r\n\treturn Construct(C, [length]);\r\n}\r\nif (!(\"filter\"in Array.prototype\r\n)) {\r\n\r\n// Array.prototype.filter\r\n/* global CreateMethodProperty, ToObject, ToLength, Get, IsCallable, ArraySpeciesCreate, ToString, HasProperty, ToBoolean, Call, CreateDataPropertyOrThrow */\r\n// 22.1.3.7. Array.prototype.filter ( callbackfn [ , thisArg ] )\r\nCreateMethodProperty(Array.prototype, 'filter', function filter(callbackfn /* [ , thisArg ] */) {\r\n\t// 1. Let O be ? ToObject(this value).\r\n\tvar O = ToObject(this);\r\n\t// 2. Let len be ? ToLength(? Get(O, \"length\")).\r\n\tvar len = ToLength(Get(O, \"length\"));\r\n\t// 3. If IsCallable(callbackfn) is false, throw a TypeError exception.\r\n\tif (IsCallable(callbackfn) === false) {\r\n\t\tthrow new TypeError(callbackfn + ' is not a function');\r\n\t}\r\n\t// 4. If thisArg is present, let T be thisArg; else let T be undefined.\r\n\tvar T = arguments.length > 1 ? arguments[1] : undefined;\r\n\t// 5. Let A be ? ArraySpeciesCreate(O, 0).\r\n\tvar A = ArraySpeciesCreate(O, 0);\r\n\t// 6. Let k be 0.\r\n\tvar k = 0;\r\n\t// 7. Let to be 0.\r\n\tvar to = 0;\r\n\t// 8. Repeat, while k < len\r\n\twhile (k < len) {\r\n\t\t// a. Let Pk be ! ToString(k).\r\n\t\tvar Pk = ToString(k);\r\n\t\t// b. Let kPresent be ? HasProperty(O, Pk).\r\n\t\tvar kPresent = HasProperty(O, Pk);\r\n\t\t// c. If kPresent is true, then\r\n\t\tif (kPresent) {\r\n\t\t\t// i. Let kValue be ? Get(O, Pk).\r\n\t\t\tvar kValue = Get(O, Pk);\r\n\t\t\t// ii. Let selected be ToBoolean(? Call(callbackfn, T, « kValue, k, O »)).\r\n\t\t\tvar selected = ToBoolean(Call(callbackfn, T, [kValue, k, O]));\r\n\t\t\t// iii. If selected is true, then\r\n\t\t\tif (selected) {\r\n\t\t\t\t// 1. Perform ? CreateDataPropertyOrThrow(A, ! ToString(to), kValue)\r\n\t\t\t\tCreateDataPropertyOrThrow(A, ToString(to), kValue);\r\n\t\t\t\t// 2. Increase to by 1.\r\n\t\t\t\tto = to + 1;\r\n\t\t\t}\r\n\r\n\t\t}\r\n\t\t// d. Increase k by 1.\r\n\t\tk = k + 1;\r\n\t}\r\n\t// 9. Return A.\r\n\treturn A;\r\n});\r\n\r\n}\r\n\r\nif (!(\"map\"in Array.prototype\r\n)) {\r\n\r\n// Array.prototype.map\r\n/* global ArraySpeciesCreate, Call, CreateDataPropertyOrThrow, CreateMethodProperty, Get, HasProperty, IsCallable, ToLength, ToObject, ToString */\r\n// 22.1.3.16. Array.prototype.map ( callbackfn [ , thisArg ] )\r\nCreateMethodProperty(Array.prototype, 'map', function map(callbackfn /* [ , thisArg ] */) {\r\n\t// 1. Let O be ? ToObject(this value).\r\n\tvar O = ToObject(this);\r\n\t// 2. Let len be ? ToLength(? Get(O, \"length\")).\r\n\tvar len = ToLength(Get(O, \"length\"));\r\n\t// 3. If IsCallable(callbackfn) is false, throw a TypeError exception.\r\n\tif (IsCallable(callbackfn) === false) {\r\n\t\tthrow new TypeError(callbackfn + ' is not a function');\r\n\t}\r\n\t// 4. If thisArg is present, let T be thisArg; else let T be undefined.\r\n\tvar T = arguments.length > 1 ? arguments[1] : undefined;\r\n\t// 5. Let A be ? ArraySpeciesCreate(O, len).\r\n\tvar A = ArraySpeciesCreate(O, len);\r\n\t// 6. Let k be 0.\r\n\tvar k = 0;\r\n\t// 7. Repeat, while k < len\r\n\twhile (k < len) {\r\n\t\t// a. Let Pk be ! ToString(k).\r\n\t\tvar Pk = ToString(k);\r\n\t\t// b. Let kPresent be ? HasProperty(O, Pk).\r\n\t\tvar kPresent = HasProperty(O, Pk);\r\n\t\t// c. If kPresent is true, then\r\n\t\tif (kPresent) {\r\n\t\t\t// i. Let kValue be ? Get(O, Pk).\r\n\t\t\tvar kValue = Get(O, Pk);\r\n\t\t\t// ii. Let mappedValue be ? Call(callbackfn, T, « kValue, k, O »).\r\n\t\t\tvar mappedValue = Call(callbackfn, T, [kValue, k, O]);\r\n\t\t\t// iii. Perform ? CreateDataPropertyOrThrow(A, Pk, mappedValue).\r\n\t\t\tCreateDataPropertyOrThrow(A, Pk, mappedValue);\r\n\t\t}\r\n\t\t// d. Increase k by 1.\r\n\t\tk = k + 1;\r\n\t}\r\n\t// 8. Return A.\r\n\treturn A;\r\n});\r\n\r\n}\r\n\r\nif (!(\"getOwnPropertyNames\"in Object&&function(){try{return Object.getOwnPropertyNames(1),!0}catch(t){return!1}}()\r\n)) {\r\n\r\n// Object.getOwnPropertyNames\r\n/* global CreateMethodProperty, ToObject */\r\n(function() {\r\n\tvar toString = {}.toString;\r\n\tvar split = \"\".split;\r\n\tvar concat = [].concat;\r\n\tvar hasOwnProperty = Object.prototype.hasOwnProperty;\r\n\tvar nativeGetOwnPropertyNames = Object.getOwnPropertyNames || Object.keys;\r\n\tvar cachedWindowNames =\r\n\t\ttypeof self === \"object\" ? nativeGetOwnPropertyNames(self) : [];\r\n\r\n\t// 19.1.2.10 Object.getOwnPropertyNames ( O )\r\n\tCreateMethodProperty(\r\n\t\tObject,\r\n\t\t\"getOwnPropertyNames\",\r\n\t\tfunction getOwnPropertyNames(O) {\r\n\t\t\tvar object = ToObject(O);\r\n\r\n\t\t\tif (toString.call(object) === \"[object Window]\") {\r\n\t\t\t\ttry {\r\n\t\t\t\t\treturn nativeGetOwnPropertyNames(object);\r\n\t\t\t\t} catch (e) {\r\n\t\t\t\t\t// IE bug where layout engine calls userland Object.getOwnPropertyNames for cross-domain `window` objects\r\n\t\t\t\t\treturn concat.call([], cachedWindowNames);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// Polyfill.io fallback for non-array-like strings which exist in some ES3 user-agents (IE 8)\r\n\t\t\tobject =\r\n\t\t\t\ttoString.call(object) == \"[object String]\"\r\n\t\t\t\t\t? split.call(object, \"\")\r\n\t\t\t\t\t: Object(object);\r\n\r\n\t\t\tvar result = nativeGetOwnPropertyNames(object);\r\n\t\t\tvar extraNonEnumerableKeys = [\"length\", \"prototype\"];\r\n\t\t\tfor (var i = 0; i < extraNonEnumerableKeys.length; i++) {\r\n\t\t\t\tvar key = extraNonEnumerableKeys[i];\r\n\t\t\t\tif (hasOwnProperty.call(object, key) && !result.includes(key)) {\r\n\t\t\t\t\tresult.push(key);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tif (result.includes(\"__proto__\")) {\r\n\t\t\t\tvar index = result.indexOf(\"__proto__\");\r\n\t\t\t\tresult.splice(index, 1);\r\n\t\t\t}\r\n\r\n\t\t\treturn result;\r\n\t\t}\r\n\t);\r\n})();\r\n\r\n}\r\n\r\nif (!(\"Symbol\"in self&&0===self.Symbol.length\r\n)) {\r\n\r\n// Symbol\r\n// A modification of https://github.com/WebReflection/get-own-property-symbols\r\n// (C) Andrea Giammarchi - MIT Licensed\r\n\r\n/* global Type */\r\n(function (Object,  GOPS, global) {\r\n\t'use strict'; //so that ({}).toString.call(null) returns the correct [object Null] rather than [object Window]\r\n\r\n\tvar supportsGetters = (function () {\r\n\t\t// supports getters\r\n\t\ttry {\r\n\t\t\tvar a = {};\r\n\t\t\tObject.defineProperty(a, \"t\", {\r\n\t\t\t\tconfigurable: true,\r\n\t\t\t\tenumerable: false,\r\n\t\t\t\tget: function () {\r\n\t\t\t\t\treturn true;\r\n\t\t\t\t},\r\n\t\t\t\tset: undefined\r\n\t\t\t});\r\n\t\t\treturn !!a.t;\r\n\t\t} catch (e) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t}());\r\n\r\n\tvar\tsetDescriptor;\r\n\tvar id = 0;\r\n\tvar random = '' + Math.random();\r\n\tvar prefix = '__\\x01symbol:';\r\n\tvar prefixLength = prefix.length;\r\n\tvar internalSymbol = '__\\x01symbol@@' + random;\r\n\tvar emptySymbolLookup = {};\r\n\tvar DP = 'defineProperty';\r\n\tvar DPies = 'defineProperties';\r\n\tvar GOPN = 'getOwnPropertyNames';\r\n\tvar GOPD = 'getOwnPropertyDescriptor';\r\n\tvar PIE = 'propertyIsEnumerable';\r\n\tvar ObjectProto = Object.prototype;\r\n\tvar hOP = ObjectProto.hasOwnProperty;\r\n\tvar pIE = ObjectProto[PIE];\r\n\tvar toString = ObjectProto.toString;\r\n\tvar concat = Array.prototype.concat;\r\n\tvar cachedWindowNames = Object.getOwnPropertyNames ? Object.getOwnPropertyNames(self) : [];\r\n\tvar nGOPN = Object[GOPN];\r\n\tvar gOPN = function getOwnPropertyNames (obj) {\r\n\t\tif (toString.call(obj) === '[object Window]') {\r\n\t\t\ttry {\r\n\t\t\t\treturn nGOPN(obj);\r\n\t\t\t} catch (e) {\r\n\t\t\t\t// IE bug where layout engine calls userland gOPN for cross-domain `window` objects\r\n\t\t\t\treturn concat.call([], cachedWindowNames);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn nGOPN(obj);\r\n\t};\r\n\tvar gOPD = Object[GOPD];\r\n\tvar objectCreate = Object.create;\r\n\tvar objectKeys = Object.keys;\r\n\tvar freeze = Object.freeze || Object;\r\n\tvar objectDefineProperty = Object[DP];\r\n\tvar $defineProperties = Object[DPies];\r\n\tvar descriptor = gOPD(Object, GOPN);\r\n\tvar addInternalIfNeeded = function (o, uid, enumerable) {\r\n\t\tif (!hOP.call(o, internalSymbol)) {\r\n\t\t\ttry {\r\n\t\t\t\tobjectDefineProperty(o, internalSymbol, {\r\n\t\t\t\t\tenumerable: false,\r\n\t\t\t\t\tconfigurable: false,\r\n\t\t\t\t\twritable: false,\r\n\t\t\t\t\tvalue: {}\r\n\t\t\t\t});\r\n\t\t\t} catch (e) {\r\n\t\t\t\to[internalSymbol] = {};\r\n\t\t\t}\r\n\t\t}\r\n\t\to[internalSymbol]['@@' + uid] = enumerable;\r\n\t};\r\n\tvar createWithSymbols = function (proto, descriptors) {\r\n\t\tvar self = objectCreate(proto);\r\n\t\tgOPN(descriptors).forEach(function (key) {\r\n\t\t\tif (propertyIsEnumerable.call(descriptors, key)) {\r\n\t\t\t\t$defineProperty(self, key, descriptors[key]);\r\n\t\t\t}\r\n\t\t});\r\n\t\treturn self;\r\n\t};\r\n\tvar copyAsNonEnumerable = function (descriptor) {\r\n\t\tvar newDescriptor = objectCreate(descriptor);\r\n\t\tnewDescriptor.enumerable = false;\r\n\t\treturn newDescriptor;\r\n\t};\r\n\tvar get = function get(){};\r\n\tvar onlyNonSymbols = function (name) {\r\n\t\treturn name != internalSymbol &&\r\n\t\t\t!hOP.call(source, name);\r\n\t};\r\n\tvar onlySymbols = function (name) {\r\n\t\treturn name != internalSymbol &&\r\n\t\t\thOP.call(source, name);\r\n\t};\r\n\tvar propertyIsEnumerable = function propertyIsEnumerable(key) {\r\n\t\tvar uid = '' + key;\r\n\t\treturn onlySymbols(uid) ? (\r\n\t\t\thOP.call(this, uid) &&\r\n\t\t\tthis[internalSymbol] && this[internalSymbol]['@@' + uid]\r\n\t\t) : pIE.call(this, key);\r\n\t};\r\n\tvar setAndGetSymbol = function (uid) {\r\n\t\tvar descriptor = {\r\n\t\t\tenumerable: false,\r\n\t\t\tconfigurable: true,\r\n\t\t\tget: get,\r\n\t\t\tset: function (value) {\r\n\t\t\tsetDescriptor(this, uid, {\r\n\t\t\t\tenumerable: false,\r\n\t\t\t\tconfigurable: true,\r\n\t\t\t\twritable: true,\r\n\t\t\t\tvalue: value\r\n\t\t\t});\r\n\t\t\taddInternalIfNeeded(this, uid, true);\r\n\t\t\t}\r\n\t\t};\r\n\t\ttry {\r\n\t\t\tobjectDefineProperty(ObjectProto, uid, descriptor);\r\n\t\t} catch (e) {\r\n\t\t\tObjectProto[uid] = descriptor.value;\r\n\t\t}\r\n\t\tsource[uid] = objectDefineProperty(\r\n\t\t\tObject(uid),\r\n\t\t\t'constructor',\r\n\t\t\tsourceConstructor\r\n\t\t);\r\n\t\tvar description = gOPD(Symbol.prototype, 'description');\r\n\t\tif (description) {\r\n\t\t\tobjectDefineProperty(\r\n\t\t\t\tsource[uid],\r\n\t\t\t\t'description',\r\n\t\t\t\tdescription\r\n\t\t\t);\r\n\t\t}\r\n\t\treturn freeze(source[uid]);\r\n\t};\r\n\r\n\tvar symbolDescription = function (s) {\r\n\t\tvar sym = thisSymbolValue(s);\r\n\r\n\t\t// 3. Return sym.[[Description]].\r\n\t\tif (supportsInferredNames) {\r\n\t\t\tvar name = getInferredName(sym);\r\n\t\t\tif (name !== \"\") {\r\n\t\t\t\treturn name.slice(1, -1); // name.slice('['.length, -']'.length);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (emptySymbolLookup[sym] !== undefined) {\r\n\t\t\treturn emptySymbolLookup[sym];\r\n\t\t}\r\n\r\n\t\tvar string = sym.toString();\r\n\t\tvar randomStartIndex = string.lastIndexOf(\"0.\");\r\n\t\tstring = string.slice(10, randomStartIndex);\r\n\r\n\t\tif (string === \"\") {\r\n\t\t\treturn undefined;\r\n\t\t}\r\n\t\treturn string;\r\n\t};\r\n\r\n\tvar Symbol = function Symbol() {\r\n\t\tvar description = arguments[0];\r\n\t\tif (this instanceof Symbol) {\r\n\t\t\tthrow new TypeError('Symbol is not a constructor');\r\n\t\t}\r\n\r\n\t\tvar uid = prefix.concat(description || '', random, ++id);\r\n\r\n\t\tif (description !== undefined && (description === null || isNaN(description) || String(description) === \"\")) {\r\n\t\t\temptySymbolLookup[uid] = String(description);\r\n\t\t}\r\n\r\n\t\tvar that = setAndGetSymbol(uid);\r\n\r\n\t\tif (!supportsGetters) {\r\n\t\t\tObject.defineProperty(that, \"description\", {\r\n\t\t\t\tconfigurable: true,\r\n\t\t\t\tenumerable: false,\r\n\t\t\t\tvalue: symbolDescription(that)\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\treturn that;\r\n\t};\r\n\r\n\tvar source = objectCreate(null);\r\n\tvar sourceConstructor = {value: Symbol};\r\n\tvar sourceMap = function (uid) {\r\n\t\treturn source[uid];\r\n\t\t};\r\n\tvar $defineProperty = function defineProperty(o, key, descriptor) {\r\n\t\tvar uid = '' + key;\r\n\t\tif (onlySymbols(uid)) {\r\n\t\t\tsetDescriptor(o, uid, descriptor.enumerable ?\r\n\t\t\t\tcopyAsNonEnumerable(descriptor) : descriptor);\r\n\t\t\taddInternalIfNeeded(o, uid, !!descriptor.enumerable);\r\n\t\t} else {\r\n\t\t\tobjectDefineProperty(o, key, descriptor);\r\n\t\t}\r\n\t\treturn o;\r\n\t};\r\n\r\n\tvar onlyInternalSymbols = function (obj) {\r\n\t\treturn function (name) {\r\n\t\t\treturn hOP.call(obj, internalSymbol) && hOP.call(obj[internalSymbol], '@@' + name);\r\n\t\t};\r\n\t};\r\n\tvar $getOwnPropertySymbols = function getOwnPropertySymbols(o) {\r\n\t\treturn gOPN(o).filter(o === ObjectProto ? onlyInternalSymbols(o) : onlySymbols).map(sourceMap);\r\n\t\t}\r\n\t;\r\n\r\n\tdescriptor.value = $defineProperty;\r\n\tobjectDefineProperty(Object, DP, descriptor);\r\n\r\n\tdescriptor.value = $getOwnPropertySymbols;\r\n\tobjectDefineProperty(Object, GOPS, descriptor);\r\n\r\n\tdescriptor.value = function getOwnPropertyNames(o) {\r\n\t\treturn gOPN(o).filter(onlyNonSymbols);\r\n\t};\r\n\tobjectDefineProperty(Object, GOPN, descriptor);\r\n\r\n\tdescriptor.value = function defineProperties(o, descriptors) {\r\n\t\tvar symbols = $getOwnPropertySymbols(descriptors);\r\n\t\tif (symbols.length) {\r\n\t\tobjectKeys(descriptors).concat(symbols).forEach(function (uid) {\r\n\t\t\tif (propertyIsEnumerable.call(descriptors, uid)) {\r\n\t\t\t$defineProperty(o, uid, descriptors[uid]);\r\n\t\t\t}\r\n\t\t});\r\n\t\t} else {\r\n\t\t$defineProperties(o, descriptors);\r\n\t\t}\r\n\t\treturn o;\r\n\t};\r\n\tobjectDefineProperty(Object, DPies, descriptor);\r\n\r\n\tdescriptor.value = propertyIsEnumerable;\r\n\tobjectDefineProperty(ObjectProto, PIE, descriptor);\r\n\r\n\tdescriptor.value = Symbol;\r\n\tobjectDefineProperty(global, 'Symbol', descriptor);\r\n\r\n\t// defining `Symbol.for(key)`\r\n\tdescriptor.value = function (key) {\r\n\t\tvar uid = prefix.concat(prefix, key, random);\r\n\t\treturn uid in ObjectProto ? source[uid] : setAndGetSymbol(uid);\r\n\t};\r\n\tobjectDefineProperty(Symbol, 'for', descriptor);\r\n\r\n\t// defining `Symbol.keyFor(symbol)`\r\n\tdescriptor.value = function (symbol) {\r\n\t\tif (onlyNonSymbols(symbol))\r\n\t\tthrow new TypeError(symbol + ' is not a symbol');\r\n\t\treturn hOP.call(source, symbol) ?\r\n\t\tsymbol.slice(prefixLength * 2, -random.length) :\r\n\t\tvoid 0\r\n\t\t;\r\n\t};\r\n\tobjectDefineProperty(Symbol, 'keyFor', descriptor);\r\n\r\n\tdescriptor.value = function getOwnPropertyDescriptor(o, key) {\r\n\t\tvar descriptor = gOPD(o, key);\r\n\t\tif (descriptor && onlySymbols(key)) {\r\n\t\tdescriptor.enumerable = propertyIsEnumerable.call(o, key);\r\n\t\t}\r\n\t\treturn descriptor;\r\n\t};\r\n\tobjectDefineProperty(Object, GOPD, descriptor);\r\n\r\n\tdescriptor.value = function create(proto, descriptors) {\r\n\t\treturn arguments.length === 1 || typeof descriptors === \"undefined\" ?\r\n\t\tobjectCreate(proto) :\r\n\t\tcreateWithSymbols(proto, descriptors);\r\n\t};\r\n\r\n\tobjectDefineProperty(Object, 'create', descriptor);\r\n\r\n\tvar strictModeSupported = (function(){ 'use strict'; return this; }).call(null) === null;\r\n\tif (strictModeSupported) {\r\n\t\tdescriptor.value = function () {\r\n\t\t\tvar str = toString.call(this);\r\n\t\t\treturn (str === '[object String]' && onlySymbols(this)) ? '[object Symbol]' : str;\r\n\t\t};\r\n\t} else {\r\n\t\tdescriptor.value = function () {\r\n\t\t\t// https://github.com/Financial-Times/polyfill-library/issues/164#issuecomment-486965300\r\n\t\t\t// Polyfill.io this code is here for the situation where a browser does not\r\n\t\t\t// support strict mode and is executing `Object.prototype.toString.call(null)`.\r\n\t\t\t// This code ensures that we return the correct result in that situation however,\r\n\t\t\t// this code also introduces a bug where it will return the incorrect result for\r\n\t\t\t// `Object.prototype.toString.call(window)`. We can't have the correct result for\r\n\t\t\t// both `window` and `null`, so we have opted for `null` as we believe this is the more\r\n\t\t\t// common situation.\r\n\t\t\tif (this === window) {\r\n\t\t\t\treturn '[object Null]';\r\n\t\t\t}\r\n\r\n\t\t\tvar str = toString.call(this);\r\n\t\t\treturn (str === '[object String]' && onlySymbols(this)) ? '[object Symbol]' : str;\r\n\t\t};\r\n\t}\r\n\tobjectDefineProperty(ObjectProto, 'toString', descriptor);\r\n\r\n\tsetDescriptor = function (o, key, descriptor) {\r\n\t\tvar protoDescriptor = gOPD(ObjectProto, key);\r\n\t\tdelete ObjectProto[key];\r\n\t\tobjectDefineProperty(o, key, descriptor);\r\n\t\tif (o !== ObjectProto) {\r\n\t\t\tobjectDefineProperty(ObjectProto, key, protoDescriptor);\r\n\t\t}\r\n\t};\r\n\r\n\t// The abstract operation thisSymbolValue(value) performs the following steps:\r\n\tfunction thisSymbolValue(value) {\r\n\t\t// 1. If Type(value) is Symbol, return value.\r\n\t\tif (Type(value) === \"symbol\") {\r\n\t\t\treturn value;\r\n\t\t}\r\n\t\t// 2. If Type(value) is Object and value has a [[SymbolData]] internal slot, then\r\n\t\t// a. Let s be value.[[SymbolData]].\r\n\t\t// b. Assert: Type(s) is Symbol.\r\n\t\t// c. Return s.\r\n\t\t// 3. Throw a TypeError exception.\r\n\t\tthrow TypeError(value + \" is not a symbol\");\r\n\t}\r\n\r\n\t// Symbol.prototype.description\r\n\tif (function () {\r\n\t\t// supports getters\r\n\t\ttry {\r\n\t\t\tvar a = {};\r\n\t\t\tObject.defineProperty(a, \"t\", {\r\n\t\t\t\tconfigurable: true,\r\n\t\t\t\tenumerable: false,\r\n\t\t\t\tget: function() {\r\n\t\t\t\t\treturn true;\r\n\t\t\t\t},\r\n\t\t\t\tset: undefined\r\n\t\t\t});\r\n\t\t\treturn !!a.t;\r\n\t\t} catch (e) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t}()) {\r\n\t\tvar getInferredName;\r\n\t\ttry {\r\n\t\t\t// eslint-disable-next-line no-new-func\r\n\t\t\tgetInferredName = Function(\"s\", \"var v = s.valueOf(); return { [v]() {} }[v].name;\");\r\n\t\t\t// eslint-disable-next-line no-empty\r\n\t\t} catch (e) { }\r\n\r\n\t\tvar inferred = function () { };\r\n\t\tvar supportsInferredNames = getInferredName && inferred.name === \"inferred\" ? getInferredName : null;\r\n\r\n\r\n\t\t// 19.4.3.2 get Symbol.prototype.description\r\n\t\tObject.defineProperty(global.Symbol.prototype, \"description\", {\r\n\t\t\tconfigurable: true,\r\n\t\t\tenumerable: false,\r\n\t\t\tget: function () {\r\n\t\t\t\t// 1. Let s be the this value.\r\n\t\t\t\tvar s = this;\r\n\t\t\t\treturn symbolDescription(s);\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n\r\n}(Object, 'getOwnPropertySymbols', self));\r\n\r\n}\r\n\r\nif (!(\"Symbol\"in self&&\"iterator\"in self.Symbol\r\n)) {\r\n\r\n// Symbol.iterator\r\nObject.defineProperty(self.Symbol, 'iterator', { value: self.Symbol('iterator') });\r\n\r\n}\r\n\r\n\r\n// _ESAbstract.GetIterator\r\n/* global GetMethod, Symbol, Call, Type, GetV */\r\n// 7.4.1. GetIterator ( obj [ , method ] )\r\n// The abstract operation GetIterator with argument obj and optional argument method performs the following steps:\r\nfunction GetIterator(obj /*, method */) { // eslint-disable-line no-unused-vars\r\n\t// 1. If method is not present, then\r\n\t\t// a. Set method to ? GetMethod(obj, @@iterator).\r\n\tvar method = arguments.length > 1 ? arguments[1] : GetMethod(obj, Symbol.iterator);\r\n\t// 2. Let iterator be ? Call(method, obj).\r\n\tvar iterator = Call(method, obj);\r\n\t// 3. If Type(iterator) is not Object, throw a TypeError exception.\r\n\tif (Type(iterator) !== 'object') {\r\n\t\tthrow new TypeError('bad iterator');\r\n\t}\r\n\t// 4. Let nextMethod be ? GetV(iterator, \"next\").\r\n\tvar nextMethod = GetV(iterator, \"next\");\r\n\t// 5. Let iteratorRecord be Record {[[Iterator]]: iterator, [[NextMethod]]: nextMethod, [[Done]]: false}.\r\n\tvar iteratorRecord = Object.create(null);\r\n\titeratorRecord['[[Iterator]]'] = iterator;\r\n\titeratorRecord['[[NextMethod]]'] = nextMethod;\r\n\titeratorRecord['[[Done]]'] = false;\r\n\t// 6. Return iteratorRecord.\r\n\treturn iteratorRecord;\r\n}\r\nif (!(\"Symbol\"in self&&\"species\"in self.Symbol\r\n)) {\r\n\r\n// Symbol.species\r\n/* global Symbol */\r\nObject.defineProperty(Symbol, 'species', { value: Symbol('species') });\r\n\r\n}\r\n\r\nif (!(\"Map\"in self&&function(t){try{var n=new t.Map([[1,1],[2,2]])\r\nreturn 0===t.Map.length&&2===n.size&&\"Symbol\"in t&&\"iterator\"in t.Symbol&&\"function\"==typeof n[t.Symbol.iterator]}catch(e){return!1}}(self)\r\n)) {\r\n\r\n// Map\r\n/* global CreateIterResultObject, CreateMethodProperty, GetIterator, IsCallable, IteratorClose, IteratorStep, IteratorValue, OrdinaryCreateFromConstructor, SameValueZero, Type, Symbol */\r\n(function (global) {\r\n\tvar supportsGetters = (function () {\r\n\t\ttry {\r\n\t\t\tvar a = {};\r\n\t\t\tObject.defineProperty(a, 't', {\r\n\t\t\t\tconfigurable: true,\r\n\t\t\t\tenumerable: false,\r\n\t\t\t\tget: function () {\r\n\t\t\t\t\treturn true;\r\n\t\t\t\t},\r\n\t\t\t\tset: undefined\r\n\t\t\t});\r\n\t\t\treturn !!a.t;\r\n\t\t} catch (e) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t}());\r\n\r\n\t// Need an internal counter to assign unique IDs to a key map\r\n\tvar _uniqueHashId = 0;\r\n\t// Create a unique key name for storing meta data on functions and objects to enable lookups in hash table\r\n\tvar _metaKey = Symbol('meta_' + ((Math.random() * 100000000) + '').replace('.', ''));\r\n\r\n\t/**\r\n\t * hashKey()\r\n\t * Function that given a key of `any` type, returns a string key value to enable hash map optimization for accessing Map data structure\r\n\t * @param {string|integer|function|object} recordKey - Record key to normalize to string accessor for hash map\r\n\t * @returns {string|false} - Returns a hashed string value or false if non extensible object key\r\n\t */\r\n\tvar hashKey = function(recordKey) {\r\n\t\t// Check to see if we are dealing with object or function type.\r\n\t\tif (typeof recordKey === 'object' ? recordKey !== null : typeof recordKey === 'function') {\r\n\t\t\t// Check to see if we are dealing with a non extensible object\r\n\t\t\tif (!Object.isExtensible(recordKey)) {\r\n\t\t\t\t// Return `false`\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t\tif (!Object.prototype.hasOwnProperty.call(recordKey, _metaKey)) {\r\n\t\t\t\tvar uniqueHashKey = typeof(recordKey)+'-'+(++_uniqueHashId);\r\n\t\t\t\tObject.defineProperty(recordKey, _metaKey, {\r\n\t\t\t\t\tconfigurable: false,\r\n\t\t\t\t\tenumerable: false,\r\n\t\t\t\t\twritable: false,\r\n\t\t\t\t\tvalue: uniqueHashKey\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t\t// Return previously defined hashed key\r\n\t\t\treturn recordKey[_metaKey];\r\n\t\t}\r\n\t\t// If this is just a primitive, we can cast it to a string and return it\r\n\t\treturn ''+recordKey;\r\n\t};\r\n\r\n\t/**\r\n\t * getRecordIndex()\r\n\t * Function that given a Map and a key of `any` type, returns an index number that coorelates with a record found in `this._keys[index]` and `this._values[index]`\r\n\t * @param {Map} map - Map structure\r\n\t * @param {string|number|function|object} recordKey - Record key to normalize to string accessor for hash map\r\n\t * @returns {number|false} - Returns either a index to access map._keys and map._values, or false if not found\r\n\t */\r\n\tvar getRecordIndex = function(map, recordKey) {\r\n\t\tvar hashedKey = hashKey(recordKey); // Casts key to unique string (unless already string or number)\r\n\t\tif (hashedKey === false) {\r\n\t\t\t// We have to iterate through our Map structure because `recordKey` is non-primitive and not extensible\r\n\t\t\treturn getRecordIndexSlow(map, recordKey);\r\n\t\t}\r\n\t\tvar recordIndex = map._table[hashedKey]; // O(1) access to record\r\n\t\treturn recordIndex !== undefined ? recordIndex : false;\r\n\t};\r\n\r\n\t/**\r\n\t * getRecordIndexSlow()\r\n\t * Alternative (and slower) function to `getRecordIndex()`.  Necessary for looking up non-extensible object keys.\r\n\t * @param {Map} map - Map structure\r\n\t * @param {string|number|function|object} recordKey - Record key to normalize to string accessor for hash map\r\n\t * @returns {number|false} - Returns either a index to access map._keys and map._values, or false if not found\r\n\t */\r\n\tvar getRecordIndexSlow = function(map, recordKey) {\r\n\t\t// We have to iterate through our Map structure because `recordKey` is non-primitive and not extensible\r\n\t\tfor (var i = 0; i < map._keys.length; i++) {\r\n\t\t\tvar _recordKey = map._keys[i];\r\n\t\t\tif (_recordKey !== undefMarker && SameValueZero(_recordKey, recordKey)) {\r\n\t\t\t\treturn i;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn false;\r\n\t};\r\n\r\n\t/**\r\n\t * setHashIndex()\r\n\t * Function that given a map, key of `any` type, and a value, creates a new entry in Map hash table\r\n\t * @param {Map} map\r\n\t * @param {string|number|function|object} recordKey - Key to translate into normalized key for hash map\r\n\t * @param {number|bool} recordIndex - new record index for the hashedKey or `false` to delete the record index for the hashedKey\r\n\t * @returns {bool} - indicates success of operation\r\n\t */\r\n\tvar setHashIndex = function(map, recordKey, recordIndex) {\r\n\t\tvar hashedKey = hashKey(recordKey);\r\n\t\tif (hashedKey === false) {\r\n\t\t\t// If hashed key is false, the recordKey is an object which is not extensible.\r\n\t\t\t// That indicates we cannot use the hash map for it, so this operation becomes no-op.\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\tif (recordIndex === false) {\r\n\t\t\tdelete map._table[hashedKey];\r\n\t\t} else {\r\n\t\t\tmap._table[hashedKey] = recordIndex;\r\n\t\t}\r\n\t\treturn true;\r\n\t};\r\n\r\n\t// Deleted map items mess with iterator pointers, so rather than removing them mark them as deleted. Can't use undefined or null since those both valid keys so use a private symbol.\r\n\tvar undefMarker = Symbol('undef');\r\n\t// 23.1.1.1 Map ( [ iterable ] )\r\n\tvar Map = function Map(/* iterable */) {\r\n\t\t// 1. If NewTarget is undefined, throw a TypeError exception.\r\n\t\tif (!(this instanceof Map)) {\r\n\t\t\tthrow new TypeError('Constructor Map requires \"new\"');\r\n\t\t}\r\n\t\t// 2. Let map be ? OrdinaryCreateFromConstructor(NewTarget, \"%MapPrototype%\", « [[MapData]] »).\r\n\t\tvar map = OrdinaryCreateFromConstructor(this, Map.prototype, {\r\n\t\t\t_table: {}, // O(1) access table for retrieving records\r\n\t\t\t_keys: [],\r\n\t\t\t_values: [],\r\n\t\t\t_size: 0,\r\n\t\t\t_es6Map: true\r\n\t\t});\r\n\r\n\t\t// 3. Set map.[[MapData]] to a new empty List.\r\n\t\t// Polyfill.io - This step was done as part of step two.\r\n\r\n\t\t// Some old engines do not support ES5 getters/setters.  Since Map only requires these for the size property, we can fall back to setting the size property statically each time the size of the map changes.\r\n\t\tif (!supportsGetters) {\r\n\t\t\tObject.defineProperty(map, 'size', {\r\n\t\t\t\tconfigurable: true,\r\n\t\t\t\tenumerable: false,\r\n\t\t\t\twritable: true,\r\n\t\t\t\tvalue: 0\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\t// 4. If iterable is not present, let iterable be undefined.\r\n\t\tvar iterable = arguments.length > 0 ? arguments[0] : undefined;\r\n\r\n\t\t// 5. If iterable is either undefined or null, return map.\r\n\t\tif (iterable === null || iterable === undefined) {\r\n\t\t\treturn map;\r\n\t\t}\r\n\r\n\t\t// 6. Let adder be ? Get(map, \"set\").\r\n\t\tvar adder = map.set;\r\n\r\n\t\t// 7. If IsCallable(adder) is false, throw a TypeError exception.\r\n\t\tif (!IsCallable(adder)) {\r\n\t\t\tthrow new TypeError(\"Map.prototype.set is not a function\");\r\n\t\t}\r\n\r\n\t\t// 8. Let iteratorRecord be ? GetIterator(iterable).\r\n\t\ttry {\r\n\t\t\tvar iteratorRecord = GetIterator(iterable);\r\n\t\t\t// 9. Repeat,\r\n\t\t\t// eslint-disable-next-line no-constant-condition\r\n\t\t\twhile (true) {\r\n\t\t\t\t// a. Let next be ? IteratorStep(iteratorRecord).\r\n\t\t\t\tvar next = IteratorStep(iteratorRecord);\r\n\t\t\t\t// b. If next is false, return map.\r\n\t\t\t\tif (next === false) {\r\n\t\t\t\t\treturn map;\r\n\t\t\t\t}\r\n\t\t\t\t// c. Let nextItem be ? IteratorValue(next).\r\n\t\t\t\tvar nextItem = IteratorValue(next);\r\n\t\t\t\t// d. If Type(nextItem) is not Object, then\r\n\t\t\t\tif (Type(nextItem) !== 'object') {\r\n\t\t\t\t\t// i. Let error be Completion{[[Type]]: throw, [[Value]]: a newly created TypeError object, [[Target]]: empty}.\r\n\t\t\t\t\ttry {\r\n\t\t\t\t\t\tthrow new TypeError('Iterator value ' + nextItem + ' is not an entry object');\r\n\t\t\t\t\t} catch (error) {\r\n\t\t\t\t\t\t// ii. Return ? IteratorClose(iteratorRecord, error).\r\n\t\t\t\t\t\treturn IteratorClose(iteratorRecord, error);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\ttry {\r\n\t\t\t\t\t// Polyfill.io - The try catch accounts for steps: f, h, and j.\r\n\r\n\t\t\t\t\t// e. Let k be Get(nextItem, \"0\").\r\n\t\t\t\t\tvar k = nextItem[0];\r\n\t\t\t\t\t// f. If k is an abrupt completion, return ? IteratorClose(iteratorRecord, k).\r\n\t\t\t\t\t// g. Let v be Get(nextItem, \"1\").\r\n\t\t\t\t\tvar v = nextItem[1];\r\n\t\t\t\t\t// h. If v is an abrupt completion, return ? IteratorClose(iteratorRecord, v).\r\n\t\t\t\t\t// i. Let status be Call(adder, map, « k.[[Value]], v.[[Value]] »).\r\n\t\t\t\t\tadder.call(map, k, v);\r\n\t\t\t\t} catch (e) {\r\n\t\t\t\t\t// j. If status is an abrupt completion, return ? IteratorClose(iteratorRecord, status).\r\n\t\t\t\t\treturn IteratorClose(iteratorRecord, e);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t} catch (e) {\r\n\t\t\t// Polyfill.io - For user agents which do not have iteration methods on argument objects or arrays, we can special case those.\r\n\t\t\tif (Array.isArray(iterable) ||\r\n\t\t\t\tObject.prototype.toString.call(iterable) === '[object Arguments]' ||\r\n\t\t\t\t// IE 7 & IE 8 return '[object Object]' for the arguments object, we can detect by checking for the existence of the callee property\r\n\t\t\t\t(!!iterable.callee)) {\r\n\t\t\t\tvar index;\r\n\t\t\t\tvar length = iterable.length;\r\n\t\t\t\tfor (index = 0; index < length; index++) {\r\n\t\t\t\t\tadder.call(map, iterable[index][0], iterable[index][1]);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn map;\r\n\t};\r\n\r\n\t// 23.1.2.1. Map.prototype\r\n\t// The initial value of Map.prototype is the intrinsic object %MapPrototype%.\r\n\t// This property has the attributes { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }.\r\n\tObject.defineProperty(Map, 'prototype', {\r\n\t\tconfigurable: false,\r\n\t\tenumerable: false,\r\n\t\twritable: false,\r\n\t\tvalue: {}\r\n\t});\r\n\r\n\t// 23.1.2.2 get Map [ @@species ]\r\n\tif (supportsGetters) {\r\n\t\tObject.defineProperty(Map, Symbol.species, {\r\n\t\t\tconfigurable: true,\r\n\t\t\tenumerable: false,\r\n\t\t\tget: function () {\r\n\t\t\t\t// 1. Return the this value.\r\n\t\t\t\treturn this;\r\n\t\t\t},\r\n\t\t\tset: undefined\r\n\t\t});\r\n\t} else {\r\n\t\tCreateMethodProperty(Map, Symbol.species, Map);\r\n\t}\r\n\r\n\t// 23.1.3.1 Map.prototype.clear ( )\r\n\tCreateMethodProperty(Map.prototype, 'clear', function clear() {\r\n\t\t\t// 1. Let M be the this value.\r\n\t\t\tvar M = this;\r\n\t\t\t// 2. If Type(M) is not Object, throw a TypeError exception.\r\n\t\t\tif (Type(M) !== 'object') {\r\n\t\t\t\tthrow new TypeError('Method Map.prototype.clear called on incompatible receiver ' + Object.prototype.toString.call(M));\r\n\t\t\t}\r\n\t\t\t// 3. If M does not have a [[MapData]] internal slot, throw a TypeError exception.\r\n\t\t\tif (M._es6Map !== true) {\r\n\t\t\t\tthrow new TypeError('Method Map.prototype.clear called on incompatible receiver ' + Object.prototype.toString.call(M));\r\n\t\t\t}\r\n\t\t\t// 4. Let entries be the List that is M.[[MapData]].\r\n\t\t\tvar entries = M._keys;\r\n\t\t\t// 5. For each Record {[[Key]], [[Value]]} p that is an element of entries, do\r\n\t\t\tfor (var i = 0; i < entries.length; i++) {\r\n\t\t\t\t// 5.a. Set p.[[Key]] to empty.\r\n\t\t\t\tM._keys[i] = undefMarker;\r\n\t\t\t\t// 5.b. Set p.[[Value]] to empty.\r\n\t\t\t\tM._values[i] = undefMarker;\r\n\t\t\t}\r\n\t\t\tthis._size = 0;\r\n\t\t\tif (!supportsGetters) {\r\n\t\t\t\tthis.size = this._size;\r\n\t\t\t}\r\n\t\t\t// 5a. Clear lookup table\r\n\t\t\tthis._table = {};\r\n\t\t\t// 6. Return undefined.\r\n\t\t\treturn undefined;\r\n\t\t}\r\n\t);\r\n\r\n\t// 23.1.3.2. Map.prototype.constructor\r\n\tCreateMethodProperty(Map.prototype, 'constructor', Map);\r\n\r\n\t// 23.1.3.3. Map.prototype.delete ( key )\r\n\tCreateMethodProperty(Map.prototype, 'delete', function (key) {\r\n\t\t\t// 1. Let M be the this value.\r\n\t\t\tvar M = this;\r\n\t\t\t// 2. If Type(M) is not Object, throw a TypeError exception.\r\n\t\t\tif (Type(M) !== 'object') {\r\n\t\t\t\tthrow new TypeError('Method Map.prototype.clear called on incompatible receiver ' + Object.prototype.toString.call(M));\r\n\t\t\t}\r\n\t\t\t// 3. If M does not have a [[MapData]] internal slot, throw a TypeError exception.\r\n\t\t\tif (M._es6Map !== true) {\r\n\t\t\t\tthrow new TypeError('Method Map.prototype.clear called on incompatible receiver ' + Object.prototype.toString.call(M));\r\n\t\t\t}\r\n\t\t\t// 4. Let entries be the List that is M.[[MapData]].\r\n\t\t\t// 5. For each Record {[[Key]], [[Value]]} p that is an element of entries, do\r\n\t\t\t\t// 5a. If p.[[Key]] is not empty and SameValueZero(p.[[Key]], key) is true, then\r\n\t\t\t\t\t// i. Set p.[[Key]] to empty.\r\n\t\t\t\t\t// ii. Set p.[[Value]] to empty.\r\n\t\t\t\t\t// ii-a. Remove key from lookup table\r\n\t\t\t\t\t// iii. Return true.\r\n\t\t\t// 6. Return false.\r\n\r\n\t\t\t// Implement steps 4-6 with a more optimal algo\r\n\r\n\t\t\t// Steps 4-5: Access record\r\n\t\t\tvar recordIndex = getRecordIndex(M, key); // O(1) access to record index\r\n\r\n\t\t\tif (recordIndex !== false) {\r\n\t\t\t\t// Get record's `key` (could be `any` type);\r\n\t\t\t\tvar recordKey = M._keys[recordIndex];\r\n\t\t\t\t// 5a. If p.[[Key]] is not empty and SameValueZero(p.[[Key]], key) is true, then\r\n\t\t\t\tif (recordKey !== undefMarker && SameValueZero(recordKey, key)) {\r\n\t\t\t\t\t// i. Set p.[[Key]] to empty.\r\n\t\t\t\t\tthis._keys[recordIndex] = undefMarker;\r\n\t\t\t\t\t// ii. Set p.[[Value]] to empty.\r\n\t\t\t\t\tthis._values[recordIndex] = undefMarker;\r\n\t\t\t\t\tthis._size = --this._size;\r\n\t\t\t\t\tif (!supportsGetters) {\r\n\t\t\t\t\t\tthis.size = this._size;\r\n\t\t\t\t\t}\r\n\t\t\t\t\t// iia. Remove key from lookup table\r\n\t\t\t\t\tsetHashIndex(this, key, false);\r\n\t\t\t\t\t// iii. Return true.\r\n\t\t\t\t\treturn true;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// 6. Return false.\r\n\t\t\treturn false;\r\n\t\t}\r\n\t);\r\n\r\n\t// 23.1.3.4. Map.prototype.entries ( )\r\n\tCreateMethodProperty(Map.prototype, 'entries', function entries () {\r\n\t\t\t// 1. Let M be the this value.\r\n\t\t\tvar M = this;\r\n\t\t\t// 2. Return ? CreateMapIterator(M, \"key+value\").\r\n\t\t\treturn CreateMapIterator(M, 'key+value');\r\n\t\t}\r\n\t);\r\n\r\n\t// 23.1.3.5. Map.prototype.forEach ( callbackfn [ , thisArg ] )\r\n\tCreateMethodProperty(Map.prototype, 'forEach', function (callbackFn) {\r\n\t\t\t// 1. Let M be the this value.\r\n\t\t\tvar M = this;\r\n\t\t\t// 2. If Type(M) is not Object, throw a TypeError exception.\r\n\t\t\tif (Type(M) !== 'object') {\r\n\t\t\t\tthrow new TypeError('Method Map.prototype.forEach called on incompatible receiver ' + Object.prototype.toString.call(M));\r\n\t\t\t}\r\n\t\t\t// 3. If M does not have a [[MapData]] internal slot, throw a TypeError exception.\r\n\t\t\tif (M._es6Map !== true) {\r\n\t\t\t\tthrow new TypeError('Method Map.prototype.forEach called on incompatible receiver ' + Object.prototype.toString.call(M));\r\n\t\t\t}\r\n\t\t\t// 4. If IsCallable(callbackfn) is false, throw a TypeError exception.\r\n\t\t\tif (!IsCallable(callbackFn)) {\r\n\t\t\t\tthrow new TypeError(Object.prototype.toString.call(callbackFn) + ' is not a function.');\r\n\t\t\t}\r\n\t\t\t// 5. If thisArg is present, let T be thisArg; else let T be undefined.\r\n\t\t\tif (arguments[1]) {\r\n\t\t\t\tvar T = arguments[1];\r\n\t\t\t}\r\n\t\t\t// 6. Let entries be the List that is M.[[MapData]].\r\n\t\t\tvar entries = M._keys;\r\n\t\t\t// 7. For each Record {[[Key]], [[Value]]} e that is an element of entries, in original key insertion order, do\r\n\t\t\tfor (var i = 0; i < entries.length; i++) {\r\n\t\t\t\t// a. If e.[[Key]] is not empty, then\r\n\t\t\t\tif (M._keys[i] !== undefMarker && M._values[i] !== undefMarker ) {\r\n\t\t\t\t\t// i. Perform ? Call(callbackfn, T, « e.[[Value]], e.[[Key]], M »).\r\n\t\t\t\t\tcallbackFn.call(T, M._values[i], M._keys[i], M);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t// 8. Return undefined.\r\n\t\t\treturn undefined;\r\n\t\t}\r\n\t);\r\n\r\n\t// 23.1.3.6. Map.prototype.get ( key )\r\n\tCreateMethodProperty(Map.prototype, 'get', function get(key) {\r\n\t\t\t// 1. Let M be the this value.\r\n\t\t\tvar M = this;\r\n\t\t\t// 2. If Type(M) is not Object, throw a TypeError exception.\r\n\t\t\tif (Type(M) !== 'object') {\r\n\t\t\t\tthrow new TypeError('Method Map.prototype.get called on incompatible receiver ' + Object.prototype.toString.call(M));\r\n\t\t\t}\r\n\t\t\t// 3. If M does not have a [[MapData]] internal slot, throw a TypeError exception.\r\n\t\t\tif (M._es6Map !== true) {\r\n\t\t\t\tthrow new TypeError('Method Map.prototype.get called on incompatible receiver ' + Object.prototype.toString.call(M));\r\n\t\t\t}\r\n\t\t\t// 4. Let entries be the List that is M.[[MapData]].\r\n\t\t\t// 5. For each Record {[[Key]], [[Value]]} p that is an element of entries, do\r\n\t\t\t\t// a. If p.[[Key]] is not empty and SameValueZero(p.[[Key]], key) is true, return p.[[Value]].\r\n\t\t\t// 6. Return undefined.\r\n\r\n\t\t\t// Implement steps 4-6 with a more optimal algo\r\n\t\t\tvar recordIndex = getRecordIndex(M, key); // O(1) access to record index\r\n\t\t\tif (recordIndex !== false) {\r\n\t\t\t\tvar recordKey = M._keys[recordIndex];\r\n\t\t\t\tif (recordKey !== undefMarker && SameValueZero(recordKey, key)) {\r\n\t\t\t\t\treturn M._values[recordIndex];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\treturn undefined;\r\n\t\t});\r\n\r\n\t// 23.1.3.7. Map.prototype.has ( key )\r\n\tCreateMethodProperty(Map.prototype, 'has', function has (key) {\r\n\t\t\t// 1. Let M be the this value.\r\n\t\t\tvar M = this;\r\n\t\t\t// 2. If Type(M) is not Object, throw a TypeError exception.\r\n\t\t\tif (typeof M !== 'object') {\r\n\t\t\t\tthrow new TypeError('Method Map.prototype.has called on incompatible receiver ' + Object.prototype.toString.call(M));\r\n\t\t\t}\r\n\t\t\t// 3. If M does not have a [[MapData]] internal slot, throw a TypeError exception.\r\n\t\t\tif (M._es6Map !== true) {\r\n\t\t\t\tthrow new TypeError('Method Map.prototype.has called on incompatible receiver ' + Object.prototype.toString.call(M));\r\n\t\t\t}\r\n\t\t\t// 4. Let entries be the List that is M.[[MapData]].\r\n\t\t\t// 5. For each Record {[[Key]], [[Value]]} p that is an element of entries, do\r\n\t\t\t\t// a. If p.[[Key]] is not empty and SameValueZero(p.[[Key]], key) is true, return true.\r\n\t\t\t// 6. Return false.\r\n\r\n\t\t\t// Implement steps 4-6 with a more optimal algo\r\n\t\t\tvar recordIndex = getRecordIndex(M, key); // O(1) access to record index\r\n\t\t\tif (recordIndex !== false) {\r\n\t\t\t\tvar recordKey = M._keys[recordIndex];\r\n\t\t\t\tif (recordKey !== undefMarker && SameValueZero(recordKey, key)) {\r\n\t\t\t\t\treturn true;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\treturn false;\r\n\t\t});\r\n\r\n\t// 23.1.3.8. Map.prototype.keys ( )\r\n\tCreateMethodProperty(Map.prototype, 'keys', function keys () {\r\n\t\t\t// 1. Let M be the this value.\r\n\t\t\tvar M = this;\r\n\t\t\t// 2. Return ? CreateMapIterator(M, \"key\").\r\n\t\t\treturn CreateMapIterator(M, \"key\");\r\n\t\t});\r\n\r\n\t// 23.1.3.9. Map.prototype.set ( key, value )\r\n\tCreateMethodProperty(Map.prototype, 'set', function set(key, value) {\r\n\t\t\t// 1. Let M be the this value.\r\n\t\t\tvar M = this;\r\n\t\t\t// 2. If Type(M) is not Object, throw a TypeError exception.\r\n\t\t\tif (Type(M) !== 'object') {\r\n\t\t\t\tthrow new TypeError('Method Map.prototype.set called on incompatible receiver ' + Object.prototype.toString.call(M));\r\n\t\t\t}\r\n\t\t\t// 3. If M does not have a [[MapData]] internal slot, throw a TypeError exception.\r\n\t\t\tif (M._es6Map !== true) {\r\n\t\t\t\tthrow new TypeError('Method Map.prototype.set called on incompatible receiver ' + Object.prototype.toString.call(M));\r\n\t\t\t}\r\n\t\t\t// 4. Let entries be the List that is M.[[MapData]].\r\n\t\t\t// 5. For each Record {[[Key]], [[Value]]} p that is an element of entries, do\r\n\t\t\t// 6. If key is -0, let key be +0.\r\n\t\t\t// 7. Let p be the Record {[[Key]]: key, [[Value]]: value}.\r\n\t\t\t// 8. Append p as the last element of entries.\r\n\t\t\t// 9. Return M.\r\n\r\n\t\t\t// Strictly following the above steps 4-9 will lead to an inefficient algorithm.\r\n\t\t\t// Step 8 also doesn't seem to be required if an entry already exists\r\n\t\t\tvar recordIndex = getRecordIndex(M, key); // O(1) access to record index\r\n\t\t\tif (recordIndex !== false) {\r\n\t\t\t\t// update path\r\n\t\t\t\tM._values[recordIndex] = value;\r\n\t\t\t} else {\r\n\t\t\t\t// eslint-disable-next-line no-compare-neg-zero\r\n\t\t\t\tif (key === -0) {\r\n\t\t\t\t\tkey = 0;\r\n\t\t\t\t}\r\n\t\t\t\tvar p = {\r\n\t\t\t\t\t'[[Key]]': key,\r\n\t\t\t\t\t'[[Value]]': value\r\n\t\t\t\t};\r\n\t\t\t\tM._keys.push(p['[[Key]]']);\r\n\t\t\t\tM._values.push(p['[[Value]]']);\r\n\t\t\t\tsetHashIndex(M, key, M._keys.length - 1); // update lookup table\r\n\t\t\t\t++M._size;\r\n\t\t\t\tif (!supportsGetters) {\r\n\t\t\t\t\tM.size = M._size;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn M;\r\n\t\t});\r\n\r\n\t// 23.1.3.10. get Map.prototype.size\r\n\tif (supportsGetters) {\r\n\t\tObject.defineProperty(Map.prototype, 'size', {\r\n\t\t\tconfigurable: true,\r\n\t\t\tenumerable: false,\r\n\t\t\tget: function () {\r\n\t\t\t\t// 1. Let M be the this value.\r\n\t\t\t\tvar M = this;\r\n\t\t\t\t// 2. If Type(M) is not Object, throw a TypeError exception.\r\n\t\t\t\tif (Type(M) !== 'object') {\r\n\t\t\t\t\tthrow new TypeError('Method Map.prototype.size called on incompatible receiver ' + Object.prototype.toString.call(M));\r\n\t\t\t\t}\r\n\t\t\t\t// 3. If M does not have a [[MapData]] internal slot, throw a TypeError exception.\r\n\t\t\t\tif (M._es6Map !== true) {\r\n\t\t\t\t\tthrow new TypeError('Method Map.prototype.size called on incompatible receiver ' + Object.prototype.toString.call(M));\r\n\t\t\t\t}\r\n\t\t\t\t// 4. Let entries be the List that is M.[[MapData]].\r\n\t\t\t\t// 5. Let count be 0.\r\n\t\t\t\t// 6. For each Record {[[Key]], [[Value]]} p that is an element of entries, do\r\n\t\t\t\t\t// 6a. If p.[[Key]] is not empty, set count to count+1.\r\n\t\t\t\t// 7. Return count.\r\n\r\n\t\t\t\t// Implement 4-7 more efficently by returning pre-computed property\r\n\t\t\t\treturn this._size;\r\n\t\t\t},\r\n\t\t\tset: undefined\r\n\t\t});\r\n\t}\r\n\r\n\t// 23.1.3.11. Map.prototype.values ( )\r\n\tCreateMethodProperty(Map.prototype, 'values', function values () {\r\n\t\t\t// 1. Let M be the this value.\r\n\t\t\tvar M = this;\r\n\t\t\t// 2. Return ? CreateMapIterator(M, \"value\").\r\n\t\t\treturn CreateMapIterator(M, 'value');\r\n\t\t}\r\n\t);\r\n\r\n\t// 23.1.3.12. Map.prototype [ @@iterator ] ( )\r\n\t// The initial value of the @@iterator property is the same function object as the initial value of the entries property.\r\n\tCreateMethodProperty(Map.prototype, Symbol.iterator, Map.prototype.entries);\r\n\r\n\t// 23.1.3.13. Map.prototype [ @@toStringTag ]\r\n\t// The initial value of the @@toStringTag property is the String value \"Map\".\r\n\t// This property has the attributes { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: true }.\r\n\r\n\t// Polyfill.io - Safari 8 implements Map.name but as a non-configurable property, which means it would throw an error if we try and configure it here.\r\n\tif (!('name' in Map)) {\r\n\t\t// 19.2.4.2 name\r\n\t\tObject.defineProperty(Map, 'name', {\r\n\t\t\tconfigurable: true,\r\n\t\t\tenumerable: false,\r\n\t\t\twritable: false,\r\n\t\t\tvalue: 'Map'\r\n\t\t});\r\n\t}\r\n\r\n\t// 23.1.5.1. CreateMapIterator ( map, kind )\r\n\tfunction CreateMapIterator(map, kind) {\r\n\t\t// 1. If Type(map) is not Object, throw a TypeError exception.\r\n\t\tif (Type(map) !== 'object') {\r\n\t\t\tthrow new TypeError('createMapIterator called on incompatible receiver ' + Object.prototype.toString.call(map));\r\n\t\t}\r\n\t\t// 2. If map does not have a [[MapData]] internal slot, throw a TypeError exception.\r\n\t\tif (map._es6Map !== true) {\r\n\t\t\tthrow new TypeError('createMapIterator called on incompatible receiver ' + Object.prototype.toString.call(map));\r\n\t\t}\r\n\t\t// 3. Let iterator be ObjectCreate(%MapIteratorPrototype%, « [[Map]], [[MapNextIndex]], [[MapIterationKind]] »).\r\n\t\tvar iterator = Object.create(MapIteratorPrototype);\r\n\t\t// 4. Set iterator.[[Map]] to map.\r\n\t\tObject.defineProperty(iterator, '[[Map]]', {\r\n\t\t\tconfigurable: true,\r\n\t\t\tenumerable: false,\r\n\t\t\twritable: true,\r\n\t\t\tvalue: map\r\n\t\t});\r\n\t\t// 5. Set iterator.[[MapNextIndex]] to 0.\r\n\t\tObject.defineProperty(iterator, '[[MapNextIndex]]', {\r\n\t\t\tconfigurable: true,\r\n\t\t\tenumerable: false,\r\n\t\t\twritable: true,\r\n\t\t\tvalue: 0\r\n\t\t});\r\n\t\t// 6. Set iterator.[[MapIterationKind]] to kind.\r\n\t\tObject.defineProperty(iterator, '[[MapIterationKind]]', {\r\n\t\t\tconfigurable: true,\r\n\t\t\tenumerable: false,\r\n\t\t\twritable: true,\r\n\t\t\tvalue: kind\r\n\t\t});\r\n\t\t// 7. Return iterator.\r\n\t\treturn iterator;\r\n\t}\r\n\r\n\t// 23.1.5.2. The %MapIteratorPrototype% Object\r\n\tvar MapIteratorPrototype = {};\r\n\t// Polyfill.io - We use this as a quick way to check if an object is a Map Iterator instance.\r\n\tObject.defineProperty(MapIteratorPrototype, 'isMapIterator', {\r\n\t\tconfigurable: false,\r\n\t\tenumerable: false,\r\n\t\twritable: false,\r\n\t\tvalue: true\r\n\t});\r\n\r\n\t// 23.1.5.2.1. %MapIteratorPrototype%.next ( )\r\n\tCreateMethodProperty(MapIteratorPrototype, 'next', function next() {\r\n\t\t\t// 1. Let O be the this value.\r\n\t\t\tvar O = this;\r\n\t\t\t// 2. If Type(O) is not Object, throw a TypeError exception.\r\n\t\t\tif (Type(O) !== 'object') {\r\n\t\t\t\tthrow new TypeError('Method %MapIteratorPrototype%.next called on incompatible receiver ' + Object.prototype.toString.call(O));\r\n\t\t\t}\r\n\t\t\t// 3. If O does not have all of the internal slots of a Map Iterator Instance (23.1.5.3), throw a TypeError exception.\r\n\t\t\tif (!O.isMapIterator) {\r\n\t\t\t\tthrow new TypeError('Method %MapIteratorPrototype%.next called on incompatible receiver ' + Object.prototype.toString.call(O));\r\n\t\t\t}\r\n\t\t\t// 4. Let m be O.[[Map]].\r\n\t\t\tvar m = O['[[Map]]'];\r\n\t\t\t// 5. Let index be O.[[MapNextIndex]].\r\n\t\t\tvar index = O['[[MapNextIndex]]'];\r\n\t\t\t// 6. Let itemKind be O.[[MapIterationKind]].\r\n\t\t\tvar itemKind = O['[[MapIterationKind]]'];\r\n\t\t\t// 7. If m is undefined, return CreateIterResultObject(undefined, true).\r\n\t\t\tif (m === undefined) {\r\n\t\t\t\treturn CreateIterResultObject(undefined, true);\r\n\t\t\t}\r\n\t\t\t// 8. Assert: m has a [[MapData]] internal slot.\r\n\t\t\tif (!m._es6Map) {\r\n\t\t\t\tthrow new Error(Object.prototype.toString.call(m) + ' has a [[MapData]] internal slot.');\r\n\t\t\t}\r\n\t\t\t// 9. Let entries be the List that is m.[[MapData]].\r\n\t\t\tvar entries = m._keys;\r\n\t\t\t// 10. Let numEntries be the number of elements of entries.\r\n\t\t\tvar numEntries = entries.length;\r\n\t\t\t// 11. NOTE: numEntries must be redetermined each time this method is evaluated.\r\n\t\t\t// 12. Repeat, while index is less than numEntries,\r\n\t\t\twhile (index < numEntries) {\r\n\t\t\t\t// a. Let e be the Record {[[Key]], [[Value]]} that is the value of entries[index].\r\n\t\t\t\tvar e = Object.create(null);\r\n\t\t\t\te['[[Key]]'] = m._keys[index];\r\n\t\t\t\te['[[Value]]'] = m._values[index];\r\n\t\t\t\t// b. Set index to index+1.\r\n\t\t\t\tindex = index + 1;\r\n\t\t\t\t// c. Set O.[[MapNextIndex]] to index.\r\n\t\t\t\tO['[[MapNextIndex]]'] = index;\r\n\t\t\t\t// d. If e.[[Key]] is not empty, then\r\n\t\t\t\tif (e['[[Key]]'] !== undefMarker) {\r\n\t\t\t\t\t// i. If itemKind is \"key\", let result be e.[[Key]].\r\n\t\t\t\t\tif (itemKind === 'key') {\r\n\t\t\t\t\t\tvar result = e['[[Key]]'];\r\n\t\t\t\t\t\t// ii. Else if itemKind is \"value\", let result be e.[[Value]].\r\n\t\t\t\t\t} else if (itemKind === 'value') {\r\n\t\t\t\t\t\tresult = e['[[Value]]'];\r\n\t\t\t\t\t\t// iii. Else,\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\t// 1. Assert: itemKind is \"key+value\".\r\n\t\t\t\t\t\tif (itemKind !== 'key+value') {\r\n\t\t\t\t\t\t\tthrow new Error();\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t// 2. Let result be CreateArrayFromList(« e.[[Key]], e.[[Value]] »).\r\n\t\t\t\t\t\tresult = [\r\n\t\t\t\t\t\t\te['[[Key]]'],\r\n\t\t\t\t\t\t\te['[[Value]]']\r\n\t\t\t\t\t\t];\r\n\t\t\t\t\t}\r\n\t\t\t\t\t// iv. Return CreateIterResultObject(result, false).\r\n\t\t\t\t\treturn CreateIterResultObject(result, false);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t// 13. Set O.[[Map]] to undefined.\r\n\t\t\tO['[[Map]]'] = undefined;\r\n\t\t\t// 14. Return CreateIterResultObject(undefined, true).\r\n\t\t\treturn CreateIterResultObject(undefined, true);\r\n\t\t}\r\n\t);\r\n\r\n\t// 23.1.5.2.2 %MapIteratorPrototype% [ @@toStringTag ]\r\n\t// The initial value of the @@toStringTag property is the String value \"Map Iterator\".\r\n\t// This property has the attributes { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: true }.\r\n\r\n\tCreateMethodProperty(MapIteratorPrototype, Symbol.iterator, function iterator() {\r\n\t\t\treturn this;\r\n\t\t}\r\n\t);\r\n\r\n\t// Export the object\r\n\ttry {\r\n\t\tCreateMethodProperty(global, 'Map', Map);\r\n\t} catch (e) {\r\n\t\t// IE8 throws an error here if we set enumerable to false.\r\n\t\t// More info on table 2: https://msdn.microsoft.com/en-us/library/dd229916(v=vs.85).aspx\r\n\t\tglobal.Map = Map;\r\n\t}\r\n}(self));\r\n\r\n}\r\n\r\nif (!(\"Set\"in self&&function(){try{var e=new self.Set([1,2])\r\nreturn 0===self.Set.length&&2===e.size&&\"Symbol\"in self&&\"iterator\"in self.Symbol&&\"function\"==typeof e[self.Symbol.iterator]}catch(t){return!1}}()\r\n)) {\r\n\r\n// Set\r\n/* global CreateIterResultObject, CreateMethodProperty, GetIterator, IsCallable, IteratorClose, IteratorStep, IteratorValue, OrdinaryCreateFromConstructor, SameValueZero, Symbol */\r\n(function (global) {\r\n\tvar supportsGetters = (function () {\r\n\t\ttry {\r\n\t\t\tvar a = {};\r\n\t\t\tObject.defineProperty(a, 't', {\r\n\t\t\t\tconfigurable: true,\r\n\t\t\t\tenumerable: false,\r\n\t\t\t\tget: function () {\r\n\t\t\t\t\treturn true;\r\n\t\t\t\t},\r\n\t\t\t\tset: undefined\r\n\t\t\t});\r\n\t\t\treturn !!a.t;\r\n\t\t} catch (e) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t}());\r\n\r\n\t// Deleted set items mess with iterator pointers, so rather than removing them mark them as deleted. Can't use undefined or null since those both valid keys so use a private symbol.\r\n\tvar undefMarker = Symbol('undef');\r\n\t// 23.2.1.1. Set ( [ iterable ] )\r\n\tvar Set = function Set(/* iterable */) {\r\n\t\t// 1. If NewTarget is undefined, throw a TypeError exception.\r\n\t\tif (!(this instanceof Set)) {\r\n\t\t\tthrow new TypeError('Constructor Set requires \"new\"');\r\n\t\t}\r\n\t\t// 2. Let set be ? OrdinaryCreateFromConstructor(NewTarget, \"%SetPrototype%\", « [[SetData]] »).\r\n\t\tvar set = OrdinaryCreateFromConstructor(this, Set.prototype, {\r\n\t\t\t_values: [],\r\n\t\t\t_size: 0,\r\n\t\t\t_es6Set: true\r\n\t\t});\r\n\r\n\t\t// 3. Set set.[[SetData]] to a new empty List.\r\n\t\t// Polyfill.io - This step was done as part of step two.\r\n\r\n\t\t// Some old engines do not support ES5 getters/setters.  Since Set only requires these for the size property, we can fall back to setting the size property statically each time the size of the set changes.\r\n\t\tif (!supportsGetters) {\r\n\t\t\tObject.defineProperty(set, 'size', {\r\n\t\t\t\tconfigurable: true,\r\n\t\t\t\tenumerable: false,\r\n\t\t\t\twritable: true,\r\n\t\t\t\tvalue: 0\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\t// 4. If iterable is not present, let iterable be undefined.\r\n\t\tvar iterable = arguments.length > 0 ? arguments[0] : undefined;\r\n\r\n\t\t// 5. If iterable is either undefined or null, return set.\r\n\t\tif (iterable === null || iterable === undefined) {\r\n\t\t\treturn set;\r\n\t\t}\r\n\r\n\t\t// 6. Let adder be ? Get(set, \"add\").\r\n\t\tvar adder = set.add;\r\n\t\t// 7. If IsCallable(adder) is false, throw a TypeError exception.\r\n\t\tif (!IsCallable(adder)) {\r\n\t\t\tthrow new TypeError(\"Set.prototype.add is not a function\");\r\n\t\t}\r\n\r\n\t\ttry {\r\n\t\t\t// 8. Let iteratorRecord be ? GetIterator(iterable).\r\n\t\t\tvar iteratorRecord = GetIterator(iterable);\r\n\t\t\t// 9. Repeat,\r\n\t\t\t// eslint-disable-next-line no-constant-condition\r\n\t\t\twhile (true) {\r\n\t\t\t\t// a. Let next be ? IteratorStep(iteratorRecord).\r\n\t\t\t\tvar next = IteratorStep(iteratorRecord);\r\n\t\t\t\t// b. If next is false, return set.\r\n\t\t\t\tif (next === false) {\r\n\t\t\t\t\treturn set;\r\n\t\t\t\t}\r\n\t\t\t\t// c. Let nextValue be ? IteratorValue(next).\r\n\t\t\t\tvar nextValue = IteratorValue(next);\r\n\t\t\t\t// d. Let status be Call(adder, set, « nextValue.[[Value]] »).\r\n\t\t\t\ttry {\r\n\t\t\t\t\tadder.call(set, nextValue);\r\n\t\t\t\t} catch (e) {\r\n\t\t\t\t\t// e. If status is an abrupt completion, return ? IteratorClose(iteratorRecord, status).\r\n\t\t\t\t\treturn IteratorClose(iteratorRecord, e);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t} catch (e) {\r\n\t\t\t// Polyfill.io - For user agents which do not have iteration methods on argument objects or arrays, we can special case those.\r\n\t\t\tif (Array.isArray(iterable) ||\r\n\t\t\t\tObject.prototype.toString.call(iterable) === '[object Arguments]' ||\r\n\t\t\t\t// IE 7 & IE 8 return '[object Object]' for the arguments object, we can detect by checking for the existence of the callee property\r\n\t\t\t\t(!!iterable.callee)) {\r\n\t\t\t\tvar index;\r\n\t\t\t\tvar length = iterable.length;\r\n\t\t\t\tfor (index = 0; index < length; index++) {\r\n\t\t\t\t\tadder.call(set, iterable[index]);\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tthrow (e);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn set;\r\n\t};\r\n\r\n\t// 23.2.2.1. Set.prototype\r\n\t// The initial value of Set.prototype is the intrinsic %SetPrototype% object.\r\n\t// This property has the attributes { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }.\r\n\tObject.defineProperty(Set, 'prototype', {\r\n\t\tconfigurable: false,\r\n\t\tenumerable: false,\r\n\t\twritable: false,\r\n\t\tvalue: {}\r\n\t});\r\n\r\n\t// 23.2.2.2 get Set [ @@species ]\r\n\tif (supportsGetters) {\r\n\t\tObject.defineProperty(Set, Symbol.species, {\r\n\t\t\tconfigurable: true,\r\n\t\t\tenumerable: false,\r\n\t\t\tget: function () {\r\n\t\t\t\t// 1. Return the this value.\r\n\t\t\t\treturn this;\r\n\t\t\t},\r\n\t\t\tset: undefined\r\n\t\t});\r\n\t} else {\r\n\t\tCreateMethodProperty(Set, Symbol.species, Set);\r\n\t}\r\n\r\n\t// 23.2.3.1. Set.prototype.add ( value )\r\n\tCreateMethodProperty(Set.prototype, 'add', function add(value) {\r\n\t\t\t// 1. Let S be the this value.\r\n\t\t\tvar S = this;\r\n\t\t\t// 2. If Type(S) is not Object, throw a TypeError exception.\r\n\t\t\tif (typeof S !== 'object') {\r\n\t\t\t\tthrow new TypeError('Method Set.prototype.add called on incompatible receiver ' + Object.prototype.toString.call(S));\r\n\t\t\t}\r\n\t\t\t// 3. If S does not have a [[SetData]] internal slot, throw a TypeError exception.\r\n\t\t\tif (S._es6Set !== true) {\r\n\t\t\t\tthrow new TypeError('Method Set.prototype.add called on incompatible receiver ' + Object.prototype.toString.call(S));\r\n\t\t\t}\r\n\t\t\t// 4. Let entries be the List that is S.[[SetData]].\r\n\t\t\tvar entries = S._values;\r\n\t\t\t// 5. For each e that is an element of entries, do\r\n\t\t\tfor (var i = 0; i < entries.length; i++) {\r\n\t\t\t\tvar e = entries[i];\r\n\t\t\t\t// a. If e is not empty and SameValueZero(e, value) is true, then\r\n\t\t\t\tif (e !== undefMarker && SameValueZero(e, value)) {\r\n\t\t\t\t\t// i. Return S.\r\n\t\t\t\t\treturn S;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t// 6. If value is -0, let value be +0.\r\n\t\t\tif (value === 0 && 1/value === -Infinity) {\r\n\t\t\t\tvalue = 0;\r\n\t\t\t}\r\n\t\t\t// 7. Append value as the last element of entries.\r\n\t\t\tS._values.push(value);\r\n\r\n\t\t\tthis._size = ++this._size;\r\n\t\t\tif (!supportsGetters) {\r\n\t\t\t\tthis.size = this._size;\r\n\t\t\t}\r\n\t\t\t// 8. Return S.\r\n\t\t\treturn S;\r\n\t\t});\r\n\r\n\t// 23.2.3.2. Set.prototype.clear ( )\r\n\tCreateMethodProperty(Set.prototype, 'clear', function clear() {\r\n\t\t\t// 1. Let S be the this value.\r\n\t\t\tvar S = this;\r\n\t\t\t// 2. If Type(S) is not Object, throw a TypeError exception.\r\n\t\t\tif (typeof S !== 'object') {\r\n\t\t\t\tthrow new TypeError('Method Set.prototype.clear called on incompatible receiver ' + Object.prototype.toString.call(S));\r\n\t\t\t}\r\n\t\t\t// 3. If S does not have a [[SetData]] internal slot, throw a TypeError exception.\r\n\t\t\tif (S._es6Set !== true) {\r\n\t\t\t\tthrow new TypeError('Method Set.prototype.clear called on incompatible receiver ' + Object.prototype.toString.call(S));\r\n\t\t\t}\r\n\t\t\t// 4. Let entries be the List that is S.[[SetData]].\r\n\t\t\tvar entries = S._values;\r\n\t\t\t// 5. For each e that is an element of entries, do\r\n\t\t\tfor (var i = 0; i < entries.length; i++) {\r\n\t\t\t\t// a. Replace the element of entries whose value is e with an element whose value is empty.\r\n\t\t\t\tentries[i] = undefMarker;\r\n\t\t\t}\r\n\t\t\tthis._size = 0;\r\n\t\t\tif (!supportsGetters) {\r\n\t\t\t\tthis.size = this._size;\r\n\t\t\t}\r\n\t\t\t// 6. Return undefined.\r\n\t\t\treturn undefined;\r\n\t\t});\r\n\r\n\t// 23.2.3.3. Set.prototype.constructor\r\n\tCreateMethodProperty(Set.prototype, 'constructor', Set);\r\n\r\n\t// 23.2.3.4. Set.prototype.delete ( value )\r\n\tCreateMethodProperty(Set.prototype, 'delete', function (value) {\r\n\t\t\t// 1. Let S be the this value.\r\n\t\t\tvar S = this;\r\n\t\t\t// 2. If Type(S) is not Object, throw a TypeError exception.\r\n\t\t\tif (typeof S !== 'object') {\r\n\t\t\t\tthrow new TypeError('Method Set.prototype.delete called on incompatible receiver ' + Object.prototype.toString.call(S));\r\n\t\t\t}\r\n\t\t\t// 3. If S does not have a [[SetData]] internal slot, throw a TypeError exception.\r\n\t\t\tif (S._es6Set !== true) {\r\n\t\t\t\tthrow new TypeError('Method Set.prototype.delete called on incompatible receiver ' + Object.prototype.toString.call(S));\r\n\t\t\t}\r\n\t\t\t// 4. Let entries be the List that is S.[[SetData]].\r\n\t\t\tvar entries = S._values;\r\n\t\t\t// 5. For each e that is an element of entries, do\r\n\t\t\tfor (var i = 0; i < entries.length; i++) {\r\n\t\t\t\tvar e = entries[i];\r\n\t\t\t\t// a. If e is not empty and SameValueZero(e, value) is true, then\r\n\t\t\t\tif (e !== undefMarker && SameValueZero(e, value)) {\r\n\t\t\t\t\t// i. Replace the element of entries whose value is e with an element whose value is empty.\r\n\t\t\t\t\tentries[i] = undefMarker;\r\n\r\n\t\t\t\t\tthis._size = --this._size;\r\n\t\t\t\t\tif (!supportsGetters) {\r\n\t\t\t\t\t\tthis.size = this._size;\r\n\t\t\t\t\t}\r\n\t\t\t\t\t// ii. Return true.\r\n\t\t\t\t\treturn true;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t// 6. Return false.\r\n\t\t\treturn false;\r\n\t\t}\r\n\t);\r\n\r\n\t// 23.2.3.5. Set.prototype.entries ( )\r\n\tCreateMethodProperty(Set.prototype, 'entries', function entries() {\r\n\t\t\t// 1. Let S be the this value.\r\n\t\t\tvar S = this;\r\n\t\t\t// 2. Return ? CreateSetIterator(S, \"key+value\").\r\n\t\t\treturn CreateSetIterator(S, 'key+value');\r\n\t\t}\r\n\t);\r\n\r\n\t// 23.2.3.6. Set.prototype.forEach ( callbackfn [ , thisArg ] )\r\n\tCreateMethodProperty(Set.prototype, 'forEach', function forEach(callbackFn /*[ , thisArg ]*/) {\r\n\t\t\t// 1. Let S be the this value.\r\n\t\t\tvar S = this;\r\n\t\t\t// 2. If Type(S) is not Object, throw a TypeError exception.\r\n\t\t\tif (typeof S !== 'object') {\r\n\t\t\t\tthrow new TypeError('Method Set.prototype.forEach called on incompatible receiver ' + Object.prototype.toString.call(S));\r\n\t\t\t}\r\n\t\t\t// 3. If S does not have a [[SetData]] internal slot, throw a TypeError exception.\r\n\t\t\tif (S._es6Set !== true) {\r\n\t\t\t\tthrow new TypeError('Method Set.prototype.forEach called on incompatible receiver ' + Object.prototype.toString.call(S));\r\n\t\t\t}\r\n\t\t\t// 4. If IsCallable(callbackfn) is false, throw a TypeError exception.\r\n\t\t\tif (!IsCallable(callbackFn)) {\r\n\t\t\t\tthrow new TypeError(Object.prototype.toString.call(callbackFn) + ' is not a function.');\r\n\t\t\t}\r\n\t\t\t// 5. If thisArg is present, let T be thisArg; else let T be undefined.\r\n\t\t\tif (arguments[1]) {\r\n\t\t\t\tvar T = arguments[1];\r\n\t\t\t}\r\n\t\t\t// 6. Let entries be the List that is S.[[SetData]].\r\n\t\t\tvar entries = S._values;\r\n\t\t\t// 7. For each e that is an element of entries, in original insertion order, do\r\n\t\t\tfor (var i = 0; i < entries.length; i++) {\r\n\t\t\t\tvar e = entries[i];\r\n\t\t\t\t// a. If e is not empty, then\r\n\t\t\t\tif (e !== undefMarker) {\r\n\t\t\t\t\t// i. Perform ? Call(callbackfn, T, « e, e, S »).\r\n\t\t\t\t\tcallbackFn.call(T, e, e, S);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t// 8. Return undefined.\r\n\t\t\treturn undefined;\r\n\t\t}\r\n\t);\r\n\r\n\t// 23.2.3.7. Set.prototype.has ( value )\r\n\tCreateMethodProperty(Set.prototype, 'has', function has(value) {\r\n\t\t\t// 1. Let S be the this value.\r\n\t\t\tvar S = this;\r\n\t\t\t// 2. If Type(S) is not Object, throw a TypeError exception.\r\n\t\t\tif (typeof S !== 'object') {\r\n\t\t\t\tthrow new TypeError('Method Set.prototype.forEach called on incompatible receiver ' + Object.prototype.toString.call(S));\r\n\t\t\t}\r\n\t\t\t// 3. If S does not have a [[SetData]] internal slot, throw a TypeError exception.\r\n\t\t\tif (S._es6Set !== true) {\r\n\t\t\t\tthrow new TypeError('Method Set.prototype.forEach called on incompatible receiver ' + Object.prototype.toString.call(S));\r\n\t\t\t}\r\n\t\t\t// 4. Let entries be the List that is S.[[SetData]].\r\n\t\t\tvar entries = S._values;\r\n\t\t\t// 5. For each e that is an element of entries, do\r\n\t\t\tfor (var i = 0; i < entries.length; i++) {\r\n\t\t\t\tvar e = entries[i];\r\n\t\t\t\t// a. If e is not empty and SameValueZero(e, value) is true, return true.\r\n\t\t\t\tif (e !== undefMarker && SameValueZero(e, value)) {\r\n\t\t\t\t\treturn true;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t// 6. Return false.\r\n\t\t\treturn false;\r\n\t\t}\r\n\t);\r\n\r\n\t// Polyfill.io - We need to define Set.prototype.values before Set.prototype.keys because keys is a reference to values.\r\n\t// 23.2.3.10. Set.prototype.values()\r\n\tvar values = function values() {\r\n\t\t// 1. Let S be the this value.\r\n\t\tvar S = this;\r\n\t\t// 2. Return ? CreateSetIterator(S, \"value\").\r\n\t\treturn CreateSetIterator(S, \"value\");\r\n\t};\r\n\tCreateMethodProperty(Set.prototype, 'values', values);\r\n\r\n\t// 23.2.3.8 Set.prototype.keys ( )\r\n\t// The initial value of the keys property is the same function object as the initial value of the values property.\r\n\tCreateMethodProperty(Set.prototype, 'keys', values);\r\n\r\n\t// 23.2.3.9. get Set.prototype.size\r\n\tif (supportsGetters) {\r\n\t\tObject.defineProperty(Set.prototype, 'size', {\r\n\t\t\tconfigurable: true,\r\n\t\t\tenumerable: false,\r\n\t\t\tget: function () {\r\n\t\t\t\t// 1. Let S be the this value.\r\n\t\t\t\tvar S = this;\r\n\t\t\t\t// 2. If Type(S) is not Object, throw a TypeError exception.\r\n\t\t\t\tif (typeof S !== 'object') {\r\n\t\t\t\t\tthrow new TypeError('Method Set.prototype.size called on incompatible receiver ' + Object.prototype.toString.call(S));\r\n\t\t\t\t}\r\n\t\t\t\t// 3. If S does not have a [[SetData]] internal slot, throw a TypeError exception.\r\n\t\t\t\tif (S._es6Set !== true) {\r\n\t\t\t\t\tthrow new TypeError('Method Set.prototype.size called on incompatible receiver ' + Object.prototype.toString.call(S));\r\n\t\t\t\t}\r\n\t\t\t\t// 4. Let entries be the List that is S.[[SetData]].\r\n\t\t\t\tvar entries = S._values;\r\n\t\t\t\t// 5. Let count be 0.\r\n\t\t\t\tvar count = 0;\r\n\t\t\t\t// 6. For each e that is an element of entries, do\r\n\t\t\t\tfor (var i = 0; i < entries.length; i++) {\r\n\t\t\t\t\tvar e = entries[i];\r\n\t\t\t\t\t// a. If e is not empty, set count to count+1.\r\n\t\t\t\t\tif (e !== undefMarker) {\r\n\t\t\t\t\t\tcount = count + 1;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\t// 7. Return count.\r\n\t\t\t\treturn count;\r\n\t\t\t},\r\n\t\t\tset: undefined\r\n\t\t});\r\n\t}\r\n\r\n\t// 23.2.3.11. Set.prototype [ @@iterator ] ( )\r\n\t// The initial value of the @@iterator property is the same function object as the initial value of the values property.\r\n\tCreateMethodProperty(Set.prototype, Symbol.iterator, values);\r\n\r\n\t// 23.2.3.12. Set.prototype [ @@toStringTag ]\r\n\t// The initial value of the @@toStringTag property is the String value \"Set\".\r\n\t// This property has the attributes { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: true }.\r\n\r\n\t// Polyfill.io - Safari 8 implements Set.name but as a non-configurable property, which means it would throw an error if we try and configure it here.\r\n\tif (!('name' in Set)) {\r\n\t\t// 19.2.4.2 name\r\n\t\tObject.defineProperty(Set, 'name', {\r\n\t\t\tconfigurable: true,\r\n\t\t\tenumerable: false,\r\n\t\t\twritable: false,\r\n\t\t\tvalue: 'Set'\r\n\t\t});\r\n\t}\r\n\r\n\t// 23.2.5.1. CreateSetIterator ( set, kind )\r\n\tfunction CreateSetIterator(set, kind) {\r\n\t\t// 1. If Type(set) is not Object, throw a TypeError exception.\r\n\t\tif (typeof set !== 'object') {\r\n\t\t\tthrow new TypeError('createSetIterator called on incompatible receiver ' + Object.prototype.toString.call(set));\r\n\t\t}\r\n\t\t// 2. If set does not have a [[SetData]] internal slot, throw a TypeError exception.\r\n\t\tif (set._es6Set !== true) {\r\n\t\t\tthrow new TypeError('createSetIterator called on incompatible receiver ' + Object.prototype.toString.call(set));\r\n\t\t}\r\n\t\t// 3. Let iterator be ObjectCreate(%SetIteratorPrototype%, « [[IteratedSet]], [[SetNextIndex]], [[SetIterationKind]] »).\r\n\t\tvar iterator = Object.create(SetIteratorPrototype);\r\n\t\t// 4. Set iterator.[[IteratedSet]] to set.\r\n\t\tObject.defineProperty(iterator, '[[IteratedSet]]', {\r\n\t\t\tconfigurable: true,\r\n\t\t\tenumerable: false,\r\n\t\t\twritable: true,\r\n\t\t\tvalue: set\r\n\t\t});\r\n\t\t// 5. Set iterator.[[SetNextIndex]] to 0.\r\n\t\tObject.defineProperty(iterator, '[[SetNextIndex]]', {\r\n\t\t\tconfigurable: true,\r\n\t\t\tenumerable: false,\r\n\t\t\twritable: true,\r\n\t\t\tvalue: 0\r\n\t\t});\r\n\t\t// 6. Set iterator.[[SetIterationKind]] to kind.\r\n\t\tObject.defineProperty(iterator, '[[SetIterationKind]]', {\r\n\t\t\tconfigurable: true,\r\n\t\t\tenumerable: false,\r\n\t\t\twritable: true,\r\n\t\t\tvalue: kind\r\n\t\t});\r\n\t\t// 7. Return iterator.\r\n\t\treturn iterator;\r\n\t}\r\n\r\n\t// 23.2.5.2. The %SetIteratorPrototype% Object\r\n\tvar SetIteratorPrototype = {};\r\n\t//Polyfill.io - We add this property to help us identify what is a set iterator.\r\n\tObject.defineProperty(SetIteratorPrototype, 'isSetIterator', {\r\n\t\tconfigurable: false,\r\n\t\tenumerable: false,\r\n\t\twritable: false,\r\n\t\tvalue: true\r\n\t});\r\n\r\n\t// 23.2.5.2.1. %SetIteratorPrototype%.next ( )\r\n\tCreateMethodProperty(SetIteratorPrototype, 'next', function next() {\r\n\t\t// 1. Let O be the this value.\r\n\t\tvar O = this;\r\n\t\t// 2. If Type(O) is not Object, throw a TypeError exception.\r\n\t\tif (typeof O !== 'object') {\r\n\t\t\tthrow new TypeError('Method %SetIteratorPrototype%.next called on incompatible receiver ' + Object.prototype.toString.call(O));\r\n\t\t}\r\n\t\t// 3. If O does not have all of the internal slots of a Set Iterator Instance (23.2.5.3), throw a TypeError exception.\r\n\t\tif (!O.isSetIterator) {\r\n\t\t\tthrow new TypeError('Method %SetIteratorPrototype%.next called on incompatible receiver ' + Object.prototype.toString.call(O));\r\n\t\t}\r\n\t\t// 4. Let s be O.[[IteratedSet]].\r\n\t\tvar s = O['[[IteratedSet]]'];\r\n\t\t// 5. Let index be O.[[SetNextIndex]].\r\n\t\tvar index = O['[[SetNextIndex]]'];\r\n\t\t// 6. Let itemKind be O.[[SetIterationKind]].\r\n\t\tvar itemKind = O['[[SetIterationKind]]'];\r\n\t\t// 7. If s is undefined, return CreateIterResultObject(undefined, true).\r\n\t\tif (s === undefined) {\r\n\t\t\treturn CreateIterResultObject(undefined, true);\r\n\t\t}\r\n\t\t// 8. Assert: s has a [[SetData]] internal slot.\r\n\t\tif (!s._es6Set) {\r\n\t\t\tthrow new Error(Object.prototype.toString.call(s) + ' does not have [[SetData]] internal slot.');\r\n\t\t}\r\n\t\t// 9. Let entries be the List that is s.[[SetData]].\r\n\t\tvar entries = s._values;\r\n\t\t// 10. Let numEntries be the number of elements of entries.\r\n\t\tvar numEntries = entries.length;\r\n\t\t// 11. NOTE: numEntries must be redetermined each time this method is evaluated.\r\n\t\t// 12. Repeat, while index is less than numEntries,\r\n\t\twhile (index < numEntries) {\r\n\t\t\t// a. Let e be entries[index].\r\n\t\t\tvar e = entries[index];\r\n\t\t\t// b. Set index to index+1.\r\n\t\t\tindex = index + 1;\r\n\t\t\t// c. Set O.[[SetNextIndex]] to index.\r\n\t\t\tO['[[SetNextIndex]]'] = index;\r\n\t\t\t// d. If e is not empty, then\r\n\t\t\tif (e !== undefMarker) {\r\n\t\t\t\t// i. If itemKind is \"key+value\", then\r\n\t\t\t\tif (itemKind === 'key+value') {\r\n\t\t\t\t\t// 1. Return CreateIterResultObject(CreateArrayFromList(« e, e »), false).\r\n\t\t\t\t\treturn CreateIterResultObject([e, e], false);\r\n\t\t\t\t}\r\n\t\t\t\t// ii. Return CreateIterResultObject(e, false).\r\n\t\t\t\treturn CreateIterResultObject(e, false);\r\n\t\t\t}\r\n\t\t}\r\n\t\t// 13. Set O.[[IteratedSet]] to undefined.\r\n\t\tO['[[IteratedSet]]'] = undefined;\r\n\t\t// 14. Return CreateIterResultObject(undefined, true).\r\n\t\treturn CreateIterResultObject(undefined, true);\r\n\t});\r\n\r\n\t// 23.2.5.2.2. %SetIteratorPrototype% [ @@toStringTag ]\r\n\t// The initial value of the @@toStringTag property is the String value \"Set Iterator\".\r\n\t// This property has the attributes { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: true }.\r\n\r\n\tCreateMethodProperty(SetIteratorPrototype, Symbol.iterator, function iterator() {\r\n\t\t\treturn this;\r\n\t\t}\r\n\t);\r\n\r\n\t// Export the object\r\n\ttry {\r\n\t\tCreateMethodProperty(global, 'Set', Set);\r\n\t} catch (e) {\r\n\t\t// IE8 throws an error here if we set enumerable to false.\r\n\t\t// More info on table 2: https://msdn.microsoft.com/en-us/library/dd229916(v=vs.85).aspx\r\n\t\tglobal.Set = Set;\r\n\t}\r\n\r\n}(self));\r\n\r\n}\r\n\r\nif (!(\"from\"in Array&&function(){try{return Array.from({length:-Infinity}),\"a\"===Array.from(new self.Set([\"a\"]))[0]&&\"a\"===Array.from(new self.Map([[\"a\",\"one\"]]))[0][0]}catch(r){return!1}}()\r\n)) {\r\n\r\n// Array.from\r\n/* globals\r\n\tIsCallable, GetMethod, Symbol, IsConstructor, Construct, ArrayCreate, GetIterator, IteratorClose,\r\n\tToString, IteratorStep, IteratorValue, Call, CreateDataPropertyOrThrow, ToObject, ToLength, Get, CreateMethodProperty\r\n*/\r\n(function () {\r\n\tvar toString = Object.prototype.toString;\r\n\tvar stringMatch = String.prototype.match;\r\n\t// A cross-realm friendly way to detect if a value is a String object or literal.\r\n\tfunction isString(value) {\r\n\t\tif (typeof value === 'string') { return true; }\r\n\t\tif (typeof value !== 'object') { return false; }\r\n\t\treturn toString.call(value) === '[object String]';\r\n\t}\r\n\r\n\t// 22.1.2.1. Array.from ( items [ , mapfn [ , thisArg ] ] )\r\n\tCreateMethodProperty(Array, 'from', function from(items /* [ , mapfn [ , thisArg ] ] */) { // eslint-disable-line no-undef\r\n\t\t// 1. Let C be the this value.\r\n\t\tvar C = this;\r\n\t\t// 2. If mapfn is undefined, let mapping be false.\r\n\t\tvar mapfn = arguments.length > 1 ? arguments[1] : undefined;\r\n\t\tif (mapfn === undefined) {\r\n\t\t\tvar mapping = false;\r\n\t\t\t// 3. Else,\r\n\t\t} else {\r\n\t\t\t// a. If IsCallable(mapfn) is false, throw a TypeError exception.\r\n\t\t\tif (IsCallable(mapfn) === false) {\r\n\t\t\t\tthrow new TypeError(Object.prototype.toString.call(mapfn) + ' is not a function.');\r\n\t\t\t}\r\n\t\t\t// b. If thisArg is present, let T be thisArg; else let T be undefined.\r\n\t\t\tvar thisArg = arguments.length > 2 ? arguments[2] : undefined;\r\n\t\t\tif (thisArg !== undefined) {\r\n\t\t\t\tvar T = thisArg;\r\n\t\t\t} else {\r\n\t\t\t\tT = undefined;\r\n\t\t\t}\r\n\t\t\t// c. Let mapping be true.\r\n\t\t\tmapping = true;\r\n\r\n\t\t}\r\n\t\t// 4. Let usingIterator be ? GetMethod(items, @@iterator).\r\n\t\tvar usingIterator = GetMethod(items, Symbol.iterator);\r\n\t\t// 5. If usingIterator is not undefined, then\r\n\t\tif (usingIterator !== undefined) {\r\n\t\t\t// a. If IsConstructor(C) is true, then\r\n\t\t\tif (IsConstructor(C)) {\r\n\t\t\t\t// i. Let A be ? Construct(C).\r\n\t\t\t\tvar A = Construct(C);\r\n\t\t\t\t// b. Else,\r\n\t\t\t} else {\r\n\t\t\t\t// i. Let A be ! ArrayCreate(0).\r\n\t\t\t\tA = ArrayCreate(0);\r\n\t\t\t}\r\n\t\t\t// c. Let iteratorRecord be ? GetIterator(items, usingIterator).\r\n\t\t\tvar iteratorRecord = GetIterator(items, usingIterator);\r\n\t\t\t// d. Let k be 0.\r\n\t\t\tvar k = 0;\r\n\t\t\t// e. Repeat,\r\n\t\t\t// eslint-disable-next-line no-constant-condition\r\n\t\t\twhile (true) {\r\n\t\t\t\t// i. If k ≥ 2^53-1, then\r\n\t\t\t\tif (k >= (Math.pow(2, 53) - 1)) {\r\n\t\t\t\t\t// 1. Let error be Completion{[[Type]]: throw, [[Value]]: a newly created TypeError object, [[Target]]: empty}.\r\n\t\t\t\t\tvar error = new TypeError('Iteration count can not be greater than or equal 9007199254740991.');\r\n\t\t\t\t\t// 2. Return ? IteratorClose(iteratorRecord, error).\r\n\t\t\t\t\treturn IteratorClose(iteratorRecord, error);\r\n\t\t\t\t}\r\n\t\t\t\t// ii. Let Pk be ! ToString(k).\r\n\t\t\t\tvar Pk = ToString(k);\r\n\t\t\t\t// iii. Let next be ? IteratorStep(iteratorRecord).\r\n\t\t\t\tvar next = IteratorStep(iteratorRecord);\r\n\t\t\t\t// iv. If next is false, then\r\n\t\t\t\tif (next === false) {\r\n\t\t\t\t\t// 1. Perform ? Set(A, \"length\", k, true).\r\n\t\t\t\t\tA.length = k;\r\n\t\t\t\t\t// 2. Return A.\r\n\t\t\t\t\treturn A;\r\n\t\t\t\t}\r\n\t\t\t\t// v. Let nextValue be ? IteratorValue(next).\r\n\t\t\t\tvar nextValue = IteratorValue(next);\r\n\t\t\t\t// vi. If mapping is true, then\r\n\t\t\t\tif (mapping) {\r\n\t\t\t\t\ttry {\r\n\t\t\t\t\t\t// Polyfill.io - The try catch accounts for step 2.\r\n\t\t\t\t\t\t// 1. Let mappedValue be Call(mapfn, T, « nextValue, k »).\r\n\t\t\t\t\t\tvar mappedValue = Call(mapfn, T, [nextValue, k]);\r\n\t\t\t\t\t\t// 2. If mappedValue is an abrupt completion, return ? IteratorClose(iteratorRecord, mappedValue).\r\n\t\t\t\t\t\t// 3. Let mappedValue be mappedValue.[[Value]].\r\n\t\t\t\t\t} catch (e) {\r\n\t\t\t\t\t\treturn IteratorClose(iteratorRecord, e);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// vii. Else, let mappedValue be nextValue.\r\n\t\t\t\t} else {\r\n\t\t\t\t\tmappedValue = nextValue;\r\n\t\t\t\t}\r\n\t\t\t\ttry {\r\n\t\t\t\t\t// Polyfill.io - The try catch accounts for step ix.\r\n\t\t\t\t\t// viii. Let defineStatus be CreateDataPropertyOrThrow(A, Pk, mappedValue).\r\n\t\t\t\t\tCreateDataPropertyOrThrow(A, Pk, mappedValue);\r\n\t\t\t\t\t// ix. If defineStatus is an abrupt completion, return ? IteratorClose(iteratorRecord, defineStatus).\r\n\t\t\t\t} catch (e) {\r\n\t\t\t\t\treturn IteratorClose(iteratorRecord, e);\r\n\t\t\t\t}\r\n\t\t\t\t// x. Increase k by 1.\r\n\t\t\t\tk = k + 1;\r\n\t\t\t}\r\n\t\t}\r\n\t\t// 6. NOTE: items is not an Iterable so assume it is an array-like object.\r\n\t\t// 7. Let arrayLike be ! ToObject(items).\r\n\t\t// Polyfill.io - For Strings we need to split astral symbols into surrogate pairs.\r\n\t\tif (isString(items)) {\r\n\t\t\tvar arrayLike = stringMatch.call(items, /[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]?|[^\\uD800-\\uDFFF]|./g) || [];\r\n\t\t} else {\r\n\t\t\tarrayLike = ToObject(items);\r\n\t\t}\r\n\t\t// 8. Let len be ? ToLength(? Get(arrayLike, \"length\")).\r\n\t\tvar len = ToLength(Get(arrayLike, \"length\"));\r\n\t\t// 9. If IsConstructor(C) is true, then\r\n\t\tif (IsConstructor(C)) {\r\n\t\t\t// a. Let A be ? Construct(C, « len »).\r\n\t\t\tA = Construct(C, [len]);\r\n\t\t\t// 10. Else,\r\n\t\t} else {\r\n\t\t\t// a. Let A be ? ArrayCreate(len).\r\n\t\t\tA = ArrayCreate(len);\r\n\t\t}\r\n\t\t// 11. Let k be 0.\r\n\t\tk = 0;\r\n\t\t// 12. Repeat, while k < len\r\n\t\twhile (k < len) {\r\n\t\t\t// a. Let Pk be ! ToString(k).\r\n\t\t\tPk = ToString(k);\r\n\t\t\t// b. Let kValue be ? Get(arrayLike, Pk).\r\n\t\t\tvar kValue = Get(arrayLike, Pk);\r\n\t\t\t// c. If mapping is true, then\r\n\t\t\tif (mapping === true) {\r\n\t\t\t\t// i. Let mappedValue be ? Call(mapfn, T, « kValue, k »).\r\n\t\t\t\tmappedValue = Call(mapfn, T, [kValue, k]);\r\n\t\t\t\t// d. Else, let mappedValue be kValue.\r\n\t\t\t} else {\r\n\t\t\t\tmappedValue = kValue;\r\n\t\t\t}\r\n\t\t\t// e. Perform ? CreateDataPropertyOrThrow(A, Pk, mappedValue).\r\n\t\t\tCreateDataPropertyOrThrow(A, Pk, mappedValue);\r\n\t\t\t// f. Increase k by 1.\r\n\t\t\tk = k + 1;\r\n\t\t}\r\n\t\t// 13. Perform ? Set(A, \"length\", len, true).\r\n\t\tA.length = len;\r\n\t\t// 14. Return A.\r\n\t\treturn A;\r\n\t});\r\n}());\r\n\r\n}\r\n\r\n})\r\n('object' === typeof window && window || 'object' === typeof self && self || 'object' === typeof global && global || {});\r\n"],"names":[],"sourceRoot":""}