{"version":3,"file":"features/hebelmaison/polyfill-library.js","mappings":";;UAAA;UACA;;;;;WCDA;WACA;WACA;WACA,uDAAuD,iBAAiB;WACxE;WACA,gDAAgD,aAAa;WAC7D;;;;;;;;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,+CAA+C;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4EAA4E,sFAAsF;AAClK;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,8CAA8C;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA,wIAAwI;AACxI;AACA,6DAA6D;AAC7D;AACA,gEAAgE;AAChE;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D;AAC/D,sFAAsF;AACtF;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,2EAA2E;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,qDAAqD;AACrD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,wCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,wDAAwD;AACxD;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,wCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,wCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,iBAAiB,wBAAwB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,sDAAsD;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,IAAI;AAChD,uCAAuC,SAAS,KAAK,SAAS,UAAU;AACxE;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,CAAC;;AAED;;;AAGA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA,8CAA8C,gFAAgF;AAC9H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA,8CAA8C;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,+CAA+C;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,yCAAyC;AACzC;AACA;AACA,6CAA6C,gFAAgF;AAC7H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,uEAAuE;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,iBAAiB,iBAAiB;AAClC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,4EAA4E,uCAAuC;;AAEnH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,8CAA8C;AAC9C,8DAA8D;AAC9D;AACA;AACA,iDAAiD;AACjD,uEAAuE;AACvE;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,CAAC;;AAED;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;;AAEA,0GAA0G,IAAI,4DAA4D,SAAS,UAAU;AAC7L;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ,IAAI;AACJ;AACA;AACA,EAAE;;AAEF,mBAAmB;AACnB;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF,CAAC;;AAED;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA,+BAA+B,gBAAgB;AAC/C;AACA;AACA;AACA;AACA,CAAC;;AAED;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF,CAAC;;AAED;;AAEA,kCAAkC,yCAAyC,kBAAkB,IAAI,0BAA0B,SAAS,UAAU;AAC9I;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,2CAA2C,gBAAgB;AAC3D,4DAA4D;AAC5D;AACA;AACA;AACA;AACA,gCAAgC;AAChC,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,mBAAmB;AACtC;AACA;AACA;;AAEA;AACA,mBAAmB,mBAAmB;AACtC;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,mBAAmB,sBAAsB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;;AAEA;AACA;;AAEA;AACA;AACA;AACA,yEAAyE;AACzE;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,kBAAkB,yBAAyB;AAC3C;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,sBAAsB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,iBAAiB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,wBAAwB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;;AAEA;AACA;;AAEA;AACA;AACA;AACA,yBAAyB,kBAAkB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,EAAE;AACF,CAAC;;AAED;;;AAGA;AACA;AACA;AACA,6EAA6E;AAC7E;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iEAAiE;AACjE;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,qDAAqD;AACrD;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;;AAEA,iDAAiD,IAAI,wCAAwC,SAAS,UAAU;AAChH;;AAEA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,mCAAmC;AACtD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,CAAC;;AAED;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,eAAe,aAAa;;AAE5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;;AAEA;AACA;;AAEA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,IAAI;AACJ;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,wCAAwC,cAAc,cAAc;AACpE;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA,EAAE;AACF;AACA;AACA;AACA,yDAAyD,SAAS,UAAU,SAAS;AACrF;AACA,IAAI;;AAEJ;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA,CAAC;;AAED;;AAEA;AACA;;AAEA;AACA,iDAAiD,gCAAgC;;AAEjF;;;AAGA;AACA;AACA;AACA;AACA,0CAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,oEAAoE;AACzG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,2CAA2C,0BAA0B;;AAErE;;AAEA,gCAAgC,IAAI;AACpC,kHAAkH,SAAS,UAAU;AACrI;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,gCAAgC;AAC5C,cAAc,cAAc;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,KAAK;AACjB,YAAY,+BAA+B;AAC3C,cAAc,cAAc;AAC5B;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACA;AACA,2CAA2C;AAC3C;AACA;;AAEA;AACA;AACA;AACA,YAAY,KAAK;AACjB,YAAY,+BAA+B;AAC3C,cAAc,cAAc;AAC5B;AACA;AACA;AACA,kBAAkB,sBAAsB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,KAAK;AACjB,YAAY,+BAA+B;AAC3C,YAAY,aAAa;AACzB,cAAc,MAAM;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,gFAAgF;AACnH;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,gBAAgB;AACpC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,uCAAuC,qEAAqE;AAC5G;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,GAAG;AACH,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,oBAAoB;AAC9C,mBAAmB,oBAAoB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,oBAAoB;AAC9C;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,6CAA6C;;AAE7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD;AAClD;AACA;AACA;AACA;AACA;AACA,0BAA0B,oBAAoB;AAC9C,mBAAmB,oBAAoB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,oBAAoB;AAC9C;AACA;;AAEA;AACA,6CAA6C;AAC7C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,oBAAoB;AAC9C;AACA;;AAEA;AACA,6CAA6C;AAC7C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,oBAAoB;AAC9C;AACA,8BAA8B,+BAA+B;AAC7D;AACA;;AAEA;AACA;AACA,6CAA6C;AAC7C;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,oBAAoB;AAC/C;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,uCAAuC,oEAAoE;;AAE3G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,oBAAoB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,uCAAuC,oEAAoE;;AAE3G;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,CAAC;;AAED;;AAEA,+BAA+B,IAAI;AACnC,8HAA8H,SAAS,UAAU;AACjJ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,gBAAgB;AACpC;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,uCAAuC,qEAAqE;AAC5G;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,GAAG;AACH,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,oBAAoB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,oBAAoB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,oBAAoB;AACvC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD;AAClD;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,oBAAoB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,oBAAoB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,oBAAoB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;AACA;AACA,uCAAuC,oEAAoE;;AAE3G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA,uCAAuC,oEAAoE;;AAE3G;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA,CAAC;;AAED;;AAEA,iCAAiC,IAAI,mBAAmB,iBAAiB,gGAAgG,SAAS,UAAU;AAC5L;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC,mCAAmC;AACnC;AACA;;AAEA;AACA,4FAA4F;AAC5F;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,kDAAkD;AAClD;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,gFAAgF;AACnH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF,CAAC;;AAED;;AAEA,CAAC;AACD,uHAAuH","sources":["webpack://my-package/webpack/bootstrap","webpack://my-package/webpack/runtime/make namespace object","webpack://my-package/./src/assets/ts/common_v2/features/hebelmaison/polyfill-library.js"],"sourcesContent":["// The require scope\nvar __webpack_require__ = {};\n\n","// define __esModule on exports\n__webpack_require__.r = function(exports) {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","/* Polyfill service DEVELOPMENT MODE - for live use set NODE_ENV to 'production'\n * For detailed credits and licence information see https://github.com/financial-times/polyfill-service.\n * \n * Features requested: Array.from,Object.assign\n * \n * - _ESAbstract.ArrayCreate, License: CC0 (required by \"Array.from\", \"Set\", \"Symbol\", \"Array.prototype.map\", \"_ESAbstract.ArraySpeciesCreate\")\n * - _ESAbstract.Call, License: CC0 (required by \"Array.from\", \"_ESAbstract.ToString\", \"_ESAbstract.ToPrimitive\", \"_ESAbstract.OrdinaryToPrimitive\")\n * - _ESAbstract.Get, License: CC0 (required by \"Array.from\", \"Set\", \"Symbol\", \"Object.getOwnPropertyNames\", \"Array.prototype.indexOf\")\n * - _ESAbstract.HasOwnProperty, License: CC0 (required by \"Object.assign\", \"Object.getOwnPropertyDescriptor\")\n * - _ESAbstract.HasProperty, License: CC0 (required by \"Array.from\", \"Set\", \"Symbol\", \"Object.getOwnPropertyNames\", \"Array.prototype.indexOf\")\n * - _ESAbstract.IsArray, License: CC0 (required by \"Array.from\", \"Set\", \"Symbol\", \"Array.prototype.map\", \"_ESAbstract.ArraySpeciesCreate\")\n * - _ESAbstract.IsCallable, License: CC0 (required by \"Array.from\", \"_ESAbstract.ToString\", \"_ESAbstract.ToPrimitive\", \"_ESAbstract.OrdinaryToPrimitive\")\n * - _ESAbstract.SameValueNonNumber, License: CC0 (required by \"Array.from\", \"Set\", \"_ESAbstract.SameValueZero\")\n * - _ESAbstract.ToBoolean, License: CC0 (required by \"Array.from\", \"Set\", \"Symbol\", \"Array.prototype.filter\")\n * - _ESAbstract.ToObject, License: CC0 (required by \"Array.from\", \"Set\", \"Symbol\", \"Object.getOwnPropertyNames\", \"Array.prototype.indexOf\")\n * - _ESAbstract.GetV, License: CC0 (required by \"Array.from\", \"_ESAbstract.GetIterator\")\n * - _ESAbstract.GetMethod, License: CC0 (required by \"Array.from\", \"_ESAbstract.ToString\", \"_ESAbstract.ToPrimitive\")\n * - _ESAbstract.Type, License: CC0 (required by \"Array.from\", \"Set\", \"Symbol\", \"Array.prototype.map\", \"_ESAbstract.ArraySpeciesCreate\")\n * - _ESAbstract.GetPrototypeFromConstructor, License: CC0 (required by \"Array.from\", \"Set\", \"_ESAbstract.OrdinaryCreateFromConstructor\")\n * - _ESAbstract.IsConstructor, License: CC0 (required by \"Array.from\", \"Set\", \"Symbol\", \"Array.prototype.map\", \"_ESAbstract.ArraySpeciesCreate\")\n * - _ESAbstract.IteratorClose, License: CC0 (required by \"Array.from\", \"Set\")\n * - _ESAbstract.IteratorComplete, License: CC0 (required by \"Array.from\", \"Set\")\n * - _ESAbstract.IteratorNext, License: CC0 (required by \"Array.from\", \"Set\")\n * - _ESAbstract.IteratorStep, License: CC0 (required by \"Array.from\", \"Set\")\n * - _ESAbstract.IteratorValue, License: CC0 (required by \"Array.from\", \"Set\")\n * - _ESAbstract.OrdinaryToPrimitive, License: CC0 (required by \"Array.from\", \"_ESAbstract.ToString\", \"_ESAbstract.ToPrimitive\")\n * - _ESAbstract.SameValueZero, License: CC0 (required by \"Array.from\", \"Set\", \"Symbol\", \"Object.getOwnPropertyNames\", \"Array.prototype.includes\")\n * - _ESAbstract.ToInteger, License: CC0 (required by \"Array.from\", \"Set\", \"Symbol\", \"Object.getOwnPropertyNames\", \"Array.prototype.indexOf\")\n * - _ESAbstract.ToLength, License: CC0 (required by \"Array.from\", \"Set\", \"Symbol\", \"Object.getOwnPropertyNames\", \"Array.prototype.indexOf\")\n * - _ESAbstract.ToPrimitive, License: CC0 (required by \"Object.assign\", \"Object.getOwnPropertyDescriptor\", \"_ESAbstract.ToPropertyKey\")\n * - _ESAbstract.ToString, License: CC0 (required by \"Array.from\", \"Set\", \"Symbol\", \"Object.getOwnPropertyNames\", \"Array.prototype.indexOf\")\n * - _ESAbstract.ToPropertyKey, License: CC0 (required by \"Object.assign\", \"Object.getOwnPropertyDescriptor\")\n * - Object.defineProperty, License: CC0 (required by \"Array.from\", \"Set\", \"_ESAbstract.OrdinaryCreateFromConstructor\", \"Object.create\", \"Object.defineProperties\")\n * - _ESAbstract.CreateDataProperty, License: CC0 (required by \"Array.from\", \"Set\", \"_ESAbstract.CreateIterResultObject\")\n * - _ESAbstract.CreateDataPropertyOrThrow, License: CC0 (required by \"Array.from\", \"Set\", \"Symbol\", \"Array.prototype.map\")\n * - _ESAbstract.CreateIterResultObject, License: CC0 (required by \"Array.from\", \"Set\")\n * - _ESAbstract.CreateMethodProperty, License: CC0 (required by \"Array.from\", \"Set\", \"Symbol\", \"Object.getOwnPropertyNames\", \"Array.prototype.indexOf\")\n * - Array.isArray, License: CC0 (required by \"Array.from\", \"Set\")\n * - Array.prototype.forEach, License: CC0 (required by \"Array.from\", \"Set\", \"Symbol\")\n * - Array.prototype.includes, License: MIT (required by \"Array.from\", \"Set\", \"Symbol\", \"Object.getOwnPropertyNames\")\n * - Array.prototype.indexOf, License: CC0 (required by \"Array.from\", \"Set\", \"Symbol\", \"Object.getOwnPropertyNames\")\n * - Function.prototype.bind, License: MIT (required by \"Object.assign\", \"Object.getOwnPropertyDescriptor\")\n * - Object.freeze, License: CC0 (required by \"Array.from\", \"Set\", \"Symbol\")\n * - Object.getOwnPropertyDescriptor, License: CC0 (required by \"Array.from\", \"Set\", \"_ESAbstract.OrdinaryCreateFromConstructor\", \"Object.create\", \"Object.defineProperties\")\n * - Object.getPrototypeOf, License: CC0 (required by \"Array.from\", \"Set\", \"_ESAbstract.OrdinaryCreateFromConstructor\")\n * - Object.isExtensible, License: CC0 (required by \"Array.from\", \"Map\")\n * - Object.keys, License: MIT (required by \"Array.from\", \"Set\", \"_ESAbstract.OrdinaryCreateFromConstructor\", \"Object.create\", \"Object.defineProperties\")\n * - Object.assign, License: CC0\n * - Object.defineProperties, License: CC0 (required by \"Array.from\", \"Set\", \"_ESAbstract.OrdinaryCreateFromConstructor\", \"Object.create\")\n * - Object.create, License: CC0 (required by \"Array.from\", \"Set\", \"_ESAbstract.OrdinaryCreateFromConstructor\")\n * - _ESAbstract.OrdinaryCreateFromConstructor, License: CC0 (required by \"Array.from\", \"Set\")\n * - _ESAbstract.Construct, License: CC0 (required by \"Array.from\", \"Set\", \"Symbol\", \"Array.prototype.map\", \"_ESAbstract.ArraySpeciesCreate\")\n * - _ESAbstract.ArraySpeciesCreate, License: CC0 (required by \"Array.from\", \"Set\", \"Symbol\", \"Array.prototype.map\")\n * - Array.prototype.filter, License: CC0 (required by \"Array.from\", \"Set\", \"Symbol\")\n * - Array.prototype.map, License: CC0 (required by \"Array.from\", \"Set\", \"Symbol\")\n * - Object.getOwnPropertyNames, License: CC0 (required by \"Array.from\", \"Set\", \"Symbol\")\n * - Symbol, License: MIT (required by \"Array.from\", \"Set\", \"Symbol.species\")\n * - Symbol.iterator, License: MIT (required by \"Array.from\", \"Set\")\n * - _ESAbstract.GetIterator, License: CC0 (required by \"Array.from\", \"Set\")\n * - Symbol.species, License: MIT (required by \"Array.from\", \"Set\")\n * - Map, License: CC0 (required by \"Array.from\")\n * - Set, License: CC0 (required by \"Array.from\")\n * - Array.from, License: CC0 */\n\n(function(self, undefined) {\n\n// _ESAbstract.ArrayCreate\n// 9.4.2.2. ArrayCreate ( length [ , proto ] )\nfunction ArrayCreate(length /* [, proto] */) { // eslint-disable-line no-unused-vars\n\t// 1. Assert: length is an integer Number ≥ 0.\n\t// 2. If length is -0, set length to +0.\n\tif (1 / length === -Infinity) {\n\t\tlength = 0;\n\t}\n\t// 3. If length>2^32-1, throw a RangeError exception.\n\tif (length > (Math.pow(2, 32) - 1)) {\n\t\tthrow new RangeError('Invalid array length');\n\t}\n\t// 4. If proto is not present, set proto to the intrinsic object %ArrayPrototype%.\n\t// 5. Let A be a newly created Array exotic object.\n\tvar A = [];\n\t// 6. Set A's essential internal methods except for [[DefineOwnProperty]] to the default ordinary object definitions specified in 9.1.\n\t// 7. Set A.[[DefineOwnProperty]] as specified in 9.4.2.1.\n\t// 8. Set A.[[Prototype]] to proto.\n\t// 9. Set A.[[Extensible]] to true.\n\t// 10. Perform ! OrdinaryDefineOwnProperty(A, \"length\", PropertyDescriptor{[[Value]]: length, [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: false}).\n\tA.length = length;\n\t// 11. Return A.\n\treturn A;\n}\n\n// _ESAbstract.Call\n/* global IsCallable */\n// 7.3.12. Call ( F, V [ , argumentsList ] )\nfunction Call(F, V /* [, argumentsList] */) { // eslint-disable-line no-unused-vars\n\t// 1. If argumentsList is not present, set argumentsList to a new empty List.\n\tvar argumentsList = arguments.length > 2 ? arguments[2] : [];\n\t// 2. If IsCallable(F) is false, throw a TypeError exception.\n\tif (IsCallable(F) === false) {\n\t\tthrow new TypeError(Object.prototype.toString.call(F) + 'is not a function.');\n\t}\n\t// 3. Return ? F.[[Call]](V, argumentsList).\n\treturn F.apply(V, argumentsList);\n}\n\n// _ESAbstract.Get\n// 7.3.1. Get ( O, P )\nfunction Get(O, P) { // eslint-disable-line no-unused-vars\n\t// 1. Assert: Type(O) is Object.\n\t// 2. Assert: IsPropertyKey(P) is true.\n\t// 3. Return ? O.[[Get]](P, O).\n\treturn O[P];\n}\n\n// _ESAbstract.HasOwnProperty\n// 7.3.11 HasOwnProperty (O, P)\nfunction HasOwnProperty(o, p) { // eslint-disable-line no-unused-vars\n\t// 1. Assert: Type(O) is Object.\n\t// 2. Assert: IsPropertyKey(P) is true.\n\t// 3. Let desc be ? O.[[GetOwnProperty]](P).\n\t// 4. If desc is undefined, return false.\n\t// 5. Return true.\n\t// Polyfill.io - As we expect user agents to support ES3 fully we can skip the above steps and use Object.prototype.hasOwnProperty to do them for us.\n\treturn Object.prototype.hasOwnProperty.call(o, p);\n}\n\n// _ESAbstract.HasProperty\n// 7.3.10. HasProperty ( O, P )\nfunction HasProperty(O, P) { // eslint-disable-line no-unused-vars\n\t// Assert: Type(O) is Object.\n\t// Assert: IsPropertyKey(P) is true.\n\t// Return ? O.[[HasProperty]](P).\n\treturn P in O;\n}\n\n// _ESAbstract.IsArray\n// 7.2.2. IsArray ( argument )\nfunction IsArray(argument) { // eslint-disable-line no-unused-vars\n\t// 1. If Type(argument) is not Object, return false.\n\t// 2. If argument is an Array exotic object, return true.\n\t// 3. If argument is a Proxy exotic object, then\n\t\t// a. If argument.[[ProxyHandler]] is null, throw a TypeError exception.\n\t\t// b. Let target be argument.[[ProxyTarget]].\n\t\t// c. Return ? IsArray(target).\n\t// 4. Return false.\n\n\t// Polyfill.io - We can skip all the above steps and check the string returned from Object.prototype.toString().\n\treturn Object.prototype.toString.call(argument) === '[object Array]';\n}\n\n// _ESAbstract.IsCallable\n// 7.2.3. IsCallable ( argument )\nfunction IsCallable(argument) { // eslint-disable-line no-unused-vars\n\t// 1. If Type(argument) is not Object, return false.\n\t// 2. If argument has a [[Call]] internal method, return true.\n\t// 3. Return false.\n\n\t// Polyfill.io - Only function objects have a [[Call]] internal method. This means we can simplify this function to check that the argument has a type of function.\n\treturn typeof argument === 'function';\n}\n\n// _ESAbstract.SameValueNonNumber\n// 7.2.12. SameValueNonNumber ( x, y )\nfunction SameValueNonNumber(x, y) { // eslint-disable-line no-unused-vars\n\t// 1. Assert: Type(x) is not Number.\n\t// 2. Assert: Type(x) is the same as Type(y).\n\t// 3. If Type(x) is Undefined, return true.\n\t// 4. If Type(x) is Null, return true.\n\t// 5. If Type(x) is String, then\n\t\t// a. If x and y are exactly the same sequence of code units (same length and same code units at corresponding indices), return true; otherwise, return false.\n\t// 6. If Type(x) is Boolean, then\n\t\t// a. If x and y are both true or both false, return true; otherwise, return false.\n\t// 7. If Type(x) is Symbol, then\n\t\t// a. If x and y are both the same Symbol value, return true; otherwise, return false.\n\t// 8. If x and y are the same Object value, return true. Otherwise, return false.\n\n\t// Polyfill.io - We can skip all above steps because the === operator does it all for us.\n\treturn x === y;\n}\n\n// _ESAbstract.ToBoolean\n// 7.1.2. ToBoolean ( argument )\n// The abstract operation ToBoolean converts argument to a value of type Boolean according to Table 9:\n/*\n--------------------------------------------------------------------------------------------------------------\n| Argument Type | Result                                                                                     |\n--------------------------------------------------------------------------------------------------------------\n| Undefined     | Return false.                                                                              |\n| Null          | Return false.                                                                              |\n| Boolean       | Return argument.                                                                           |\n| Number        | If argument is +0, -0, or NaN, return false; otherwise return true.                        |\n| String        | If argument is the empty String (its length is zero), return false; otherwise return true. |\n| Symbol        | Return true.                                                                               |\n| Object        | Return true.                                                                               |\n--------------------------------------------------------------------------------------------------------------\n*/\nfunction ToBoolean(argument) { // eslint-disable-line no-unused-vars\n\treturn Boolean(argument);\n}\n\n// _ESAbstract.ToObject\n// 7.1.13 ToObject ( argument )\n// The abstract operation ToObject converts argument to a value of type Object according to Table 12:\n// Table 12: ToObject Conversions\n/*\n|----------------------------------------------------------------------------------------------------------------------------------------------------|\n| Argument Type | Result                                                                                                                             |\n|----------------------------------------------------------------------------------------------------------------------------------------------------|\n| Undefined     | Throw a TypeError exception.                                                                                                       |\n| Null          | Throw a TypeError exception.                                                                                                       |\n| Boolean       | Return a new Boolean object whose [[BooleanData]] internal slot is set to argument. See 19.3 for a description of Boolean objects. |\n| Number        | Return a new Number object whose [[NumberData]] internal slot is set to argument. See 20.1 for a description of Number objects.    |\n| String        | Return a new String object whose [[StringData]] internal slot is set to argument. See 21.1 for a description of String objects.    |\n| Symbol        | Return a new Symbol object whose [[SymbolData]] internal slot is set to argument. See 19.4 for a description of Symbol objects.    |\n| Object        | Return argument.                                                                                                                   |\n|----------------------------------------------------------------------------------------------------------------------------------------------------|\n*/\nfunction ToObject(argument) { // eslint-disable-line no-unused-vars\n\tif (argument === null || argument === undefined) {\n\t\tthrow TypeError();\n\t}\n\treturn Object(argument);\n}\n\n// _ESAbstract.GetV\n/* global ToObject */\n// 7.3.2 GetV (V, P)\nfunction GetV(v, p) { // eslint-disable-line no-unused-vars\n\t// 1. Assert: IsPropertyKey(P) is true.\n\t// 2. Let O be ? ToObject(V).\n\tvar o = ToObject(v);\n\t// 3. Return ? O.[[Get]](P, V).\n\treturn o[p];\n}\n\n// _ESAbstract.GetMethod\n/* global GetV, IsCallable */\n// 7.3.9. GetMethod ( V, P )\nfunction GetMethod(V, P) { // eslint-disable-line no-unused-vars\n\t// 1. Assert: IsPropertyKey(P) is true.\n\t// 2. Let func be ? GetV(V, P).\n\tvar func = GetV(V, P);\n\t// 3. If func is either undefined or null, return undefined.\n\tif (func === null || func === undefined) {\n\t\treturn undefined;\n\t}\n\t// 4. If IsCallable(func) is false, throw a TypeError exception.\n\tif (IsCallable(func) === false) {\n\t\tthrow new TypeError('Method not callable: ' + P);\n\t}\n\t// 5. Return func.\n\treturn func;\n}\n\n// _ESAbstract.Type\n// \"Type(x)\" is used as shorthand for \"the type of x\"...\nfunction Type(x) { // eslint-disable-line no-unused-vars\n\tswitch (typeof x) {\n\t\tcase 'undefined':\n\t\t\treturn 'undefined';\n\t\tcase 'boolean':\n\t\t\treturn 'boolean';\n\t\tcase 'number':\n\t\t\treturn 'number';\n\t\tcase 'string':\n\t\t\treturn 'string';\n\t\tcase 'symbol':\n\t\t\treturn 'symbol';\n\t\tdefault:\n\t\t\t// typeof null is 'object'\n\t\t\tif (x === null) return 'null';\n\t\t\t// Polyfill.io - This is here because a Symbol polyfill will have a typeof `object`.\n\t\t\tif ('Symbol' in self && (x instanceof self.Symbol || x.constructor === self.Symbol)) return 'symbol';\n\n\t\t\treturn 'object';\n\t}\n}\n\n// _ESAbstract.GetPrototypeFromConstructor\n/* global Get, Type */\n// 9.1.14. GetPrototypeFromConstructor ( constructor, intrinsicDefaultProto )\nfunction GetPrototypeFromConstructor(constructor, intrinsicDefaultProto) { // eslint-disable-line no-unused-vars\n\t// 1. Assert: intrinsicDefaultProto is a String value that is this specification's name of an intrinsic object. The corresponding object must be an intrinsic that is intended to be used as the [[Prototype]] value of an object.\n\t// 2. Assert: IsCallable(constructor) is true.\n\t// 3. Let proto be ? Get(constructor, \"prototype\").\n\tvar proto = Get(constructor, \"prototype\");\n\t// 4. If Type(proto) is not Object, then\n\tif (Type(proto) !== 'object') {\n\t\t// a. Let realm be ? GetFunctionRealm(constructor).\n\t\t// b. Set proto to realm's intrinsic object named intrinsicDefaultProto.\n\t\tproto = intrinsicDefaultProto;\n\t}\n\t// 5. Return proto.\n\treturn proto;\n}\n\n// _ESAbstract.IsConstructor\n/* global Type */\n// 7.2.4. IsConstructor ( argument )\nfunction IsConstructor(argument) { // eslint-disable-line no-unused-vars\n\t// 1. If Type(argument) is not Object, return false.\n\tif (Type(argument) !== 'object') {\n\t\treturn false;\n\t}\n\t// 2. If argument has a [[Construct]] internal method, return true.\n\t// 3. Return false.\n\n\t// Polyfill.io - `new argument` is the only way  to truly test if a function is a constructor.\n\t// We choose to not use`new argument` because the argument could have side effects when called.\n\t// Instead we check to see if the argument is a function and if it has a prototype.\n\t// Arrow functions do not have a [[Construct]] internal method, nor do they have a prototype.\n\treturn typeof argument === 'function' && !!argument.prototype;\n}\n\n// _ESAbstract.IteratorClose\n/* global GetMethod, Type, Call */\n// 7.4.6. IteratorClose ( iteratorRecord, completion )\nfunction IteratorClose(iteratorRecord, completion) { // eslint-disable-line no-unused-vars\n\t// 1. Assert: Type(iteratorRecord.[[Iterator]]) is Object.\n\tif (Type(iteratorRecord['[[Iterator]]']) !== 'object') {\n\t\tthrow new Error(Object.prototype.toString.call(iteratorRecord['[[Iterator]]']) + 'is not an Object.');\n\t}\n\t// 2. Assert: completion is a Completion Record.\n\t// Polyfill.io - Ignoring this step as there is no way to check if something is a Completion Record in userland JavaScript.\n\n\t// 3. Let iterator be iteratorRecord.[[Iterator]].\n\tvar iterator = iteratorRecord['[[Iterator]]'];\n\t// 4. Let return be ? GetMethod(iterator, \"return\").\n\t// Polyfill.io - We name it  returnMethod because return is a keyword and can not be used as an identifier (E.G. variable name, function name etc).\n\tvar returnMethod = GetMethod(iterator, \"return\");\n\t// 5. If return is undefined, return Completion(completion).\n\tif (returnMethod === undefined) {\n\t\treturn completion;\n\t}\n\t// 6. Let innerResult be Call(return, iterator, « »).\n\ttry {\n\t\tvar innerResult = Call(returnMethod, iterator);\n\t} catch (error) {\n\t\tvar innerException = error;\n\t}\n\t// 7. If completion.[[Type]] is throw, return Completion(completion).\n\tif (completion) {\n\t\treturn completion;\n\t}\n\t// 8. If innerResult.[[Type]] is throw, return Completion(innerResult).\n\tif (innerException) {\n\t\tthrow innerException;\n\t}\n\t// 9. If Type(innerResult.[[Value]]) is not Object, throw a TypeError exception.\n\tif (Type(innerResult) !== 'object') {\n\t\tthrow new TypeError(\"Iterator's return method returned a non-object.\");\n\t}\n\t// 10. Return Completion(completion).\n\treturn completion;\n}\n\n// _ESAbstract.IteratorComplete\n/* global Type, ToBoolean, Get */\n// 7.4.3 IteratorComplete ( iterResult )\nfunction IteratorComplete(iterResult) { // eslint-disable-line no-unused-vars\n\t// 1. Assert: Type(iterResult) is Object.\n\tif (Type(iterResult) !== 'object') {\n\t\tthrow new Error(Object.prototype.toString.call(iterResult) + 'is not an Object.');\n\t}\n\t// 2. Return ToBoolean(? Get(iterResult, \"done\")).\n\treturn ToBoolean(Get(iterResult, \"done\"));\n}\n\n// _ESAbstract.IteratorNext\n/* global Call, Type */\n// 7.4.2. IteratorNext ( iteratorRecord [ , value ] )\nfunction IteratorNext(iteratorRecord /* [, value] */) { // eslint-disable-line no-unused-vars\n\t// 1. If value is not present, then\n\tif (arguments.length < 2) {\n\t\t// a. Let result be ? Call(iteratorRecord.[[NextMethod]], iteratorRecord.[[Iterator]], « »).\n\t\tvar result = Call(iteratorRecord['[[NextMethod]]'], iteratorRecord['[[Iterator]]']);\n\t// 2. Else,\n\t} else {\n\t\t// a. Let result be ? Call(iteratorRecord.[[NextMethod]], iteratorRecord.[[Iterator]], « value »).\n\t\tresult = Call(iteratorRecord['[[NextMethod]]'], iteratorRecord['[[Iterator]]'], [arguments[1]]);\n\t}\n\t// 3. If Type(result) is not Object, throw a TypeError exception.\n\tif (Type(result) !== 'object') {\n\t\tthrow new TypeError('bad iterator');\n\t}\n\t// 4. Return result.\n\treturn result;\n}\n\n// _ESAbstract.IteratorStep\n/* global IteratorNext, IteratorComplete */\n// 7.4.5. IteratorStep ( iteratorRecord )\nfunction IteratorStep(iteratorRecord) { // eslint-disable-line no-unused-vars\n\t// 1. Let result be ? IteratorNext(iteratorRecord).\n\tvar result = IteratorNext(iteratorRecord);\n\t// 2. Let done be ? IteratorComplete(result).\n\tvar done = IteratorComplete(result);\n\t// 3. If done is true, return false.\n\tif (done === true) {\n\t\treturn false;\n\t}\n\t// 4. Return result.\n\treturn result;\n}\n\n// _ESAbstract.IteratorValue\n/* global Type, Get */\n// 7.4.4 IteratorValue ( iterResult )\nfunction IteratorValue(iterResult) { // eslint-disable-line no-unused-vars\n\t// Assert: Type(iterResult) is Object.\n\tif (Type(iterResult) !== 'object') {\n\t\tthrow new Error(Object.prototype.toString.call(iterResult) + 'is not an Object.');\n\t}\n\t// Return ? Get(iterResult, \"value\").\n\treturn Get(iterResult, \"value\");\n}\n\n// _ESAbstract.OrdinaryToPrimitive\n/* global Get, IsCallable, Call, Type */\n// 7.1.1.1. OrdinaryToPrimitive ( O, hint )\nfunction OrdinaryToPrimitive(O, hint) { // eslint-disable-line no-unused-vars\n\t// 1. Assert: Type(O) is Object.\n\t// 2. Assert: Type(hint) is String and its value is either \"string\" or \"number\".\n\t// 3. If hint is \"string\", then\n\tif (hint === 'string') {\n\t\t// a. Let methodNames be « \"toString\", \"valueOf\" ».\n\t\tvar methodNames = ['toString', 'valueOf'];\n\t\t// 4. Else,\n\t} else {\n\t\t// a. Let methodNames be « \"valueOf\", \"toString\" ».\n\t\tmethodNames = ['valueOf', 'toString'];\n\t}\n\t// 5. For each name in methodNames in List order, do\n\tfor (var i = 0; i < methodNames.length; ++i) {\n\t\tvar name = methodNames[i];\n\t\t// a. Let method be ? Get(O, name).\n\t\tvar method = Get(O, name);\n\t\t// b. If IsCallable(method) is true, then\n\t\tif (IsCallable(method)) {\n\t\t\t// i. Let result be ? Call(method, O).\n\t\t\tvar result = Call(method, O);\n\t\t\t// ii. If Type(result) is not Object, return result.\n\t\t\tif (Type(result) !== 'object') {\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\t}\n\t// 6. Throw a TypeError exception.\n\tthrow new TypeError('Cannot convert to primitive.');\n}\n\n// _ESAbstract.SameValueZero\n/* global Type, SameValueNonNumber */\n// 7.2.11. SameValueZero ( x, y )\nfunction SameValueZero (x, y) { // eslint-disable-line no-unused-vars\n\t// 1. If Type(x) is different from Type(y), return false.\n\tif (Type(x) !== Type(y)) {\n\t\treturn false;\n\t}\n\t// 2. If Type(x) is Number, then\n\tif (Type(x) === 'number') {\n\t\t// a. If x is NaN and y is NaN, return true.\n\t\tif (isNaN(x) && isNaN(y)) {\n\t\t\treturn true;\n\t\t}\n\t\t// b. If x is +0 and y is -0, return true.\n\t\tif (1/x === Infinity && 1/y === -Infinity) {\n\t\t\treturn true;\n\t\t}\n\t\t// c. If x is -0 and y is +0, return true.\n\t\tif (1/x === -Infinity && 1/y === Infinity) {\n\t\t\treturn true;\n\t\t}\n\t\t// d. If x is the same Number value as y, return true.\n\t\tif (x === y) {\n\t\t\treturn true;\n\t\t}\n\t\t// e. Return false.\n\t\treturn false;\n\t}\n\t// 3. Return SameValueNonNumber(x, y).\n\treturn SameValueNonNumber(x, y);\n}\n\n// _ESAbstract.ToInteger\n/* global Type */\n// 7.1.4. ToInteger ( argument )\nfunction ToInteger(argument) { // eslint-disable-line no-unused-vars\n\tif (Type(argument) === 'symbol') {\n\t\tthrow new TypeError('Cannot convert a Symbol value to a number');\n\t}\n\n\t// 1. Let number be ? ToNumber(argument).\n\tvar number = Number(argument);\n\t// 2. If number is NaN, return +0.\n\tif (isNaN(number)) {\n\t\treturn 0;\n\t}\n\t// 3. If number is +0, -0, +∞, or -∞, return number.\n\tif (1/number === Infinity || 1/number === -Infinity || number === Infinity || number === -Infinity) {\n\t\treturn number;\n\t}\n\t// 4. Return the number value that is the same sign as number and whose magnitude is floor(abs(number)).\n\treturn ((number < 0) ? -1 : 1) * Math.floor(Math.abs(number));\n}\n\n// _ESAbstract.ToLength\n/* global ToInteger */\n// 7.1.15. ToLength ( argument )\nfunction ToLength(argument) { // eslint-disable-line no-unused-vars\n\t// 1. Let len be ? ToInteger(argument).\n\tvar len = ToInteger(argument);\n\t// 2. If len ≤ +0, return +0.\n\tif (len <= 0) {\n\t\treturn 0;\n\t}\n\t// 3. Return min(len, 253-1).\n\treturn Math.min(len, Math.pow(2, 53) -1);\n}\n\n// _ESAbstract.ToPrimitive\n/* global Type, GetMethod, Call, OrdinaryToPrimitive */\n// 7.1.1. ToPrimitive ( input [ , PreferredType ] )\nfunction ToPrimitive(input /* [, PreferredType] */) { // eslint-disable-line no-unused-vars\n\tvar PreferredType = arguments.length > 1 ? arguments[1] : undefined;\n\t// 1. Assert: input is an ECMAScript language value.\n\t// 2. If Type(input) is Object, then\n\tif (Type(input) === 'object') {\n\t\t// a. If PreferredType is not present, let hint be \"default\".\n\t\tif (arguments.length < 2) {\n\t\t\tvar hint = 'default';\n\t\t\t// b. Else if PreferredType is hint String, let hint be \"string\".\n\t\t} else if (PreferredType === String) {\n\t\t\thint = 'string';\n\t\t\t// c. Else PreferredType is hint Number, let hint be \"number\".\n\t\t} else if (PreferredType === Number) {\n\t\t\thint = 'number';\n\t\t}\n\t\t// d. Let exoticToPrim be ? GetMethod(input, @@toPrimitive).\n\t\tvar exoticToPrim = typeof self.Symbol === 'function' && typeof self.Symbol.toPrimitive === 'symbol' ? GetMethod(input, self.Symbol.toPrimitive) : undefined;\n\t\t// e. If exoticToPrim is not undefined, then\n\t\tif (exoticToPrim !== undefined) {\n\t\t\t// i. Let result be ? Call(exoticToPrim, input, « hint »).\n\t\t\tvar result = Call(exoticToPrim, input, [hint]);\n\t\t\t// ii. If Type(result) is not Object, return result.\n\t\t\tif (Type(result) !== 'object') {\n\t\t\t\treturn result;\n\t\t\t}\n\t\t\t// iii. Throw a TypeError exception.\n\t\t\tthrow new TypeError('Cannot convert exotic object to primitive.');\n\t\t}\n\t\t// f. If hint is \"default\", set hint to \"number\".\n\t\tif (hint === 'default') {\n\t\t\thint = 'number';\n\t\t}\n\t\t// g. Return ? OrdinaryToPrimitive(input, hint).\n\t\treturn OrdinaryToPrimitive(input, hint);\n\t}\n\t// 3. Return input\n\treturn input;\n}\n\n// _ESAbstract.ToString\n/* global Type, ToPrimitive */\n// 7.1.12. ToString ( argument )\n// The abstract operation ToString converts argument to a value of type String according to Table 11:\n// Table 11: ToString Conversions\n/*\n|---------------|--------------------------------------------------------|\n| Argument Type | Result                                                 |\n|---------------|--------------------------------------------------------|\n| Undefined     | Return \"undefined\".                                    |\n|---------------|--------------------------------------------------------|\n| Null\t        | Return \"null\".                                         |\n|---------------|--------------------------------------------------------|\n| Boolean       | If argument is true, return \"true\".                    |\n|               | If argument is false, return \"false\".                  |\n|---------------|--------------------------------------------------------|\n| Number        | Return NumberToString(argument).                       |\n|---------------|--------------------------------------------------------|\n| String        | Return argument.                                       |\n|---------------|--------------------------------------------------------|\n| Symbol        | Throw a TypeError exception.                           |\n|---------------|--------------------------------------------------------|\n| Object        | Apply the following steps:                             |\n|               | Let primValue be ? ToPrimitive(argument, hint String). |\n|               | Return ? ToString(primValue).                          |\n|---------------|--------------------------------------------------------|\n*/\nfunction ToString(argument) { // eslint-disable-line no-unused-vars\n\tswitch(Type(argument)) {\n\t\tcase 'symbol':\n\t\t\tthrow new TypeError('Cannot convert a Symbol value to a string');\n\t\tcase 'object':\n\t\t\tvar primValue = ToPrimitive(argument, String);\n\t\t\treturn ToString(primValue); // eslint-disable-line no-unused-vars\n\t\tdefault:\n\t\t\treturn String(argument);\n\t}\n}\n\n// _ESAbstract.ToPropertyKey\n/* globals ToPrimitive, Type, ToString */\n// 7.1.14. ToPropertyKey ( argument )\nfunction ToPropertyKey(argument) { // eslint-disable-line no-unused-vars\n\t// 1. Let key be ? ToPrimitive(argument, hint String).\n\tvar key = ToPrimitive(argument, String);\n\t// 2. If Type(key) is Symbol, then\n\tif (Type(key) === 'symbol') {\n\t\t// a. Return key.\n\t\treturn key;\n\t}\n\t// 3. Return ! ToString(key).\n\treturn ToString(key);\n}\nif (!(\"defineProperty\"in Object&&function(){try{var e={}\nreturn Object.defineProperty(e,\"test\",{value:42}),!0}catch(t){return!1}}()\n)) {\n\n// Object.defineProperty\n(function (nativeDefineProperty) {\n\n\tvar supportsAccessors = Object.prototype.hasOwnProperty.call(Object.prototype, '__defineGetter__');\n\tvar ERR_ACCESSORS_NOT_SUPPORTED = 'Getters & setters cannot be defined on this javascript engine';\n\tvar ERR_VALUE_ACCESSORS = 'A property cannot both have accessors and be writable or have a value';\n\n\t// Polyfill.io - This does not use CreateMethodProperty because our CreateMethodProperty function uses Object.defineProperty.\n\tObject.defineProperty = function defineProperty(object, property, descriptor) {\n\n\t\t// Where native support exists, assume it\n\t\tif (nativeDefineProperty && (object === window || object === document || object === Element.prototype || object instanceof Element)) {\n\t\t\treturn nativeDefineProperty(object, property, descriptor);\n\t\t}\n\n\t\tif (object === null || !(object instanceof Object || typeof object === 'object')) {\n\t\t\tthrow new TypeError('Object.defineProperty called on non-object');\n\t\t}\n\n\t\tif (!(descriptor instanceof Object)) {\n\t\t\tthrow new TypeError('Property description must be an object');\n\t\t}\n\n\t\tvar propertyString = String(property);\n\t\tvar hasValueOrWritable = 'value' in descriptor || 'writable' in descriptor;\n\t\tvar getterType = 'get' in descriptor && typeof descriptor.get;\n\t\tvar setterType = 'set' in descriptor && typeof descriptor.set;\n\n\t\t// handle descriptor.get\n\t\tif (getterType) {\n\t\t\tif (getterType === undefined) {\n\t\t\t\treturn object;\n\t\t\t}\n\t\t\tif (getterType !== 'function') {\n\t\t\t\tthrow new TypeError('Getter must be a function');\n\t\t\t}\n\t\t\tif (!supportsAccessors) {\n\t\t\t\tthrow new TypeError(ERR_ACCESSORS_NOT_SUPPORTED);\n\t\t\t}\n\t\t\tif (hasValueOrWritable) {\n\t\t\t\tthrow new TypeError(ERR_VALUE_ACCESSORS);\n\t\t\t}\n\t\t\tObject.__defineGetter__.call(object, propertyString, descriptor.get);\n\t\t} else {\n\t\t\tobject[propertyString] = descriptor.value;\n\t\t}\n\n\t\t// handle descriptor.set\n\t\tif (setterType) {\n\t\t\tif (setterType === undefined) {\n\t\t\t\treturn object;\n\t\t\t}\n\t\t\tif (setterType !== 'function') {\n\t\t\t\tthrow new TypeError('Setter must be a function');\n\t\t\t}\n\t\t\tif (!supportsAccessors) {\n\t\t\t\tthrow new TypeError(ERR_ACCESSORS_NOT_SUPPORTED);\n\t\t\t}\n\t\t\tif (hasValueOrWritable) {\n\t\t\t\tthrow new TypeError(ERR_VALUE_ACCESSORS);\n\t\t\t}\n\t\t\tObject.__defineSetter__.call(object, propertyString, descriptor.set);\n\t\t}\n\n\t\t// OK to define value unconditionally - if a getter has been specified as well, an error would be thrown above\n\t\tif ('value' in descriptor) {\n\t\t\tobject[propertyString] = descriptor.value;\n\t\t}\n\n\t\treturn object;\n\t};\n}(Object.defineProperty));\n\n}\n\n\n// _ESAbstract.CreateDataProperty\n// 7.3.4. CreateDataProperty ( O, P, V )\n// NOTE\n// This abstract operation creates a property whose attributes are set to the same defaults used for properties created by the ECMAScript language assignment operator.\n// Normally, the property will not already exist. If it does exist and is not configurable or if O is not extensible, [[DefineOwnProperty]] will return false.\nfunction CreateDataProperty(O, P, V) { // eslint-disable-line no-unused-vars\n\t// 1. Assert: Type(O) is Object.\n\t// 2. Assert: IsPropertyKey(P) is true.\n\t// 3. Let newDesc be the PropertyDescriptor{ [[Value]]: V, [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: true }.\n\tvar newDesc = {\n\t\tvalue: V,\n\t\twritable: true,\n\t\tenumerable: true,\n\t\tconfigurable: true\n\t};\n\t// 4. Return ? O.[[DefineOwnProperty]](P, newDesc).\n\ttry {\n\t\tObject.defineProperty(O, P, newDesc);\n\t\treturn true;\n\t} catch (e) {\n\t\treturn false;\n\t}\n}\n\n// _ESAbstract.CreateDataPropertyOrThrow\n/* global CreateDataProperty */\n// 7.3.6. CreateDataPropertyOrThrow ( O, P, V )\nfunction CreateDataPropertyOrThrow(O, P, V) { // eslint-disable-line no-unused-vars\n\t// 1. Assert: Type(O) is Object.\n\t// 2. Assert: IsPropertyKey(P) is true.\n\t// 3. Let success be ? CreateDataProperty(O, P, V).\n\tvar success = CreateDataProperty(O, P, V);\n\t// 4. If success is false, throw a TypeError exception.\n\tif (!success) {\n\t\tthrow new TypeError('Cannot assign value `' + Object.prototype.toString.call(V) + '` to property `' + Object.prototype.toString.call(P) + '` on object `' + Object.prototype.toString.call(O) + '`');\n\t}\n\t// 5. Return success.\n\treturn success;\n}\n\n// _ESAbstract.CreateIterResultObject\n/* global Type, CreateDataProperty */\n// 7.4.7. CreateIterResultObject ( value, done )\nfunction CreateIterResultObject(value, done) { // eslint-disable-line no-unused-vars\n\t// 1. Assert: Type(done) is Boolean.\n\tif (Type(done) !== 'boolean') {\n\t\tthrow new Error();\n\t}\n\t// 2. Let obj be ObjectCreate(%ObjectPrototype%).\n\tvar obj = {};\n\t// 3. Perform CreateDataProperty(obj, \"value\", value).\n\tCreateDataProperty(obj, \"value\", value);\n\t// 4. Perform CreateDataProperty(obj, \"done\", done).\n\tCreateDataProperty(obj, \"done\", done);\n\t// 5. Return obj.\n\treturn obj;\n}\n\n// _ESAbstract.CreateMethodProperty\n// 7.3.5. CreateMethodProperty ( O, P, V )\nfunction CreateMethodProperty(O, P, V) { // eslint-disable-line no-unused-vars\n\t// 1. Assert: Type(O) is Object.\n\t// 2. Assert: IsPropertyKey(P) is true.\n\t// 3. Let newDesc be the PropertyDescriptor{[[Value]]: V, [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: true}.\n\tvar newDesc = {\n\t\tvalue: V,\n\t\twritable: true,\n\t\tenumerable: false,\n\t\tconfigurable: true\n\t};\n\t// 4. Return ? O.[[DefineOwnProperty]](P, newDesc).\n\tObject.defineProperty(O, P, newDesc);\n}\nif (!(\"isArray\"in Array\n)) {\n\n// Array.isArray\n/* global CreateMethodProperty, IsArray */\n// 22.1.2.2. Array.isArray ( arg )\nCreateMethodProperty(Array, 'isArray', function isArray(arg) {\n\t// 1. Return ? IsArray(arg).\n\treturn IsArray(arg);\n});\n\n}\n\nif (!(\"forEach\"in Array.prototype\n)) {\n\n// Array.prototype.forEach\n/* global Call, CreateMethodProperty, Get, HasProperty, IsCallable, ToLength, ToObject, ToString */\n// 22.1.3.10. Array.prototype.forEach ( callbackfn [ , thisArg ] )\nCreateMethodProperty(Array.prototype, 'forEach', function forEach(callbackfn /* [ , thisArg ] */) {\n\t// 1. Let O be ? ToObject(this value).\n\tvar O = ToObject(this);\n\t// Polyfill.io - If O is a String object, split it into an array in order to iterate correctly.\n\t// We will use arrayLike in place of O when we are iterating through the list.\n\tvar arraylike = O instanceof String ? O.split('') : O;\n\t// 2. Let len be ? ToLength(? Get(O, \"length\")).\n\tvar len = ToLength(Get(O, \"length\"));\n\t// 3. If IsCallable(callbackfn) is false, throw a TypeError exception.\n\tif (IsCallable(callbackfn) === false) {\n\t\tthrow new TypeError(callbackfn + ' is not a function');\n\t}\n\t// 4. If thisArg is present, let T be thisArg; else let T be undefined.\n\tvar T = arguments.length > 1 ? arguments[1] : undefined;\n\t// 5. Let k be 0.\n\tvar k = 0;\n\t// 6. Repeat, while k < len\n\twhile (k < len) {\n\t\t// a. Let Pk be ! ToString(k).\n\t\tvar Pk = ToString(k);\n\t\t// b. Let kPresent be ? HasProperty(O, Pk).\n\t\tvar kPresent = HasProperty(arraylike, Pk);\n\t\t// c. If kPresent is true, then\n\t\tif (kPresent) {\n\t\t\t// i. Let kValue be ? Get(O, Pk).\n\t\t\tvar kValue = Get(arraylike, Pk);\n\t\t\t// ii. Perform ? Call(callbackfn, T, « kValue, k, O »).\n\t\t\tCall(callbackfn, T, [kValue, k, O]);\n\t\t}\n\t\t// d. Increase k by 1.\n\t\tk = k + 1;\n\t}\n\t// 7. Return undefined.\n\treturn undefined;\n});\n\n}\n\nif (!(\"includes\"in Array.prototype\n)) {\n\n// Array.prototype.includes\n/* global CreateMethodProperty, Get, SameValueZero, ToInteger, ToLength, ToObject, ToString */\n// 22.1.3.11. Array.prototype.includes ( searchElement [ , fromIndex ] )\nCreateMethodProperty(Array.prototype, 'includes', function includes(searchElement /* [ , fromIndex ] */) {\n\t'use strict';\n\t// 1. Let O be ? ToObject(this value).\n\tvar O = ToObject(this);\n\t// 2. Let len be ? ToLength(? Get(O, \"length\")).\n\tvar len = ToLength(Get(O, \"length\"));\n\t// 3. If len is 0, return false.\n\tif (len === 0) {\n\t\treturn false;\n\t}\n\t// 4. Let n be ? ToInteger(fromIndex). (If fromIndex is undefined, this step produces the value 0.)\n\tvar n = ToInteger(arguments[1]);\n\t// 5. If n ≥ 0, then\n\tif (n >= 0) {\n\t\t// a. Let k be n.\n\t\tvar k = n;\n\t\t// 6. Else n < 0,\n\t} else {\n\t\t// a. Let k be len + n.\n\t\tk = len + n;\n\t\t// b. If k < 0, let k be 0.\n\t\tif (k < 0) {\n\t\t\tk = 0;\n\t\t}\n\t}\n\t// 7. Repeat, while k < len\n\twhile (k < len) {\n\t\t// a. Let elementK be the result of ? Get(O, ! ToString(k)).\n\t\tvar elementK = Get(O, ToString(k));\n\t\t// b. If SameValueZero(searchElement, elementK) is true, return true.\n\t\tif (SameValueZero(searchElement, elementK)) {\n\t\t\treturn true;\n\t\t}\n\t\t// c. Increase k by 1.\n\t\tk = k + 1;\n\t}\n\t// 8. Return false.\n\treturn false;\n});\n\n}\n\nif (!(\"indexOf\"in Array.prototype\n)) {\n\n// Array.prototype.indexOf\n/* global CreateMethodProperty, Get, HasProperty, ToInteger, ToLength, ToObject, ToString */\n// 22.1.3.12. Array.prototype.indexOf ( searchElement [ , fromIndex ] )\nCreateMethodProperty(Array.prototype, 'indexOf', function indexOf(searchElement /* [ , fromIndex ] */) {\n\t// 1. Let O be ? ToObject(this value).\n\tvar O = ToObject(this);\n\t// 2. Let len be ? ToLength(? Get(O, \"length\")).\n\tvar len = ToLength(Get(O, \"length\"));\n\t// 3. If len is 0, return -1.\n\tif (len === 0) {\n\t\treturn -1;\n\t}\n\t// 4. Let n be ? ToInteger(fromIndex). (If fromIndex is undefined, this step produces the value 0.)\n\tvar n = ToInteger(arguments[1]);\n\t// 5. If n ≥ len, return -1.\n\tif (n >= len) {\n\t\treturn -1;\n\t}\n\t// 6. If n ≥ 0, then\n\tif (n >= 0) {\n\t\t// a. If n is -0, let k be +0; else let k be n.\n\t\tvar k = 1/n === -Infinity ? 0 : n;\n\t\t// 7. Else n < 0,\n\t} else {\n\t\t// a. Let k be len + n.\n\t\tk = len + n;\n\t\t// b. If k < 0, let k be 0.\n\t\tif (k < 0) {\n\t\t\tk = 0;\n\t\t}\n\t}\n\t// 8. Repeat, while k < len\n\twhile (k < len) {\n\t\t// a. Let kPresent be ? HasProperty(O, ! ToString(k)).\n\t\tvar kPresent = HasProperty(O, ToString(k));\n\t\t// b. If kPresent is true, then\n\t\tif (kPresent) {\n\t\t\t// i. Let elementK be ? Get(O, ! ToString(k)).\n\t\t\tvar elementK = Get(O, ToString(k));\n\t\t\t// ii. Let same be the result of performing Strict Equality Comparison searchElement === elementK.\n\t\t\tvar same = searchElement === elementK;\n\t\t\t// iii. If same is true, return k.\n\t\t\tif (same) {\n\t\t\t\treturn k;\n\t\t\t}\n\t\t}\n\t\t// c. Increase k by 1.\n\t\tk = k + 1;\n\t}\n\t// 9. Return -1.\n\treturn -1;\n});\n\n}\n\nif (!(\"bind\"in Function.prototype\n)) {\n\n// Function.prototype.bind\n/* global CreateMethodProperty, IsCallable */\n// 19.2.3.2. Function.prototype.bind ( thisArg, ...args )\n// https://github.com/es-shims/es5-shim/blob/d6d7ff1b131c7ba14c798cafc598bb6780d37d3b/es5-shim.js#L182\nCreateMethodProperty(Function.prototype, 'bind', function bind(that) { // .length is 1\n\t// add necessary es5-shim utilities\n\tvar $Array = Array;\n\tvar $Object = Object;\n\tvar ArrayPrototype = $Array.prototype;\n\tvar Empty = function Empty() { };\n\tvar array_slice = ArrayPrototype.slice;\n\tvar array_concat = ArrayPrototype.concat;\n\tvar array_push = ArrayPrototype.push;\n\tvar max = Math.max;\n\t// /add necessary es5-shim utilities\n\n\t// 1. Let Target be the this value.\n\tvar target = this;\n\t// 2. If IsCallable(Target) is false, throw a TypeError exception.\n\tif (!IsCallable(target)) {\n\t\tthrow new TypeError('Function.prototype.bind called on incompatible ' + target);\n\t}\n\t// 3. Let A be a new (possibly empty) internal list of all of the\n\t//   argument values provided after thisArg (arg1, arg2 etc), in order.\n\t// XXX slicedArgs will stand in for \"A\" if used\n\tvar args = array_slice.call(arguments, 1); // for normal call\n\t// 4. Let F be a new native ECMAScript object.\n\t// 11. Set the [[Prototype]] internal property of F to the standard\n\t//   built-in Function prototype object as specified in 15.3.3.1.\n\t// 12. Set the [[Call]] internal property of F as described in\n\t//   15.3.4.5.1.\n\t// 13. Set the [[Construct]] internal property of F as described in\n\t//   15.3.4.5.2.\n\t// 14. Set the [[HasInstance]] internal property of F as described in\n\t//   15.3.4.5.3.\n\tvar bound;\n\tvar binder = function () {\n\n\t\tif (this instanceof bound) {\n\t\t\t// 15.3.4.5.2 [[Construct]]\n\t\t\t// When the [[Construct]] internal method of a function object,\n\t\t\t// F that was created using the bind function is called with a\n\t\t\t// list of arguments ExtraArgs, the following steps are taken:\n\t\t\t// 1. Let target be the value of F's [[TargetFunction]]\n\t\t\t//   internal property.\n\t\t\t// 2. If target has no [[Construct]] internal method, a\n\t\t\t//   TypeError exception is thrown.\n\t\t\t// 3. Let boundArgs be the value of F's [[BoundArgs]] internal\n\t\t\t//   property.\n\t\t\t// 4. Let args be a new list containing the same values as the\n\t\t\t//   list boundArgs in the same order followed by the same\n\t\t\t//   values as the list ExtraArgs in the same order.\n\t\t\t// 5. Return the result of calling the [[Construct]] internal\n\t\t\t//   method of target providing args as the arguments.\n\n\t\t\tvar result = target.apply(\n\t\t\t\tthis,\n\t\t\t\tarray_concat.call(args, array_slice.call(arguments))\n\t\t\t);\n\t\t\tif ($Object(result) === result) {\n\t\t\t\treturn result;\n\t\t\t}\n\t\t\treturn this;\n\n\t\t} else {\n\t\t\t// 15.3.4.5.1 [[Call]]\n\t\t\t// When the [[Call]] internal method of a function object, F,\n\t\t\t// which was created using the bind function is called with a\n\t\t\t// this value and a list of arguments ExtraArgs, the following\n\t\t\t// steps are taken:\n\t\t\t// 1. Let boundArgs be the value of F's [[BoundArgs]] internal\n\t\t\t//   property.\n\t\t\t// 2. Let boundThis be the value of F's [[BoundThis]] internal\n\t\t\t//   property.\n\t\t\t// 3. Let target be the value of F's [[TargetFunction]] internal\n\t\t\t//   property.\n\t\t\t// 4. Let args be a new list containing the same values as the\n\t\t\t//   list boundArgs in the same order followed by the same\n\t\t\t//   values as the list ExtraArgs in the same order.\n\t\t\t// 5. Return the result of calling the [[Call]] internal method\n\t\t\t//   of target providing boundThis as the this value and\n\t\t\t//   providing args as the arguments.\n\n\t\t\t// equiv: target.call(this, ...boundArgs, ...args)\n\t\t\treturn target.apply(\n\t\t\t\tthat,\n\t\t\t\tarray_concat.call(args, array_slice.call(arguments))\n\t\t\t);\n\n\t\t}\n\n\t};\n\n\t// 15. If the [[Class]] internal property of Target is \"Function\", then\n\t//     a. Let L be the length property of Target minus the length of A.\n\t//     b. Set the length own property of F to either 0 or L, whichever is\n\t//       larger.\n\t// 16. Else set the length own property of F to 0.\n\n\tvar boundLength = max(0, target.length - args.length);\n\n\t// 17. Set the attributes of the length own property of F to the values\n\t//   specified in 15.3.5.1.\n\tvar boundArgs = [];\n\tfor (var i = 0; i < boundLength; i++) {\n\t\tarray_push.call(boundArgs, '$' + i);\n\t}\n\n\t// XXX Build a dynamic function with desired amount of arguments is the only\n\t// way to set the length property of a function.\n\t// In environments where Content Security Policies enabled (Chrome extensions,\n\t// for ex.) all use of eval or Function costructor throws an exception.\n\t// However in all of these environments Function.prototype.bind exists\n\t// and so this code will never be executed.\n\tbound = Function('binder', 'return function (' + boundArgs.join(',') + '){ return binder.apply(this, arguments); }')(binder);\n\n\tif (target.prototype) {\n\t\tEmpty.prototype = target.prototype;\n\t\tbound.prototype = new Empty();\n\t\t// Clean up dangling references.\n\t\tEmpty.prototype = null;\n\t}\n\n\t// TODO\n\t// 18. Set the [[Extensible]] internal property of F to true.\n\n\t// TODO\n\t// 19. Let thrower be the [[ThrowTypeError]] function Object (13.2.3).\n\t// 20. Call the [[DefineOwnProperty]] internal method of F with\n\t//   arguments \"caller\", PropertyDescriptor {[[Get]]: thrower, [[Set]]:\n\t//   thrower, [[Enumerable]]: false, [[Configurable]]: false}, and\n\t//   false.\n\t// 21. Call the [[DefineOwnProperty]] internal method of F with\n\t//   arguments \"arguments\", PropertyDescriptor {[[Get]]: thrower,\n\t//   [[Set]]: thrower, [[Enumerable]]: false, [[Configurable]]: false},\n\t//   and false.\n\n\t// TODO\n\t// NOTE Function objects created using Function.prototype.bind do not\n\t// have a prototype property or the [[Code]], [[FormalParameters]], and\n\t// [[Scope]] internal properties.\n\t// XXX can't delete prototype in pure-js.\n\n\t// 22. Return F.\n\treturn bound;\n});\n\n}\n\nif (!(\"freeze\"in Object\n)) {\n\n// Object.freeze\n/* global CreateMethodProperty */\n// 19.1.2.6. Object.freeze ( O )\nCreateMethodProperty(Object, 'freeze', function freeze(O) {\n\t// This feature cannot be implemented fully as a polyfill.\n\t// We choose to silently fail which allows \"securable\" code\n\t// to \"gracefully\" degrade to working but insecure code.\n\treturn O;\n});\n\n}\n\nif (!(\"getOwnPropertyDescriptor\"in Object&&\"function\"==typeof Object.getOwnPropertyDescriptor&&function(){try{return\"3\"===Object.getOwnPropertyDescriptor(\"13.7\",1).value}catch(t){return!1}}()\n)) {\n\n// Object.getOwnPropertyDescriptor\n/* global CreateMethodProperty, ToObject, ToPropertyKey, HasOwnProperty, Type */\n(function () {\n\tvar nativeGetOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\n\n\tvar supportsDOMDescriptors = (function () {\n\t\ttry {\n\t\t\treturn Object.defineProperty(document.createElement('div'), 'one', {\n\t\t\t\tget: function () {\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t}).one === 1;\n\t\t} catch (e) {\n\t\t\treturn false;\n\t\t}\n\t});\n\n\tvar toString = ({}).toString;\n\tvar split = ''.split;\n\n\t// 19.1.2.8 Object.getOwnPropertyDescriptor ( O, P )\n\tCreateMethodProperty(Object, 'getOwnPropertyDescriptor', function getOwnPropertyDescriptor(O, P) {\n\t\t// 1. Let obj be ? ToObject(O).\n\t\tvar obj = ToObject(O);\n\t\t// Polyfill.io fallback for non-array-like strings which exist in some ES3 user-agents (IE 8)\n\t\tobj = (Type(obj) === 'string' || obj instanceof String) && toString.call(O) == '[object String]' ? split.call(O, '') : Object(O);\n\n\t\t// 2. Let key be ? ToPropertyKey(P).\n\t\tvar key = ToPropertyKey(P);\n\n\t\t// 3. Let desc be ? obj.[[GetOwnProperty]](key).\n\t\t// 4. Return FromPropertyDescriptor(desc).\n\t\t// Polyfill.io Internet Explorer 8 natively supports property descriptors only on DOM objects.\n\t\t// We will fallback to the polyfill implementation if the native implementation throws an error.\n\t\tif (supportsDOMDescriptors) {\n\t\t\ttry {\n\t\t\t\treturn nativeGetOwnPropertyDescriptor(obj, key);\n\t\t\t// eslint-disable-next-line no-empty\n\t\t\t} catch (error) {}\n\t\t}\n\t\tif (HasOwnProperty(obj, key)) {\n\t\t\treturn {\n\t\t\t\tenumerable: true,\n\t\t\t\tconfigurable: true,\n\t\t\t\twritable: true,\n\t\t\t\tvalue: obj[key]\n\t\t\t};\n\t\t}\n\t});\n}());\n\n}\n\nif (!(\"getPrototypeOf\"in Object\n)) {\n\n// Object.getPrototypeOf\n/* global CreateMethodProperty */\n// Based on: https://github.com/es-shims/es5-shim/blob/master/es5-sham.js\n\n// https://github.com/es-shims/es5-shim/issues#issue/2\n// http://ejohn.org/blog/objectgetprototypeof/\n// recommended by fschaefer on github\n//\n// sure, and webreflection says ^_^\n// ... this will nerever possibly return null\n// ... Opera Mini breaks here with infinite loops\nCreateMethodProperty(Object, 'getPrototypeOf', function getPrototypeOf(object) {\n\tif (object !== Object(object)) {\n\t\tthrow new TypeError('Object.getPrototypeOf called on non-object');\n\t}\n\tvar proto = object.__proto__;\n\tif (proto || proto === null) {\n\t\treturn proto;\n\t} else if (typeof object.constructor == 'function' && object instanceof object.constructor) {\n\t\treturn object.constructor.prototype;\n\t} else if (object instanceof Object) {\n\t\treturn Object.prototype;\n\t} else {\n\t\t// Correctly return null for Objects created with `Object.create(null)`\n\t\t// (shammed or native) or `{ __proto__: null}`.  Also returns null for\n\t\t// cross-realm objects on browsers that lack `__proto__` support (like\n\t\t// IE <11), but that's the best we can do.\n\t\treturn null;\n\t}\n});\n\n}\n\nif (!(\"isExtensible\"in Object\n)) {\n\n// Object.isExtensible\n/* global CreateMethodProperty, Type */\n\n(function (nativeIsExtensible) {\n\t// 19.1.2.13 Object.isExtensible ( O )\n\tCreateMethodProperty(Object, 'isExtensible', function isExtensible(O) {\n\t\t// 1. If Type(O) is not Object, return false.\n\t\tif (Type(O) !== \"object\") {\n\t\t\treturn false;\n\t\t}\n\t\t// 2. Return ? IsExtensible(O).\n\t\treturn nativeIsExtensible ? nativeIsExtensible(O) : true;\n\t});\n}(Object.isExtensible));\n\n}\n\nif (!(\"keys\"in Object&&function(){return 2===Object.keys(arguments).length}(1,2)&&function(){try{return Object.keys(\"\"),!0}catch(t){return!1}}()\n)) {\n\n// Object.keys\n/* global CreateMethodProperty */\nCreateMethodProperty(Object, \"keys\", (function() {\n\t'use strict';\n\n\t// modified from https://github.com/es-shims/object-keys\n\n\tvar has = Object.prototype.hasOwnProperty;\n\tvar toStr = Object.prototype.toString;\n\tvar isEnumerable = Object.prototype.propertyIsEnumerable;\n\tvar hasDontEnumBug = !isEnumerable.call({ toString: null }, 'toString');\n\tvar hasPrototypeEnumBug = isEnumerable.call(function () { }, 'prototype');\n\tfunction hasProtoEnumBug() {\n\t\t// Object.create polyfill creates an enumerable __proto__\n\t\tvar createdObj;\n\t\ttry {\n\t\t\tcreatedObj = Object.create({});\n\t\t} catch (e) {\n\t\t\t// If this fails the polyfil isn't loaded yet, but will be.\n\t\t\t// Can't add it to depedencies because of it would create a circular depedency.\n\t\t\treturn true;\n\t\t}\n\n\t\treturn isEnumerable.call(createdObj, '__proto__')\n\t}\n\n\tvar dontEnums = [\n\t\t'toString',\n\t\t'toLocaleString',\n\t\t'valueOf',\n\t\t'hasOwnProperty',\n\t\t'isPrototypeOf',\n\t\t'propertyIsEnumerable',\n\t\t'constructor'\n\t];\n\tvar equalsConstructorPrototype = function (o) {\n\t\tvar ctor = o.constructor;\n\t\treturn ctor && ctor.prototype === o;\n\t};\n\tvar excludedKeys = {\n\t\t$console: true,\n\t\t$external: true,\n\t\t$frame: true,\n\t\t$frameElement: true,\n\t\t$frames: true,\n\t\t$innerHeight: true,\n\t\t$innerWidth: true,\n\t\t$outerHeight: true,\n\t\t$outerWidth: true,\n\t\t$pageXOffset: true,\n\t\t$pageYOffset: true,\n\t\t$parent: true,\n\t\t$scrollLeft: true,\n\t\t$scrollTop: true,\n\t\t$scrollX: true,\n\t\t$scrollY: true,\n\t\t$self: true,\n\t\t$webkitIndexedDB: true,\n\t\t$webkitStorageInfo: true,\n\t\t$window: true\n\t};\n\tvar hasAutomationEqualityBug = (function () {\n\t\tif (typeof window === 'undefined') { return false; }\n\t\tfor (var k in window) {\n\t\t\ttry {\n\t\t\t\tif (!excludedKeys['$' + k] && has.call(window, k) && window[k] !== null && typeof window[k] === 'object') {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tequalsConstructorPrototype(window[k]);\n\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}());\n\tvar equalsConstructorPrototypeIfNotBuggy = function (o) {\n\t\tif (typeof window === 'undefined' || !hasAutomationEqualityBug) {\n\t\t\treturn equalsConstructorPrototype(o);\n\t\t}\n\t\ttry {\n\t\t\treturn equalsConstructorPrototype(o);\n\t\t} catch (e) {\n\t\t\treturn false;\n\t\t}\n\t};\n\n\tfunction isArgumentsObject(value) {\n\t\tvar str = toStr.call(value);\n\t\tvar isArgs = str === '[object Arguments]';\n\t\tif (!isArgs) {\n\t\t\tisArgs = str !== '[object Array]' &&\n\t\t\t\tvalue !== null &&\n\t\t\t\ttypeof value === 'object' &&\n\t\t\t\ttypeof value.length === 'number' &&\n\t\t\t\tvalue.length >= 0 &&\n\t\t\t\ttoStr.call(value.callee) === '[object Function]';\n\t\t}\n\t\treturn isArgs;\n\t}\n\n\treturn function keys(object) {\n\t\tvar isFunction = toStr.call(object) === '[object Function]';\n\t\tvar isArguments = isArgumentsObject(object);\n\t\tvar isString = toStr.call(object) === '[object String]';\n\t\tvar theKeys = [];\n\n\t\tif (object === undefined || object === null) {\n\t\t\tthrow new TypeError('Cannot convert undefined or null to object');\n\t\t}\n\n\t\tvar skipPrototype = hasPrototypeEnumBug && isFunction;\n\t\tif (isString && object.length > 0 && !has.call(object, 0)) {\n\t\t\tfor (var i = 0; i < object.length; ++i) {\n\t\t\t\ttheKeys.push(String(i));\n\t\t\t}\n\t\t}\n\n\t\tif (isArguments && object.length > 0) {\n\t\t\tfor (var j = 0; j < object.length; ++j) {\n\t\t\t\ttheKeys.push(String(j));\n\t\t\t}\n\t\t} else {\n\t\t\tfor (var name in object) {\n\t\t\t\tif (!(hasProtoEnumBug() && name === '__proto__') && !(skipPrototype && name === 'prototype') && has.call(object, name)) {\n\t\t\t\t\ttheKeys.push(String(name));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (hasDontEnumBug) {\n\t\t\tvar skipConstructor = equalsConstructorPrototypeIfNotBuggy(object);\n\n\t\t\tfor (var k = 0; k < dontEnums.length; ++k) {\n\t\t\t\tif (!(skipConstructor && dontEnums[k] === 'constructor') && has.call(object, dontEnums[k])) {\n\t\t\t\t\ttheKeys.push(dontEnums[k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn theKeys;\n\t};\n}()));\n\n}\n\nif (!(\"assign\"in Object\n)) {\n\n// Object.assign\n/* global CreateMethodProperty, Get, ToObject */\n// 19.1.2.1 Object.assign ( target, ...sources )\nCreateMethodProperty(Object, 'assign', function assign(target, source) { // eslint-disable-line no-unused-vars\n\t// 1. Let to be ? ToObject(target).\n\tvar to = ToObject(target);\n\n\t// 2. If only one argument was passed, return to.\n\tif (arguments.length === 1) {\n\t\treturn to;\n\t}\n\n\t// 3. Let sources be the List of argument values starting with the second argument\n\tvar sources = Array.prototype.slice.call(arguments, 1);\n\n\t// 4. For each element nextSource of sources, in ascending index order, do\n\tvar index1;\n\tvar index2;\n\tvar keys;\n\tvar from;\n\tfor (index1 = 0; index1 < sources.length; index1++) {\n\t\tvar nextSource = sources[index1];\n\t\t// a. If nextSource is undefined or null, let keys be a new empty List.\n\t\tif (nextSource === undefined || nextSource === null) {\n\t\t\tkeys = [];\n\t\t\t// b. Else,\n\t\t} else {\n\t\t\t// Polyfill.io - In order to get strings in ES3 and old V8 working correctly we need to split them into an array ourselves.\n\t\t\t// i. Let from be ! ToObject(nextSource).\n\t\t\tfrom = Object.prototype.toString.call(nextSource) === '[object String]' ? String(nextSource).split('') : ToObject(nextSource);\n\t\t\t// ii. Let keys be ? from.[[OwnPropertyKeys]]().\n\t\t\t/*\n\t\t\t\tThis step in our polyfill is not complying with the specification.\n\t\t\t\t[[OwnPropertyKeys]] is meant to return ALL keys, including non-enumerable and symbols.\n\t\t\t\tTODO: When we have Reflect.ownKeys, use that instead as it is the userland equivalent of [[OwnPropertyKeys]].\n\t\t\t*/\n\t\t\tkeys = Object.keys(from);\n\t\t}\n\n\t\t// c. For each element nextKey of keys in List order, do\n\t\tfor (index2 = 0; index2 < keys.length; index2++) {\n\t\t\tvar nextKey = keys[index2];\n\t\t\tvar enumerable;\n\t\t\ttry {\n\t\t\t\t// i. Let desc be ? from.[[GetOwnProperty]](nextKey).\n\t\t\t\tvar desc = Object.getOwnPropertyDescriptor(from, nextKey);\n\t\t\t\t// ii. If desc is not undefined and desc.[[Enumerable]] is true, then\n\t\t\t\tenumerable = desc !== undefined && desc.enumerable === true;\n\t\t\t} catch (e) {\n\t\t\t\t// Polyfill.io - We use Object.prototype.propertyIsEnumerable as a fallback\n\t\t\t\t// because `Object.getOwnPropertyDescriptor(window.location, 'hash')` causes Internet Explorer 11 to crash.\n\t\t\t\tenumerable = Object.prototype.propertyIsEnumerable.call(from, nextKey);\n\t\t\t}\n\t\t\tif (enumerable) {\n\t\t\t\t// 1. Let propValue be ? Get(from, nextKey).\n\t\t\t\tvar propValue = Get(from, nextKey);\n\t\t\t\t// 2. Perform ? Set(to, nextKey, propValue, true).\n\t\t\t\tto[nextKey] = propValue;\n\t\t\t}\n\t\t}\n\t}\n\t// 5. Return to.\n\treturn to;\n});\n\n}\n\nif (!(\"defineProperties\"in Object\n)) {\n\n// Object.defineProperties\n/* global CreateMethodProperty, Get, ToObject, Type */\n// 19.1.2.3. Object.defineProperties ( O, Properties )\nCreateMethodProperty(Object, 'defineProperties', function defineProperties(O, Properties) {\n\t// 1. If Type(O) is not Object, throw a TypeError exception.\n\tif (Type(O) !== 'object') {\n\t\tthrow new TypeError('Object.defineProperties called on non-object');\n\t}\n\t// 2. Let props be ? ToObject(Properties).\n\tvar props = ToObject(Properties);\n\t// 3. Let keys be ? props.[[OwnPropertyKeys]]().\n\t/*\n\t\tPolyfill.io - This step in our polyfill is not complying with the specification.\n\t\t[[OwnPropertyKeys]] is meant to return ALL keys, including non-enumerable and symbols.\n\t\tTODO: When we have Reflect.ownKeys, use that instead as it is the userland equivalent of [[OwnPropertyKeys]].\n\t*/\n\tvar keys = Object.keys(props);\n\t// 4. Let descriptors be a new empty List.\n\tvar descriptors = [];\n\t// 5. For each element nextKey of keys in List order, do\n\tfor (var i = 0; i < keys.length; i++) {\n\t\tvar nextKey = keys[i];\n\t\t// a. Let propDesc be ? props.[[GetOwnProperty]](nextKey).\n\t\tvar propDesc = Object.getOwnPropertyDescriptor(props, nextKey);\n\t\t// b. If propDesc is not undefined and propDesc.[[Enumerable]] is true, then\n\t\tif (propDesc !== undefined && propDesc.enumerable) {\n\t\t\t// i. Let descObj be ? Get(props, nextKey).\n\t\t\tvar descObj = Get(props, nextKey);\n\t\t\t// ii. Let desc be ? ToPropertyDescriptor(descObj).\n\t\t\t// Polyfill.io - We skip this step because Object.defineProperty deals with it.\n\t\t\t// TODO: Implement this step?\n\t\t\tvar desc = descObj;\n\t\t\t// iii. Append the pair (a two element List) consisting of nextKey and desc to the end of descriptors.\n\t\t\tdescriptors.push([nextKey, desc]);\n\t\t}\n\t}\n\t// 6. For each pair from descriptors in list order, do\n\tfor (var j = 0; j < descriptors.length; j++){\n\t\t// a. Let P be the first element of pair.\n\t\tvar P = descriptors[j][0];\n\t\t// b. Let desc be the second element of pair.\n\t\tdesc = descriptors[j][1];\n\t\t// c. Perform ? DefinePropertyOrThrow(O, P, desc).\n\t\tObject.defineProperty(O, P, desc);\n\t}\n\t// 7. Return O.\n\treturn O;\n});\n\n}\n\nif (!(\"create\"in Object\n)) {\n\n// Object.create\n/* global CreateMethodProperty, Type */\n(function () {\n\tvar supportsProto = !({ __proto__: null } instanceof Object);\n\tif (supportsProto) {\n\t\tvar createEmpty = function () {\n\t\t\treturn {\n\t\t\t\t__proto__: null\n\t\t\t};\n\t\t};\n\t} else {\n\t\t// Taken from https://github.com/es-shims/es5-shim/blob/a265a136d6220146cfbb09026c2de1fa42e220ec/es5-sham.js#L247\n\t\t// In old IE __proto__ can't be used to manually set `null`, nor does\n\t\t// any other method exist to make an object that inherits from nothing,\n\t\t// aside from Object.prototype itself. Instead, create a new global\n\t\t// object and *steal* its Object.prototype and strip it bare. This is\n\t\t// used as the prototype to create nullary objects.\n\t\tcreateEmpty = function () {\n\t\t\t// Determine which approach to use\n\t\t\t// see https://github.com/es-shims/es5-shim/issues/150\n\t\t\tvar iframe = document.createElement('iframe');\n\t\t\tiframe.style.display = 'none';\n\t\t\tvar parent = document.body || document.documentElement;\n\t\t\tparent.appendChild(iframe);\n\t\t\tiframe.src = 'javascript:';\n\t\t\tvar empty = iframe.contentWindow.Object.prototype;\n\t\t\tparent.removeChild(iframe);\n\t\t\tiframe = null;\n\t\t\tdelete empty.constructor;\n\t\t\tdelete empty.hasOwnProperty;\n\t\t\tdelete empty.propertyIsEnumerable;\n\t\t\tdelete empty.isPrototypeOf;\n\t\t\tdelete empty.toLocaleString;\n\t\t\tdelete empty.toString;\n\t\t\tdelete empty.valueOf;\n\t\t\tvar Empty = function Empty() {};\n\t\t\tEmpty.prototype = empty;\n\t\t\t// short-circuit future calls\n\t\t\tcreateEmpty = function () {\n\t\t\t\treturn new Empty();\n\t\t\t};\n\t\t\treturn new Empty();\n\t\t};\n\t}\n\n\tfunction T() {}\n\n\tCreateMethodProperty(Object, 'create', function create(O, properties) {\n\t\t// 1. If Type(O) is neither Object nor Null, throw a TypeError exception.\n\t\tif (Type(O) !== 'object' && Type(O) !== 'null') {\n\t\t\tthrow new TypeError('Object prototype may only be an Object or null');\n\t\t}\n\t\tif (Type(O) === 'null') {\n\t\t\tvar obj = createEmpty();\n\t\t} else {\n\t\t\t// 2. Let obj be ObjectCreate(O).\n\t\t\tT.prototype = O;\n\t\t\tobj = new T();\n\t\t\tobj.__proto__ = O;\n\n\n\t\t\tobj.constructor.prototype = O;\n\t\t\tobj.__proto__ = O;\n\t\t}\n\n\t\t// 3. If Properties is not undefined, then\n\t\tif (1 in arguments) {\n\t\t\t// a. Return ? ObjectDefineProperties(obj, Properties).\n\t\t\treturn Object.defineProperties(obj, properties);\n\t\t}\n\n\t\treturn obj;\n\t});\n}());\n\n}\n\n\n// _ESAbstract.OrdinaryCreateFromConstructor\n/* global GetPrototypeFromConstructor */\n// 9.1.13. OrdinaryCreateFromConstructor ( constructor, intrinsicDefaultProto [ , internalSlotsList ] )\nfunction OrdinaryCreateFromConstructor(constructor, intrinsicDefaultProto) { // eslint-disable-line no-unused-vars\n\tvar internalSlotsList = arguments[2] || {};\n\t// 1. Assert: intrinsicDefaultProto is a String value that is this specification's name of an intrinsic object.\n\t// The corresponding object must be an intrinsic that is intended to be used as the[[Prototype]] value of an object.\n\n\t// 2. Let proto be ? GetPrototypeFromConstructor(constructor, intrinsicDefaultProto).\n\tvar proto = GetPrototypeFromConstructor(constructor, intrinsicDefaultProto);\n\n\t// 3. Return ObjectCreate(proto, internalSlotsList).\n\t// Polyfill.io - We do not pass internalSlotsList to Object.create because Object.create does not use the default ordinary object definitions specified in 9.1.\n\tvar obj = Object.create(proto);\n\tfor (var name in internalSlotsList) {\n\t\tif (Object.prototype.hasOwnProperty.call(internalSlotsList, name)) {\n\t\t\tObject.defineProperty(obj, name, {\n\t\t\t\tconfigurable: true,\n\t\t\t\tenumerable: false,\n\t\t\t\twritable: true,\n\t\t\t\tvalue: internalSlotsList[name]\n\t\t\t});\n\t\t}\n\t}\n\treturn obj;\n}\n\n// _ESAbstract.Construct\n/* global IsConstructor, OrdinaryCreateFromConstructor, Call */\n// 7.3.13. Construct ( F [ , argumentsList [ , newTarget ]] )\nfunction Construct(F /* [ , argumentsList [ , newTarget ]] */) { // eslint-disable-line no-unused-vars\n\t// 1. If newTarget is not present, set newTarget to F.\n\tvar newTarget = arguments.length > 2 ? arguments[2] : F;\n\n\t// 2. If argumentsList is not present, set argumentsList to a new empty List.\n\tvar argumentsList = arguments.length > 1 ? arguments[1] : [];\n\n\t// 3. Assert: IsConstructor(F) is true.\n\tif (!IsConstructor(F)) {\n\t\tthrow new TypeError('F must be a constructor.');\n\t}\n\n\t// 4. Assert: IsConstructor(newTarget) is true.\n\tif (!IsConstructor(newTarget)) {\n\t\tthrow new TypeError('newTarget must be a constructor.');\n\t}\n\n\t// 5. Return ? F.[[Construct]](argumentsList, newTarget).\n\t// Polyfill.io - If newTarget is the same as F, it is equivalent to new F(...argumentsList).\n\tif (newTarget === F) {\n\t\treturn new (Function.prototype.bind.apply(F, [null].concat(argumentsList)))();\n\t} else {\n\t\t// Polyfill.io - This is mimicking section 9.2.2 step 5.a.\n\t\tvar obj = OrdinaryCreateFromConstructor(newTarget, Object.prototype);\n\t\treturn Call(F, obj, argumentsList);\n\t}\n}\n\n// _ESAbstract.ArraySpeciesCreate\n/* global IsArray, ArrayCreate, Get, Type, IsConstructor, Construct */\n// 9.4.2.3. ArraySpeciesCreate ( originalArray, length )\nfunction ArraySpeciesCreate(originalArray, length) { // eslint-disable-line no-unused-vars\n\t// 1. Assert: length is an integer Number ≥ 0.\n\t// 2. If length is -0, set length to +0.\n\tif (length === 0 && 1/length === -Infinity) {\n\t\tlength = 0;\n\t}\n\n\t// 3. Let isArray be ? IsArray(originalArray).\n\tvar isArray = IsArray(originalArray);\n\n\t// 4. If isArray is false, return ? ArrayCreate(length).\n\tif (isArray === false) {\n\t\treturn ArrayCreate(length);\n\t}\n\n\t// 5. Let C be ? Get(originalArray, \"constructor\").\n\tvar C = Get(originalArray, 'constructor');\n\n\t// Polyfill.io - We skip this section as not sure how to make a cross-realm normal Array, a same-realm Array.\n\t// 6. If IsConstructor(C) is true, then\n\t// if (IsConstructor(C)) {\n\t\t// a. Let thisRealm be the current Realm Record.\n\t\t// b. Let realmC be ? GetFunctionRealm(C).\n\t\t// c. If thisRealm and realmC are not the same Realm Record, then\n\t\t\t// i. If SameValue(C, realmC.[[Intrinsics]].[[%Array%]]) is true, set C to undefined.\n\t// }\n\t// 7. If Type(C) is Object, then\n\tif (Type(C) === 'object') {\n\t\t// a. Set C to ? Get(C, @@species).\n\t\tC = 'Symbol' in self && 'species' in self.Symbol ? Get(C, self.Symbol.species) : undefined;\n\t\t// b. If C is null, set C to undefined.\n\t\tif (C === null) {\n\t\t\tC = undefined;\n\t\t}\n\t}\n\t// 8. If C is undefined, return ? ArrayCreate(length).\n\tif (C === undefined) {\n\t\treturn ArrayCreate(length);\n\t}\n\t// 9. If IsConstructor(C) is false, throw a TypeError exception.\n\tif (!IsConstructor(C)) {\n\t\tthrow new TypeError('C must be a constructor');\n\t}\n\t// 10. Return ? Construct(C, « length »).\n\treturn Construct(C, [length]);\n}\nif (!(\"filter\"in Array.prototype\n)) {\n\n// Array.prototype.filter\n/* global CreateMethodProperty, ToObject, ToLength, Get, IsCallable, ArraySpeciesCreate, ToString, HasProperty, ToBoolean, Call, CreateDataPropertyOrThrow */\n// 22.1.3.7. Array.prototype.filter ( callbackfn [ , thisArg ] )\nCreateMethodProperty(Array.prototype, 'filter', function filter(callbackfn /* [ , thisArg ] */) {\n\t// 1. Let O be ? ToObject(this value).\n\tvar O = ToObject(this);\n\t// 2. Let len be ? ToLength(? Get(O, \"length\")).\n\tvar len = ToLength(Get(O, \"length\"));\n\t// 3. If IsCallable(callbackfn) is false, throw a TypeError exception.\n\tif (IsCallable(callbackfn) === false) {\n\t\tthrow new TypeError(callbackfn + ' is not a function');\n\t}\n\t// 4. If thisArg is present, let T be thisArg; else let T be undefined.\n\tvar T = arguments.length > 1 ? arguments[1] : undefined;\n\t// 5. Let A be ? ArraySpeciesCreate(O, 0).\n\tvar A = ArraySpeciesCreate(O, 0);\n\t// 6. Let k be 0.\n\tvar k = 0;\n\t// 7. Let to be 0.\n\tvar to = 0;\n\t// 8. Repeat, while k < len\n\twhile (k < len) {\n\t\t// a. Let Pk be ! ToString(k).\n\t\tvar Pk = ToString(k);\n\t\t// b. Let kPresent be ? HasProperty(O, Pk).\n\t\tvar kPresent = HasProperty(O, Pk);\n\t\t// c. If kPresent is true, then\n\t\tif (kPresent) {\n\t\t\t// i. Let kValue be ? Get(O, Pk).\n\t\t\tvar kValue = Get(O, Pk);\n\t\t\t// ii. Let selected be ToBoolean(? Call(callbackfn, T, « kValue, k, O »)).\n\t\t\tvar selected = ToBoolean(Call(callbackfn, T, [kValue, k, O]));\n\t\t\t// iii. If selected is true, then\n\t\t\tif (selected) {\n\t\t\t\t// 1. Perform ? CreateDataPropertyOrThrow(A, ! ToString(to), kValue)\n\t\t\t\tCreateDataPropertyOrThrow(A, ToString(to), kValue);\n\t\t\t\t// 2. Increase to by 1.\n\t\t\t\tto = to + 1;\n\t\t\t}\n\n\t\t}\n\t\t// d. Increase k by 1.\n\t\tk = k + 1;\n\t}\n\t// 9. Return A.\n\treturn A;\n});\n\n}\n\nif (!(\"map\"in Array.prototype\n)) {\n\n// Array.prototype.map\n/* global ArraySpeciesCreate, Call, CreateDataPropertyOrThrow, CreateMethodProperty, Get, HasProperty, IsCallable, ToLength, ToObject, ToString */\n// 22.1.3.16. Array.prototype.map ( callbackfn [ , thisArg ] )\nCreateMethodProperty(Array.prototype, 'map', function map(callbackfn /* [ , thisArg ] */) {\n\t// 1. Let O be ? ToObject(this value).\n\tvar O = ToObject(this);\n\t// 2. Let len be ? ToLength(? Get(O, \"length\")).\n\tvar len = ToLength(Get(O, \"length\"));\n\t// 3. If IsCallable(callbackfn) is false, throw a TypeError exception.\n\tif (IsCallable(callbackfn) === false) {\n\t\tthrow new TypeError(callbackfn + ' is not a function');\n\t}\n\t// 4. If thisArg is present, let T be thisArg; else let T be undefined.\n\tvar T = arguments.length > 1 ? arguments[1] : undefined;\n\t// 5. Let A be ? ArraySpeciesCreate(O, len).\n\tvar A = ArraySpeciesCreate(O, len);\n\t// 6. Let k be 0.\n\tvar k = 0;\n\t// 7. Repeat, while k < len\n\twhile (k < len) {\n\t\t// a. Let Pk be ! ToString(k).\n\t\tvar Pk = ToString(k);\n\t\t// b. Let kPresent be ? HasProperty(O, Pk).\n\t\tvar kPresent = HasProperty(O, Pk);\n\t\t// c. If kPresent is true, then\n\t\tif (kPresent) {\n\t\t\t// i. Let kValue be ? Get(O, Pk).\n\t\t\tvar kValue = Get(O, Pk);\n\t\t\t// ii. Let mappedValue be ? Call(callbackfn, T, « kValue, k, O »).\n\t\t\tvar mappedValue = Call(callbackfn, T, [kValue, k, O]);\n\t\t\t// iii. Perform ? CreateDataPropertyOrThrow(A, Pk, mappedValue).\n\t\t\tCreateDataPropertyOrThrow(A, Pk, mappedValue);\n\t\t}\n\t\t// d. Increase k by 1.\n\t\tk = k + 1;\n\t}\n\t// 8. Return A.\n\treturn A;\n});\n\n}\n\nif (!(\"getOwnPropertyNames\"in Object&&function(){try{return Object.getOwnPropertyNames(1),!0}catch(t){return!1}}()\n)) {\n\n// Object.getOwnPropertyNames\n/* global CreateMethodProperty, ToObject */\n(function() {\n\tvar toString = {}.toString;\n\tvar split = \"\".split;\n\tvar concat = [].concat;\n\tvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\tvar nativeGetOwnPropertyNames = Object.getOwnPropertyNames || Object.keys;\n\tvar cachedWindowNames =\n\t\ttypeof self === \"object\" ? nativeGetOwnPropertyNames(self) : [];\n\n\t// 19.1.2.10 Object.getOwnPropertyNames ( O )\n\tCreateMethodProperty(\n\t\tObject,\n\t\t\"getOwnPropertyNames\",\n\t\tfunction getOwnPropertyNames(O) {\n\t\t\tvar object = ToObject(O);\n\n\t\t\tif (toString.call(object) === \"[object Window]\") {\n\t\t\t\ttry {\n\t\t\t\t\treturn nativeGetOwnPropertyNames(object);\n\t\t\t\t} catch (e) {\n\t\t\t\t\t// IE bug where layout engine calls userland Object.getOwnPropertyNames for cross-domain `window` objects\n\t\t\t\t\treturn concat.call([], cachedWindowNames);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Polyfill.io fallback for non-array-like strings which exist in some ES3 user-agents (IE 8)\n\t\t\tobject =\n\t\t\t\ttoString.call(object) == \"[object String]\"\n\t\t\t\t\t? split.call(object, \"\")\n\t\t\t\t\t: Object(object);\n\n\t\t\tvar result = nativeGetOwnPropertyNames(object);\n\t\t\tvar extraNonEnumerableKeys = [\"length\", \"prototype\"];\n\t\t\tfor (var i = 0; i < extraNonEnumerableKeys.length; i++) {\n\t\t\t\tvar key = extraNonEnumerableKeys[i];\n\t\t\t\tif (hasOwnProperty.call(object, key) && !result.includes(key)) {\n\t\t\t\t\tresult.push(key);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (result.includes(\"__proto__\")) {\n\t\t\t\tvar index = result.indexOf(\"__proto__\");\n\t\t\t\tresult.splice(index, 1);\n\t\t\t}\n\n\t\t\treturn result;\n\t\t}\n\t);\n})();\n\n}\n\nif (!(\"Symbol\"in self&&0===self.Symbol.length\n)) {\n\n// Symbol\n// A modification of https://github.com/WebReflection/get-own-property-symbols\n// (C) Andrea Giammarchi - MIT Licensed\n\n/* global Type */\n(function (Object,  GOPS, global) {\n\t'use strict'; //so that ({}).toString.call(null) returns the correct [object Null] rather than [object Window]\n\n\tvar supportsGetters = (function () {\n\t\t// supports getters\n\t\ttry {\n\t\t\tvar a = {};\n\t\t\tObject.defineProperty(a, \"t\", {\n\t\t\t\tconfigurable: true,\n\t\t\t\tenumerable: false,\n\t\t\t\tget: function () {\n\t\t\t\t\treturn true;\n\t\t\t\t},\n\t\t\t\tset: undefined\n\t\t\t});\n\t\t\treturn !!a.t;\n\t\t} catch (e) {\n\t\t\treturn false;\n\t\t}\n\t}());\n\n\tvar\tsetDescriptor;\n\tvar id = 0;\n\tvar random = '' + Math.random();\n\tvar prefix = '__\\x01symbol:';\n\tvar prefixLength = prefix.length;\n\tvar internalSymbol = '__\\x01symbol@@' + random;\n\tvar emptySymbolLookup = {};\n\tvar DP = 'defineProperty';\n\tvar DPies = 'defineProperties';\n\tvar GOPN = 'getOwnPropertyNames';\n\tvar GOPD = 'getOwnPropertyDescriptor';\n\tvar PIE = 'propertyIsEnumerable';\n\tvar ObjectProto = Object.prototype;\n\tvar hOP = ObjectProto.hasOwnProperty;\n\tvar pIE = ObjectProto[PIE];\n\tvar toString = ObjectProto.toString;\n\tvar concat = Array.prototype.concat;\n\tvar cachedWindowNames = Object.getOwnPropertyNames ? Object.getOwnPropertyNames(self) : [];\n\tvar nGOPN = Object[GOPN];\n\tvar gOPN = function getOwnPropertyNames (obj) {\n\t\tif (toString.call(obj) === '[object Window]') {\n\t\t\ttry {\n\t\t\t\treturn nGOPN(obj);\n\t\t\t} catch (e) {\n\t\t\t\t// IE bug where layout engine calls userland gOPN for cross-domain `window` objects\n\t\t\t\treturn concat.call([], cachedWindowNames);\n\t\t\t}\n\t\t}\n\t\treturn nGOPN(obj);\n\t};\n\tvar gOPD = Object[GOPD];\n\tvar objectCreate = Object.create;\n\tvar objectKeys = Object.keys;\n\tvar freeze = Object.freeze || Object;\n\tvar objectDefineProperty = Object[DP];\n\tvar $defineProperties = Object[DPies];\n\tvar descriptor = gOPD(Object, GOPN);\n\tvar addInternalIfNeeded = function (o, uid, enumerable) {\n\t\tif (!hOP.call(o, internalSymbol)) {\n\t\t\ttry {\n\t\t\t\tobjectDefineProperty(o, internalSymbol, {\n\t\t\t\t\tenumerable: false,\n\t\t\t\t\tconfigurable: false,\n\t\t\t\t\twritable: false,\n\t\t\t\t\tvalue: {}\n\t\t\t\t});\n\t\t\t} catch (e) {\n\t\t\t\to[internalSymbol] = {};\n\t\t\t}\n\t\t}\n\t\to[internalSymbol]['@@' + uid] = enumerable;\n\t};\n\tvar createWithSymbols = function (proto, descriptors) {\n\t\tvar self = objectCreate(proto);\n\t\tgOPN(descriptors).forEach(function (key) {\n\t\t\tif (propertyIsEnumerable.call(descriptors, key)) {\n\t\t\t\t$defineProperty(self, key, descriptors[key]);\n\t\t\t}\n\t\t});\n\t\treturn self;\n\t};\n\tvar copyAsNonEnumerable = function (descriptor) {\n\t\tvar newDescriptor = objectCreate(descriptor);\n\t\tnewDescriptor.enumerable = false;\n\t\treturn newDescriptor;\n\t};\n\tvar get = function get(){};\n\tvar onlyNonSymbols = function (name) {\n\t\treturn name != internalSymbol &&\n\t\t\t!hOP.call(source, name);\n\t};\n\tvar onlySymbols = function (name) {\n\t\treturn name != internalSymbol &&\n\t\t\thOP.call(source, name);\n\t};\n\tvar propertyIsEnumerable = function propertyIsEnumerable(key) {\n\t\tvar uid = '' + key;\n\t\treturn onlySymbols(uid) ? (\n\t\t\thOP.call(this, uid) &&\n\t\t\tthis[internalSymbol] && this[internalSymbol]['@@' + uid]\n\t\t) : pIE.call(this, key);\n\t};\n\tvar setAndGetSymbol = function (uid) {\n\t\tvar descriptor = {\n\t\t\tenumerable: false,\n\t\t\tconfigurable: true,\n\t\t\tget: get,\n\t\t\tset: function (value) {\n\t\t\tsetDescriptor(this, uid, {\n\t\t\t\tenumerable: false,\n\t\t\t\tconfigurable: true,\n\t\t\t\twritable: true,\n\t\t\t\tvalue: value\n\t\t\t});\n\t\t\taddInternalIfNeeded(this, uid, true);\n\t\t\t}\n\t\t};\n\t\ttry {\n\t\t\tobjectDefineProperty(ObjectProto, uid, descriptor);\n\t\t} catch (e) {\n\t\t\tObjectProto[uid] = descriptor.value;\n\t\t}\n\t\tsource[uid] = objectDefineProperty(\n\t\t\tObject(uid),\n\t\t\t'constructor',\n\t\t\tsourceConstructor\n\t\t);\n\t\tvar description = gOPD(Symbol.prototype, 'description');\n\t\tif (description) {\n\t\t\tobjectDefineProperty(\n\t\t\t\tsource[uid],\n\t\t\t\t'description',\n\t\t\t\tdescription\n\t\t\t);\n\t\t}\n\t\treturn freeze(source[uid]);\n\t};\n\n\tvar symbolDescription = function (s) {\n\t\tvar sym = thisSymbolValue(s);\n\n\t\t// 3. Return sym.[[Description]].\n\t\tif (supportsInferredNames) {\n\t\t\tvar name = getInferredName(sym);\n\t\t\tif (name !== \"\") {\n\t\t\t\treturn name.slice(1, -1); // name.slice('['.length, -']'.length);\n\t\t\t}\n\t\t}\n\n\t\tif (emptySymbolLookup[sym] !== undefined) {\n\t\t\treturn emptySymbolLookup[sym];\n\t\t}\n\n\t\tvar string = sym.toString();\n\t\tvar randomStartIndex = string.lastIndexOf(\"0.\");\n\t\tstring = string.slice(10, randomStartIndex);\n\n\t\tif (string === \"\") {\n\t\t\treturn undefined;\n\t\t}\n\t\treturn string;\n\t};\n\n\tvar Symbol = function Symbol() {\n\t\tvar description = arguments[0];\n\t\tif (this instanceof Symbol) {\n\t\t\tthrow new TypeError('Symbol is not a constructor');\n\t\t}\n\n\t\tvar uid = prefix.concat(description || '', random, ++id);\n\n\t\tif (description !== undefined && (description === null || isNaN(description) || String(description) === \"\")) {\n\t\t\temptySymbolLookup[uid] = String(description);\n\t\t}\n\n\t\tvar that = setAndGetSymbol(uid);\n\n\t\tif (!supportsGetters) {\n\t\t\tObject.defineProperty(that, \"description\", {\n\t\t\t\tconfigurable: true,\n\t\t\t\tenumerable: false,\n\t\t\t\tvalue: symbolDescription(that)\n\t\t\t});\n\t\t}\n\n\t\treturn that;\n\t};\n\n\tvar source = objectCreate(null);\n\tvar sourceConstructor = {value: Symbol};\n\tvar sourceMap = function (uid) {\n\t\treturn source[uid];\n\t\t};\n\tvar $defineProperty = function defineProperty(o, key, descriptor) {\n\t\tvar uid = '' + key;\n\t\tif (onlySymbols(uid)) {\n\t\t\tsetDescriptor(o, uid, descriptor.enumerable ?\n\t\t\t\tcopyAsNonEnumerable(descriptor) : descriptor);\n\t\t\taddInternalIfNeeded(o, uid, !!descriptor.enumerable);\n\t\t} else {\n\t\t\tobjectDefineProperty(o, key, descriptor);\n\t\t}\n\t\treturn o;\n\t};\n\n\tvar onlyInternalSymbols = function (obj) {\n\t\treturn function (name) {\n\t\t\treturn hOP.call(obj, internalSymbol) && hOP.call(obj[internalSymbol], '@@' + name);\n\t\t};\n\t};\n\tvar $getOwnPropertySymbols = function getOwnPropertySymbols(o) {\n\t\treturn gOPN(o).filter(o === ObjectProto ? onlyInternalSymbols(o) : onlySymbols).map(sourceMap);\n\t\t}\n\t;\n\n\tdescriptor.value = $defineProperty;\n\tobjectDefineProperty(Object, DP, descriptor);\n\n\tdescriptor.value = $getOwnPropertySymbols;\n\tobjectDefineProperty(Object, GOPS, descriptor);\n\n\tdescriptor.value = function getOwnPropertyNames(o) {\n\t\treturn gOPN(o).filter(onlyNonSymbols);\n\t};\n\tobjectDefineProperty(Object, GOPN, descriptor);\n\n\tdescriptor.value = function defineProperties(o, descriptors) {\n\t\tvar symbols = $getOwnPropertySymbols(descriptors);\n\t\tif (symbols.length) {\n\t\tobjectKeys(descriptors).concat(symbols).forEach(function (uid) {\n\t\t\tif (propertyIsEnumerable.call(descriptors, uid)) {\n\t\t\t$defineProperty(o, uid, descriptors[uid]);\n\t\t\t}\n\t\t});\n\t\t} else {\n\t\t$defineProperties(o, descriptors);\n\t\t}\n\t\treturn o;\n\t};\n\tobjectDefineProperty(Object, DPies, descriptor);\n\n\tdescriptor.value = propertyIsEnumerable;\n\tobjectDefineProperty(ObjectProto, PIE, descriptor);\n\n\tdescriptor.value = Symbol;\n\tobjectDefineProperty(global, 'Symbol', descriptor);\n\n\t// defining `Symbol.for(key)`\n\tdescriptor.value = function (key) {\n\t\tvar uid = prefix.concat(prefix, key, random);\n\t\treturn uid in ObjectProto ? source[uid] : setAndGetSymbol(uid);\n\t};\n\tobjectDefineProperty(Symbol, 'for', descriptor);\n\n\t// defining `Symbol.keyFor(symbol)`\n\tdescriptor.value = function (symbol) {\n\t\tif (onlyNonSymbols(symbol))\n\t\tthrow new TypeError(symbol + ' is not a symbol');\n\t\treturn hOP.call(source, symbol) ?\n\t\tsymbol.slice(prefixLength * 2, -random.length) :\n\t\tvoid 0\n\t\t;\n\t};\n\tobjectDefineProperty(Symbol, 'keyFor', descriptor);\n\n\tdescriptor.value = function getOwnPropertyDescriptor(o, key) {\n\t\tvar descriptor = gOPD(o, key);\n\t\tif (descriptor && onlySymbols(key)) {\n\t\tdescriptor.enumerable = propertyIsEnumerable.call(o, key);\n\t\t}\n\t\treturn descriptor;\n\t};\n\tobjectDefineProperty(Object, GOPD, descriptor);\n\n\tdescriptor.value = function create(proto, descriptors) {\n\t\treturn arguments.length === 1 || typeof descriptors === \"undefined\" ?\n\t\tobjectCreate(proto) :\n\t\tcreateWithSymbols(proto, descriptors);\n\t};\n\n\tobjectDefineProperty(Object, 'create', descriptor);\n\n\tvar strictModeSupported = (function(){ 'use strict'; return this; }).call(null) === null;\n\tif (strictModeSupported) {\n\t\tdescriptor.value = function () {\n\t\t\tvar str = toString.call(this);\n\t\t\treturn (str === '[object String]' && onlySymbols(this)) ? '[object Symbol]' : str;\n\t\t};\n\t} else {\n\t\tdescriptor.value = function () {\n\t\t\t// https://github.com/Financial-Times/polyfill-library/issues/164#issuecomment-486965300\n\t\t\t// Polyfill.io this code is here for the situation where a browser does not\n\t\t\t// support strict mode and is executing `Object.prototype.toString.call(null)`.\n\t\t\t// This code ensures that we return the correct result in that situation however,\n\t\t\t// this code also introduces a bug where it will return the incorrect result for\n\t\t\t// `Object.prototype.toString.call(window)`. We can't have the correct result for\n\t\t\t// both `window` and `null`, so we have opted for `null` as we believe this is the more\n\t\t\t// common situation.\n\t\t\tif (this === window) {\n\t\t\t\treturn '[object Null]';\n\t\t\t}\n\n\t\t\tvar str = toString.call(this);\n\t\t\treturn (str === '[object String]' && onlySymbols(this)) ? '[object Symbol]' : str;\n\t\t};\n\t}\n\tobjectDefineProperty(ObjectProto, 'toString', descriptor);\n\n\tsetDescriptor = function (o, key, descriptor) {\n\t\tvar protoDescriptor = gOPD(ObjectProto, key);\n\t\tdelete ObjectProto[key];\n\t\tobjectDefineProperty(o, key, descriptor);\n\t\tif (o !== ObjectProto) {\n\t\t\tobjectDefineProperty(ObjectProto, key, protoDescriptor);\n\t\t}\n\t};\n\n\t// The abstract operation thisSymbolValue(value) performs the following steps:\n\tfunction thisSymbolValue(value) {\n\t\t// 1. If Type(value) is Symbol, return value.\n\t\tif (Type(value) === \"symbol\") {\n\t\t\treturn value;\n\t\t}\n\t\t// 2. If Type(value) is Object and value has a [[SymbolData]] internal slot, then\n\t\t// a. Let s be value.[[SymbolData]].\n\t\t// b. Assert: Type(s) is Symbol.\n\t\t// c. Return s.\n\t\t// 3. Throw a TypeError exception.\n\t\tthrow TypeError(value + \" is not a symbol\");\n\t}\n\n\t// Symbol.prototype.description\n\tif (function () {\n\t\t// supports getters\n\t\ttry {\n\t\t\tvar a = {};\n\t\t\tObject.defineProperty(a, \"t\", {\n\t\t\t\tconfigurable: true,\n\t\t\t\tenumerable: false,\n\t\t\t\tget: function() {\n\t\t\t\t\treturn true;\n\t\t\t\t},\n\t\t\t\tset: undefined\n\t\t\t});\n\t\t\treturn !!a.t;\n\t\t} catch (e) {\n\t\t\treturn false;\n\t\t}\n\t}()) {\n\t\tvar getInferredName;\n\t\ttry {\n\t\t\t// eslint-disable-next-line no-new-func\n\t\t\tgetInferredName = Function(\"s\", \"var v = s.valueOf(); return { [v]() {} }[v].name;\");\n\t\t\t// eslint-disable-next-line no-empty\n\t\t} catch (e) { }\n\n\t\tvar inferred = function () { };\n\t\tvar supportsInferredNames = getInferredName && inferred.name === \"inferred\" ? getInferredName : null;\n\n\n\t\t// 19.4.3.2 get Symbol.prototype.description\n\t\tObject.defineProperty(global.Symbol.prototype, \"description\", {\n\t\t\tconfigurable: true,\n\t\t\tenumerable: false,\n\t\t\tget: function () {\n\t\t\t\t// 1. Let s be the this value.\n\t\t\t\tvar s = this;\n\t\t\t\treturn symbolDescription(s);\n\t\t\t}\n\t\t});\n\t}\n\n}(Object, 'getOwnPropertySymbols', self));\n\n}\n\nif (!(\"Symbol\"in self&&\"iterator\"in self.Symbol\n)) {\n\n// Symbol.iterator\nObject.defineProperty(self.Symbol, 'iterator', { value: self.Symbol('iterator') });\n\n}\n\n\n// _ESAbstract.GetIterator\n/* global GetMethod, Symbol, Call, Type, GetV */\n// 7.4.1. GetIterator ( obj [ , method ] )\n// The abstract operation GetIterator with argument obj and optional argument method performs the following steps:\nfunction GetIterator(obj /*, method */) { // eslint-disable-line no-unused-vars\n\t// 1. If method is not present, then\n\t\t// a. Set method to ? GetMethod(obj, @@iterator).\n\tvar method = arguments.length > 1 ? arguments[1] : GetMethod(obj, Symbol.iterator);\n\t// 2. Let iterator be ? Call(method, obj).\n\tvar iterator = Call(method, obj);\n\t// 3. If Type(iterator) is not Object, throw a TypeError exception.\n\tif (Type(iterator) !== 'object') {\n\t\tthrow new TypeError('bad iterator');\n\t}\n\t// 4. Let nextMethod be ? GetV(iterator, \"next\").\n\tvar nextMethod = GetV(iterator, \"next\");\n\t// 5. Let iteratorRecord be Record {[[Iterator]]: iterator, [[NextMethod]]: nextMethod, [[Done]]: false}.\n\tvar iteratorRecord = Object.create(null);\n\titeratorRecord['[[Iterator]]'] = iterator;\n\titeratorRecord['[[NextMethod]]'] = nextMethod;\n\titeratorRecord['[[Done]]'] = false;\n\t// 6. Return iteratorRecord.\n\treturn iteratorRecord;\n}\nif (!(\"Symbol\"in self&&\"species\"in self.Symbol\n)) {\n\n// Symbol.species\n/* global Symbol */\nObject.defineProperty(Symbol, 'species', { value: Symbol('species') });\n\n}\n\nif (!(\"Map\"in self&&function(t){try{var n=new t.Map([[1,1],[2,2]])\nreturn 0===t.Map.length&&2===n.size&&\"Symbol\"in t&&\"iterator\"in t.Symbol&&\"function\"==typeof n[t.Symbol.iterator]}catch(e){return!1}}(self)\n)) {\n\n// Map\n/* global CreateIterResultObject, CreateMethodProperty, GetIterator, IsCallable, IteratorClose, IteratorStep, IteratorValue, OrdinaryCreateFromConstructor, SameValueZero, Type, Symbol */\n(function (global) {\n\tvar supportsGetters = (function () {\n\t\ttry {\n\t\t\tvar a = {};\n\t\t\tObject.defineProperty(a, 't', {\n\t\t\t\tconfigurable: true,\n\t\t\t\tenumerable: false,\n\t\t\t\tget: function () {\n\t\t\t\t\treturn true;\n\t\t\t\t},\n\t\t\t\tset: undefined\n\t\t\t});\n\t\t\treturn !!a.t;\n\t\t} catch (e) {\n\t\t\treturn false;\n\t\t}\n\t}());\n\n\t// Need an internal counter to assign unique IDs to a key map\n\tvar _uniqueHashId = 0;\n\t// Create a unique key name for storing meta data on functions and objects to enable lookups in hash table\n\tvar _metaKey = Symbol('meta_' + ((Math.random() * 100000000) + '').replace('.', ''));\n\n\t/**\n\t * hashKey()\n\t * Function that given a key of `any` type, returns a string key value to enable hash map optimization for accessing Map data structure\n\t * @param {string|integer|function|object} recordKey - Record key to normalize to string accessor for hash map\n\t * @returns {string|false} - Returns a hashed string value or false if non extensible object key\n\t */\n\tvar hashKey = function(recordKey) {\n\t\t// Check to see if we are dealing with object or function type.\n\t\tif (typeof recordKey === 'object' ? recordKey !== null : typeof recordKey === 'function') {\n\t\t\t// Check to see if we are dealing with a non extensible object\n\t\t\tif (!Object.isExtensible(recordKey)) {\n\t\t\t\t// Return `false`\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (!Object.prototype.hasOwnProperty.call(recordKey, _metaKey)) {\n\t\t\t\tvar uniqueHashKey = typeof(recordKey)+'-'+(++_uniqueHashId);\n\t\t\t\tObject.defineProperty(recordKey, _metaKey, {\n\t\t\t\t\tconfigurable: false,\n\t\t\t\t\tenumerable: false,\n\t\t\t\t\twritable: false,\n\t\t\t\t\tvalue: uniqueHashKey\n\t\t\t\t});\n\t\t\t}\n\t\t\t// Return previously defined hashed key\n\t\t\treturn recordKey[_metaKey];\n\t\t}\n\t\t// If this is just a primitive, we can cast it to a string and return it\n\t\treturn ''+recordKey;\n\t};\n\n\t/**\n\t * getRecordIndex()\n\t * Function that given a Map and a key of `any` type, returns an index number that coorelates with a record found in `this._keys[index]` and `this._values[index]`\n\t * @param {Map} map - Map structure\n\t * @param {string|number|function|object} recordKey - Record key to normalize to string accessor for hash map\n\t * @returns {number|false} - Returns either a index to access map._keys and map._values, or false if not found\n\t */\n\tvar getRecordIndex = function(map, recordKey) {\n\t\tvar hashedKey = hashKey(recordKey); // Casts key to unique string (unless already string or number)\n\t\tif (hashedKey === false) {\n\t\t\t// We have to iterate through our Map structure because `recordKey` is non-primitive and not extensible\n\t\t\treturn getRecordIndexSlow(map, recordKey);\n\t\t}\n\t\tvar recordIndex = map._table[hashedKey]; // O(1) access to record\n\t\treturn recordIndex !== undefined ? recordIndex : false;\n\t};\n\n\t/**\n\t * getRecordIndexSlow()\n\t * Alternative (and slower) function to `getRecordIndex()`.  Necessary for looking up non-extensible object keys.\n\t * @param {Map} map - Map structure\n\t * @param {string|number|function|object} recordKey - Record key to normalize to string accessor for hash map\n\t * @returns {number|false} - Returns either a index to access map._keys and map._values, or false if not found\n\t */\n\tvar getRecordIndexSlow = function(map, recordKey) {\n\t\t// We have to iterate through our Map structure because `recordKey` is non-primitive and not extensible\n\t\tfor (var i = 0; i < map._keys.length; i++) {\n\t\t\tvar _recordKey = map._keys[i];\n\t\t\tif (_recordKey !== undefMarker && SameValueZero(_recordKey, recordKey)) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t};\n\n\t/**\n\t * setHashIndex()\n\t * Function that given a map, key of `any` type, and a value, creates a new entry in Map hash table\n\t * @param {Map} map\n\t * @param {string|number|function|object} recordKey - Key to translate into normalized key for hash map\n\t * @param {number|bool} recordIndex - new record index for the hashedKey or `false` to delete the record index for the hashedKey\n\t * @returns {bool} - indicates success of operation\n\t */\n\tvar setHashIndex = function(map, recordKey, recordIndex) {\n\t\tvar hashedKey = hashKey(recordKey);\n\t\tif (hashedKey === false) {\n\t\t\t// If hashed key is false, the recordKey is an object which is not extensible.\n\t\t\t// That indicates we cannot use the hash map for it, so this operation becomes no-op.\n\t\t\treturn false;\n\t\t}\n\t\tif (recordIndex === false) {\n\t\t\tdelete map._table[hashedKey];\n\t\t} else {\n\t\t\tmap._table[hashedKey] = recordIndex;\n\t\t}\n\t\treturn true;\n\t};\n\n\t// Deleted map items mess with iterator pointers, so rather than removing them mark them as deleted. Can't use undefined or null since those both valid keys so use a private symbol.\n\tvar undefMarker = Symbol('undef');\n\t// 23.1.1.1 Map ( [ iterable ] )\n\tvar Map = function Map(/* iterable */) {\n\t\t// 1. If NewTarget is undefined, throw a TypeError exception.\n\t\tif (!(this instanceof Map)) {\n\t\t\tthrow new TypeError('Constructor Map requires \"new\"');\n\t\t}\n\t\t// 2. Let map be ? OrdinaryCreateFromConstructor(NewTarget, \"%MapPrototype%\", « [[MapData]] »).\n\t\tvar map = OrdinaryCreateFromConstructor(this, Map.prototype, {\n\t\t\t_table: {}, // O(1) access table for retrieving records\n\t\t\t_keys: [],\n\t\t\t_values: [],\n\t\t\t_size: 0,\n\t\t\t_es6Map: true\n\t\t});\n\n\t\t// 3. Set map.[[MapData]] to a new empty List.\n\t\t// Polyfill.io - This step was done as part of step two.\n\n\t\t// Some old engines do not support ES5 getters/setters.  Since Map only requires these for the size property, we can fall back to setting the size property statically each time the size of the map changes.\n\t\tif (!supportsGetters) {\n\t\t\tObject.defineProperty(map, 'size', {\n\t\t\t\tconfigurable: true,\n\t\t\t\tenumerable: false,\n\t\t\t\twritable: true,\n\t\t\t\tvalue: 0\n\t\t\t});\n\t\t}\n\n\t\t// 4. If iterable is not present, let iterable be undefined.\n\t\tvar iterable = arguments.length > 0 ? arguments[0] : undefined;\n\n\t\t// 5. If iterable is either undefined or null, return map.\n\t\tif (iterable === null || iterable === undefined) {\n\t\t\treturn map;\n\t\t}\n\n\t\t// 6. Let adder be ? Get(map, \"set\").\n\t\tvar adder = map.set;\n\n\t\t// 7. If IsCallable(adder) is false, throw a TypeError exception.\n\t\tif (!IsCallable(adder)) {\n\t\t\tthrow new TypeError(\"Map.prototype.set is not a function\");\n\t\t}\n\n\t\t// 8. Let iteratorRecord be ? GetIterator(iterable).\n\t\ttry {\n\t\t\tvar iteratorRecord = GetIterator(iterable);\n\t\t\t// 9. Repeat,\n\t\t\t// eslint-disable-next-line no-constant-condition\n\t\t\twhile (true) {\n\t\t\t\t// a. Let next be ? IteratorStep(iteratorRecord).\n\t\t\t\tvar next = IteratorStep(iteratorRecord);\n\t\t\t\t// b. If next is false, return map.\n\t\t\t\tif (next === false) {\n\t\t\t\t\treturn map;\n\t\t\t\t}\n\t\t\t\t// c. Let nextItem be ? IteratorValue(next).\n\t\t\t\tvar nextItem = IteratorValue(next);\n\t\t\t\t// d. If Type(nextItem) is not Object, then\n\t\t\t\tif (Type(nextItem) !== 'object') {\n\t\t\t\t\t// i. Let error be Completion{[[Type]]: throw, [[Value]]: a newly created TypeError object, [[Target]]: empty}.\n\t\t\t\t\ttry {\n\t\t\t\t\t\tthrow new TypeError('Iterator value ' + nextItem + ' is not an entry object');\n\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\t// ii. Return ? IteratorClose(iteratorRecord, error).\n\t\t\t\t\t\treturn IteratorClose(iteratorRecord, error);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ttry {\n\t\t\t\t\t// Polyfill.io - The try catch accounts for steps: f, h, and j.\n\n\t\t\t\t\t// e. Let k be Get(nextItem, \"0\").\n\t\t\t\t\tvar k = nextItem[0];\n\t\t\t\t\t// f. If k is an abrupt completion, return ? IteratorClose(iteratorRecord, k).\n\t\t\t\t\t// g. Let v be Get(nextItem, \"1\").\n\t\t\t\t\tvar v = nextItem[1];\n\t\t\t\t\t// h. If v is an abrupt completion, return ? IteratorClose(iteratorRecord, v).\n\t\t\t\t\t// i. Let status be Call(adder, map, « k.[[Value]], v.[[Value]] »).\n\t\t\t\t\tadder.call(map, k, v);\n\t\t\t\t} catch (e) {\n\t\t\t\t\t// j. If status is an abrupt completion, return ? IteratorClose(iteratorRecord, status).\n\t\t\t\t\treturn IteratorClose(iteratorRecord, e);\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (e) {\n\t\t\t// Polyfill.io - For user agents which do not have iteration methods on argument objects or arrays, we can special case those.\n\t\t\tif (Array.isArray(iterable) ||\n\t\t\t\tObject.prototype.toString.call(iterable) === '[object Arguments]' ||\n\t\t\t\t// IE 7 & IE 8 return '[object Object]' for the arguments object, we can detect by checking for the existence of the callee property\n\t\t\t\t(!!iterable.callee)) {\n\t\t\t\tvar index;\n\t\t\t\tvar length = iterable.length;\n\t\t\t\tfor (index = 0; index < length; index++) {\n\t\t\t\t\tadder.call(map, iterable[index][0], iterable[index][1]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn map;\n\t};\n\n\t// 23.1.2.1. Map.prototype\n\t// The initial value of Map.prototype is the intrinsic object %MapPrototype%.\n\t// This property has the attributes { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }.\n\tObject.defineProperty(Map, 'prototype', {\n\t\tconfigurable: false,\n\t\tenumerable: false,\n\t\twritable: false,\n\t\tvalue: {}\n\t});\n\n\t// 23.1.2.2 get Map [ @@species ]\n\tif (supportsGetters) {\n\t\tObject.defineProperty(Map, Symbol.species, {\n\t\t\tconfigurable: true,\n\t\t\tenumerable: false,\n\t\t\tget: function () {\n\t\t\t\t// 1. Return the this value.\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\tset: undefined\n\t\t});\n\t} else {\n\t\tCreateMethodProperty(Map, Symbol.species, Map);\n\t}\n\n\t// 23.1.3.1 Map.prototype.clear ( )\n\tCreateMethodProperty(Map.prototype, 'clear', function clear() {\n\t\t\t// 1. Let M be the this value.\n\t\t\tvar M = this;\n\t\t\t// 2. If Type(M) is not Object, throw a TypeError exception.\n\t\t\tif (Type(M) !== 'object') {\n\t\t\t\tthrow new TypeError('Method Map.prototype.clear called on incompatible receiver ' + Object.prototype.toString.call(M));\n\t\t\t}\n\t\t\t// 3. If M does not have a [[MapData]] internal slot, throw a TypeError exception.\n\t\t\tif (M._es6Map !== true) {\n\t\t\t\tthrow new TypeError('Method Map.prototype.clear called on incompatible receiver ' + Object.prototype.toString.call(M));\n\t\t\t}\n\t\t\t// 4. Let entries be the List that is M.[[MapData]].\n\t\t\tvar entries = M._keys;\n\t\t\t// 5. For each Record {[[Key]], [[Value]]} p that is an element of entries, do\n\t\t\tfor (var i = 0; i < entries.length; i++) {\n\t\t\t\t// 5.a. Set p.[[Key]] to empty.\n\t\t\t\tM._keys[i] = undefMarker;\n\t\t\t\t// 5.b. Set p.[[Value]] to empty.\n\t\t\t\tM._values[i] = undefMarker;\n\t\t\t}\n\t\t\tthis._size = 0;\n\t\t\tif (!supportsGetters) {\n\t\t\t\tthis.size = this._size;\n\t\t\t}\n\t\t\t// 5a. Clear lookup table\n\t\t\tthis._table = {};\n\t\t\t// 6. Return undefined.\n\t\t\treturn undefined;\n\t\t}\n\t);\n\n\t// 23.1.3.2. Map.prototype.constructor\n\tCreateMethodProperty(Map.prototype, 'constructor', Map);\n\n\t// 23.1.3.3. Map.prototype.delete ( key )\n\tCreateMethodProperty(Map.prototype, 'delete', function (key) {\n\t\t\t// 1. Let M be the this value.\n\t\t\tvar M = this;\n\t\t\t// 2. If Type(M) is not Object, throw a TypeError exception.\n\t\t\tif (Type(M) !== 'object') {\n\t\t\t\tthrow new TypeError('Method Map.prototype.clear called on incompatible receiver ' + Object.prototype.toString.call(M));\n\t\t\t}\n\t\t\t// 3. If M does not have a [[MapData]] internal slot, throw a TypeError exception.\n\t\t\tif (M._es6Map !== true) {\n\t\t\t\tthrow new TypeError('Method Map.prototype.clear called on incompatible receiver ' + Object.prototype.toString.call(M));\n\t\t\t}\n\t\t\t// 4. Let entries be the List that is M.[[MapData]].\n\t\t\t// 5. For each Record {[[Key]], [[Value]]} p that is an element of entries, do\n\t\t\t\t// 5a. If p.[[Key]] is not empty and SameValueZero(p.[[Key]], key) is true, then\n\t\t\t\t\t// i. Set p.[[Key]] to empty.\n\t\t\t\t\t// ii. Set p.[[Value]] to empty.\n\t\t\t\t\t// ii-a. Remove key from lookup table\n\t\t\t\t\t// iii. Return true.\n\t\t\t// 6. Return false.\n\n\t\t\t// Implement steps 4-6 with a more optimal algo\n\n\t\t\t// Steps 4-5: Access record\n\t\t\tvar recordIndex = getRecordIndex(M, key); // O(1) access to record index\n\n\t\t\tif (recordIndex !== false) {\n\t\t\t\t// Get record's `key` (could be `any` type);\n\t\t\t\tvar recordKey = M._keys[recordIndex];\n\t\t\t\t// 5a. If p.[[Key]] is not empty and SameValueZero(p.[[Key]], key) is true, then\n\t\t\t\tif (recordKey !== undefMarker && SameValueZero(recordKey, key)) {\n\t\t\t\t\t// i. Set p.[[Key]] to empty.\n\t\t\t\t\tthis._keys[recordIndex] = undefMarker;\n\t\t\t\t\t// ii. Set p.[[Value]] to empty.\n\t\t\t\t\tthis._values[recordIndex] = undefMarker;\n\t\t\t\t\tthis._size = --this._size;\n\t\t\t\t\tif (!supportsGetters) {\n\t\t\t\t\t\tthis.size = this._size;\n\t\t\t\t\t}\n\t\t\t\t\t// iia. Remove key from lookup table\n\t\t\t\t\tsetHashIndex(this, key, false);\n\t\t\t\t\t// iii. Return true.\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// 6. Return false.\n\t\t\treturn false;\n\t\t}\n\t);\n\n\t// 23.1.3.4. Map.prototype.entries ( )\n\tCreateMethodProperty(Map.prototype, 'entries', function entries () {\n\t\t\t// 1. Let M be the this value.\n\t\t\tvar M = this;\n\t\t\t// 2. Return ? CreateMapIterator(M, \"key+value\").\n\t\t\treturn CreateMapIterator(M, 'key+value');\n\t\t}\n\t);\n\n\t// 23.1.3.5. Map.prototype.forEach ( callbackfn [ , thisArg ] )\n\tCreateMethodProperty(Map.prototype, 'forEach', function (callbackFn) {\n\t\t\t// 1. Let M be the this value.\n\t\t\tvar M = this;\n\t\t\t// 2. If Type(M) is not Object, throw a TypeError exception.\n\t\t\tif (Type(M) !== 'object') {\n\t\t\t\tthrow new TypeError('Method Map.prototype.forEach called on incompatible receiver ' + Object.prototype.toString.call(M));\n\t\t\t}\n\t\t\t// 3. If M does not have a [[MapData]] internal slot, throw a TypeError exception.\n\t\t\tif (M._es6Map !== true) {\n\t\t\t\tthrow new TypeError('Method Map.prototype.forEach called on incompatible receiver ' + Object.prototype.toString.call(M));\n\t\t\t}\n\t\t\t// 4. If IsCallable(callbackfn) is false, throw a TypeError exception.\n\t\t\tif (!IsCallable(callbackFn)) {\n\t\t\t\tthrow new TypeError(Object.prototype.toString.call(callbackFn) + ' is not a function.');\n\t\t\t}\n\t\t\t// 5. If thisArg is present, let T be thisArg; else let T be undefined.\n\t\t\tif (arguments[1]) {\n\t\t\t\tvar T = arguments[1];\n\t\t\t}\n\t\t\t// 6. Let entries be the List that is M.[[MapData]].\n\t\t\tvar entries = M._keys;\n\t\t\t// 7. For each Record {[[Key]], [[Value]]} e that is an element of entries, in original key insertion order, do\n\t\t\tfor (var i = 0; i < entries.length; i++) {\n\t\t\t\t// a. If e.[[Key]] is not empty, then\n\t\t\t\tif (M._keys[i] !== undefMarker && M._values[i] !== undefMarker ) {\n\t\t\t\t\t// i. Perform ? Call(callbackfn, T, « e.[[Value]], e.[[Key]], M »).\n\t\t\t\t\tcallbackFn.call(T, M._values[i], M._keys[i], M);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// 8. Return undefined.\n\t\t\treturn undefined;\n\t\t}\n\t);\n\n\t// 23.1.3.6. Map.prototype.get ( key )\n\tCreateMethodProperty(Map.prototype, 'get', function get(key) {\n\t\t\t// 1. Let M be the this value.\n\t\t\tvar M = this;\n\t\t\t// 2. If Type(M) is not Object, throw a TypeError exception.\n\t\t\tif (Type(M) !== 'object') {\n\t\t\t\tthrow new TypeError('Method Map.prototype.get called on incompatible receiver ' + Object.prototype.toString.call(M));\n\t\t\t}\n\t\t\t// 3. If M does not have a [[MapData]] internal slot, throw a TypeError exception.\n\t\t\tif (M._es6Map !== true) {\n\t\t\t\tthrow new TypeError('Method Map.prototype.get called on incompatible receiver ' + Object.prototype.toString.call(M));\n\t\t\t}\n\t\t\t// 4. Let entries be the List that is M.[[MapData]].\n\t\t\t// 5. For each Record {[[Key]], [[Value]]} p that is an element of entries, do\n\t\t\t\t// a. If p.[[Key]] is not empty and SameValueZero(p.[[Key]], key) is true, return p.[[Value]].\n\t\t\t// 6. Return undefined.\n\n\t\t\t// Implement steps 4-6 with a more optimal algo\n\t\t\tvar recordIndex = getRecordIndex(M, key); // O(1) access to record index\n\t\t\tif (recordIndex !== false) {\n\t\t\t\tvar recordKey = M._keys[recordIndex];\n\t\t\t\tif (recordKey !== undefMarker && SameValueZero(recordKey, key)) {\n\t\t\t\t\treturn M._values[recordIndex];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn undefined;\n\t\t});\n\n\t// 23.1.3.7. Map.prototype.has ( key )\n\tCreateMethodProperty(Map.prototype, 'has', function has (key) {\n\t\t\t// 1. Let M be the this value.\n\t\t\tvar M = this;\n\t\t\t// 2. If Type(M) is not Object, throw a TypeError exception.\n\t\t\tif (typeof M !== 'object') {\n\t\t\t\tthrow new TypeError('Method Map.prototype.has called on incompatible receiver ' + Object.prototype.toString.call(M));\n\t\t\t}\n\t\t\t// 3. If M does not have a [[MapData]] internal slot, throw a TypeError exception.\n\t\t\tif (M._es6Map !== true) {\n\t\t\t\tthrow new TypeError('Method Map.prototype.has called on incompatible receiver ' + Object.prototype.toString.call(M));\n\t\t\t}\n\t\t\t// 4. Let entries be the List that is M.[[MapData]].\n\t\t\t// 5. For each Record {[[Key]], [[Value]]} p that is an element of entries, do\n\t\t\t\t// a. If p.[[Key]] is not empty and SameValueZero(p.[[Key]], key) is true, return true.\n\t\t\t// 6. Return false.\n\n\t\t\t// Implement steps 4-6 with a more optimal algo\n\t\t\tvar recordIndex = getRecordIndex(M, key); // O(1) access to record index\n\t\t\tif (recordIndex !== false) {\n\t\t\t\tvar recordKey = M._keys[recordIndex];\n\t\t\t\tif (recordKey !== undefMarker && SameValueZero(recordKey, key)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn false;\n\t\t});\n\n\t// 23.1.3.8. Map.prototype.keys ( )\n\tCreateMethodProperty(Map.prototype, 'keys', function keys () {\n\t\t\t// 1. Let M be the this value.\n\t\t\tvar M = this;\n\t\t\t// 2. Return ? CreateMapIterator(M, \"key\").\n\t\t\treturn CreateMapIterator(M, \"key\");\n\t\t});\n\n\t// 23.1.3.9. Map.prototype.set ( key, value )\n\tCreateMethodProperty(Map.prototype, 'set', function set(key, value) {\n\t\t\t// 1. Let M be the this value.\n\t\t\tvar M = this;\n\t\t\t// 2. If Type(M) is not Object, throw a TypeError exception.\n\t\t\tif (Type(M) !== 'object') {\n\t\t\t\tthrow new TypeError('Method Map.prototype.set called on incompatible receiver ' + Object.prototype.toString.call(M));\n\t\t\t}\n\t\t\t// 3. If M does not have a [[MapData]] internal slot, throw a TypeError exception.\n\t\t\tif (M._es6Map !== true) {\n\t\t\t\tthrow new TypeError('Method Map.prototype.set called on incompatible receiver ' + Object.prototype.toString.call(M));\n\t\t\t}\n\t\t\t// 4. Let entries be the List that is M.[[MapData]].\n\t\t\t// 5. For each Record {[[Key]], [[Value]]} p that is an element of entries, do\n\t\t\t// 6. If key is -0, let key be +0.\n\t\t\t// 7. Let p be the Record {[[Key]]: key, [[Value]]: value}.\n\t\t\t// 8. Append p as the last element of entries.\n\t\t\t// 9. Return M.\n\n\t\t\t// Strictly following the above steps 4-9 will lead to an inefficient algorithm.\n\t\t\t// Step 8 also doesn't seem to be required if an entry already exists\n\t\t\tvar recordIndex = getRecordIndex(M, key); // O(1) access to record index\n\t\t\tif (recordIndex !== false) {\n\t\t\t\t// update path\n\t\t\t\tM._values[recordIndex] = value;\n\t\t\t} else {\n\t\t\t\t// eslint-disable-next-line no-compare-neg-zero\n\t\t\t\tif (key === -0) {\n\t\t\t\t\tkey = 0;\n\t\t\t\t}\n\t\t\t\tvar p = {\n\t\t\t\t\t'[[Key]]': key,\n\t\t\t\t\t'[[Value]]': value\n\t\t\t\t};\n\t\t\t\tM._keys.push(p['[[Key]]']);\n\t\t\t\tM._values.push(p['[[Value]]']);\n\t\t\t\tsetHashIndex(M, key, M._keys.length - 1); // update lookup table\n\t\t\t\t++M._size;\n\t\t\t\tif (!supportsGetters) {\n\t\t\t\t\tM.size = M._size;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn M;\n\t\t});\n\n\t// 23.1.3.10. get Map.prototype.size\n\tif (supportsGetters) {\n\t\tObject.defineProperty(Map.prototype, 'size', {\n\t\t\tconfigurable: true,\n\t\t\tenumerable: false,\n\t\t\tget: function () {\n\t\t\t\t// 1. Let M be the this value.\n\t\t\t\tvar M = this;\n\t\t\t\t// 2. If Type(M) is not Object, throw a TypeError exception.\n\t\t\t\tif (Type(M) !== 'object') {\n\t\t\t\t\tthrow new TypeError('Method Map.prototype.size called on incompatible receiver ' + Object.prototype.toString.call(M));\n\t\t\t\t}\n\t\t\t\t// 3. If M does not have a [[MapData]] internal slot, throw a TypeError exception.\n\t\t\t\tif (M._es6Map !== true) {\n\t\t\t\t\tthrow new TypeError('Method Map.prototype.size called on incompatible receiver ' + Object.prototype.toString.call(M));\n\t\t\t\t}\n\t\t\t\t// 4. Let entries be the List that is M.[[MapData]].\n\t\t\t\t// 5. Let count be 0.\n\t\t\t\t// 6. For each Record {[[Key]], [[Value]]} p that is an element of entries, do\n\t\t\t\t\t// 6a. If p.[[Key]] is not empty, set count to count+1.\n\t\t\t\t// 7. Return count.\n\n\t\t\t\t// Implement 4-7 more efficently by returning pre-computed property\n\t\t\t\treturn this._size;\n\t\t\t},\n\t\t\tset: undefined\n\t\t});\n\t}\n\n\t// 23.1.3.11. Map.prototype.values ( )\n\tCreateMethodProperty(Map.prototype, 'values', function values () {\n\t\t\t// 1. Let M be the this value.\n\t\t\tvar M = this;\n\t\t\t// 2. Return ? CreateMapIterator(M, \"value\").\n\t\t\treturn CreateMapIterator(M, 'value');\n\t\t}\n\t);\n\n\t// 23.1.3.12. Map.prototype [ @@iterator ] ( )\n\t// The initial value of the @@iterator property is the same function object as the initial value of the entries property.\n\tCreateMethodProperty(Map.prototype, Symbol.iterator, Map.prototype.entries);\n\n\t// 23.1.3.13. Map.prototype [ @@toStringTag ]\n\t// The initial value of the @@toStringTag property is the String value \"Map\".\n\t// This property has the attributes { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: true }.\n\n\t// Polyfill.io - Safari 8 implements Map.name but as a non-configurable property, which means it would throw an error if we try and configure it here.\n\tif (!('name' in Map)) {\n\t\t// 19.2.4.2 name\n\t\tObject.defineProperty(Map, 'name', {\n\t\t\tconfigurable: true,\n\t\t\tenumerable: false,\n\t\t\twritable: false,\n\t\t\tvalue: 'Map'\n\t\t});\n\t}\n\n\t// 23.1.5.1. CreateMapIterator ( map, kind )\n\tfunction CreateMapIterator(map, kind) {\n\t\t// 1. If Type(map) is not Object, throw a TypeError exception.\n\t\tif (Type(map) !== 'object') {\n\t\t\tthrow new TypeError('createMapIterator called on incompatible receiver ' + Object.prototype.toString.call(map));\n\t\t}\n\t\t// 2. If map does not have a [[MapData]] internal slot, throw a TypeError exception.\n\t\tif (map._es6Map !== true) {\n\t\t\tthrow new TypeError('createMapIterator called on incompatible receiver ' + Object.prototype.toString.call(map));\n\t\t}\n\t\t// 3. Let iterator be ObjectCreate(%MapIteratorPrototype%, « [[Map]], [[MapNextIndex]], [[MapIterationKind]] »).\n\t\tvar iterator = Object.create(MapIteratorPrototype);\n\t\t// 4. Set iterator.[[Map]] to map.\n\t\tObject.defineProperty(iterator, '[[Map]]', {\n\t\t\tconfigurable: true,\n\t\t\tenumerable: false,\n\t\t\twritable: true,\n\t\t\tvalue: map\n\t\t});\n\t\t// 5. Set iterator.[[MapNextIndex]] to 0.\n\t\tObject.defineProperty(iterator, '[[MapNextIndex]]', {\n\t\t\tconfigurable: true,\n\t\t\tenumerable: false,\n\t\t\twritable: true,\n\t\t\tvalue: 0\n\t\t});\n\t\t// 6. Set iterator.[[MapIterationKind]] to kind.\n\t\tObject.defineProperty(iterator, '[[MapIterationKind]]', {\n\t\t\tconfigurable: true,\n\t\t\tenumerable: false,\n\t\t\twritable: true,\n\t\t\tvalue: kind\n\t\t});\n\t\t// 7. Return iterator.\n\t\treturn iterator;\n\t}\n\n\t// 23.1.5.2. The %MapIteratorPrototype% Object\n\tvar MapIteratorPrototype = {};\n\t// Polyfill.io - We use this as a quick way to check if an object is a Map Iterator instance.\n\tObject.defineProperty(MapIteratorPrototype, 'isMapIterator', {\n\t\tconfigurable: false,\n\t\tenumerable: false,\n\t\twritable: false,\n\t\tvalue: true\n\t});\n\n\t// 23.1.5.2.1. %MapIteratorPrototype%.next ( )\n\tCreateMethodProperty(MapIteratorPrototype, 'next', function next() {\n\t\t\t// 1. Let O be the this value.\n\t\t\tvar O = this;\n\t\t\t// 2. If Type(O) is not Object, throw a TypeError exception.\n\t\t\tif (Type(O) !== 'object') {\n\t\t\t\tthrow new TypeError('Method %MapIteratorPrototype%.next called on incompatible receiver ' + Object.prototype.toString.call(O));\n\t\t\t}\n\t\t\t// 3. If O does not have all of the internal slots of a Map Iterator Instance (23.1.5.3), throw a TypeError exception.\n\t\t\tif (!O.isMapIterator) {\n\t\t\t\tthrow new TypeError('Method %MapIteratorPrototype%.next called on incompatible receiver ' + Object.prototype.toString.call(O));\n\t\t\t}\n\t\t\t// 4. Let m be O.[[Map]].\n\t\t\tvar m = O['[[Map]]'];\n\t\t\t// 5. Let index be O.[[MapNextIndex]].\n\t\t\tvar index = O['[[MapNextIndex]]'];\n\t\t\t// 6. Let itemKind be O.[[MapIterationKind]].\n\t\t\tvar itemKind = O['[[MapIterationKind]]'];\n\t\t\t// 7. If m is undefined, return CreateIterResultObject(undefined, true).\n\t\t\tif (m === undefined) {\n\t\t\t\treturn CreateIterResultObject(undefined, true);\n\t\t\t}\n\t\t\t// 8. Assert: m has a [[MapData]] internal slot.\n\t\t\tif (!m._es6Map) {\n\t\t\t\tthrow new Error(Object.prototype.toString.call(m) + ' has a [[MapData]] internal slot.');\n\t\t\t}\n\t\t\t// 9. Let entries be the List that is m.[[MapData]].\n\t\t\tvar entries = m._keys;\n\t\t\t// 10. Let numEntries be the number of elements of entries.\n\t\t\tvar numEntries = entries.length;\n\t\t\t// 11. NOTE: numEntries must be redetermined each time this method is evaluated.\n\t\t\t// 12. Repeat, while index is less than numEntries,\n\t\t\twhile (index < numEntries) {\n\t\t\t\t// a. Let e be the Record {[[Key]], [[Value]]} that is the value of entries[index].\n\t\t\t\tvar e = Object.create(null);\n\t\t\t\te['[[Key]]'] = m._keys[index];\n\t\t\t\te['[[Value]]'] = m._values[index];\n\t\t\t\t// b. Set index to index+1.\n\t\t\t\tindex = index + 1;\n\t\t\t\t// c. Set O.[[MapNextIndex]] to index.\n\t\t\t\tO['[[MapNextIndex]]'] = index;\n\t\t\t\t// d. If e.[[Key]] is not empty, then\n\t\t\t\tif (e['[[Key]]'] !== undefMarker) {\n\t\t\t\t\t// i. If itemKind is \"key\", let result be e.[[Key]].\n\t\t\t\t\tif (itemKind === 'key') {\n\t\t\t\t\t\tvar result = e['[[Key]]'];\n\t\t\t\t\t\t// ii. Else if itemKind is \"value\", let result be e.[[Value]].\n\t\t\t\t\t} else if (itemKind === 'value') {\n\t\t\t\t\t\tresult = e['[[Value]]'];\n\t\t\t\t\t\t// iii. Else,\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// 1. Assert: itemKind is \"key+value\".\n\t\t\t\t\t\tif (itemKind !== 'key+value') {\n\t\t\t\t\t\t\tthrow new Error();\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// 2. Let result be CreateArrayFromList(« e.[[Key]], e.[[Value]] »).\n\t\t\t\t\t\tresult = [\n\t\t\t\t\t\t\te['[[Key]]'],\n\t\t\t\t\t\t\te['[[Value]]']\n\t\t\t\t\t\t];\n\t\t\t\t\t}\n\t\t\t\t\t// iv. Return CreateIterResultObject(result, false).\n\t\t\t\t\treturn CreateIterResultObject(result, false);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// 13. Set O.[[Map]] to undefined.\n\t\t\tO['[[Map]]'] = undefined;\n\t\t\t// 14. Return CreateIterResultObject(undefined, true).\n\t\t\treturn CreateIterResultObject(undefined, true);\n\t\t}\n\t);\n\n\t// 23.1.5.2.2 %MapIteratorPrototype% [ @@toStringTag ]\n\t// The initial value of the @@toStringTag property is the String value \"Map Iterator\".\n\t// This property has the attributes { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: true }.\n\n\tCreateMethodProperty(MapIteratorPrototype, Symbol.iterator, function iterator() {\n\t\t\treturn this;\n\t\t}\n\t);\n\n\t// Export the object\n\ttry {\n\t\tCreateMethodProperty(global, 'Map', Map);\n\t} catch (e) {\n\t\t// IE8 throws an error here if we set enumerable to false.\n\t\t// More info on table 2: https://msdn.microsoft.com/en-us/library/dd229916(v=vs.85).aspx\n\t\tglobal.Map = Map;\n\t}\n}(self));\n\n}\n\nif (!(\"Set\"in self&&function(){try{var e=new self.Set([1,2])\nreturn 0===self.Set.length&&2===e.size&&\"Symbol\"in self&&\"iterator\"in self.Symbol&&\"function\"==typeof e[self.Symbol.iterator]}catch(t){return!1}}()\n)) {\n\n// Set\n/* global CreateIterResultObject, CreateMethodProperty, GetIterator, IsCallable, IteratorClose, IteratorStep, IteratorValue, OrdinaryCreateFromConstructor, SameValueZero, Symbol */\n(function (global) {\n\tvar supportsGetters = (function () {\n\t\ttry {\n\t\t\tvar a = {};\n\t\t\tObject.defineProperty(a, 't', {\n\t\t\t\tconfigurable: true,\n\t\t\t\tenumerable: false,\n\t\t\t\tget: function () {\n\t\t\t\t\treturn true;\n\t\t\t\t},\n\t\t\t\tset: undefined\n\t\t\t});\n\t\t\treturn !!a.t;\n\t\t} catch (e) {\n\t\t\treturn false;\n\t\t}\n\t}());\n\n\t// Deleted set items mess with iterator pointers, so rather than removing them mark them as deleted. Can't use undefined or null since those both valid keys so use a private symbol.\n\tvar undefMarker = Symbol('undef');\n\t// 23.2.1.1. Set ( [ iterable ] )\n\tvar Set = function Set(/* iterable */) {\n\t\t// 1. If NewTarget is undefined, throw a TypeError exception.\n\t\tif (!(this instanceof Set)) {\n\t\t\tthrow new TypeError('Constructor Set requires \"new\"');\n\t\t}\n\t\t// 2. Let set be ? OrdinaryCreateFromConstructor(NewTarget, \"%SetPrototype%\", « [[SetData]] »).\n\t\tvar set = OrdinaryCreateFromConstructor(this, Set.prototype, {\n\t\t\t_values: [],\n\t\t\t_size: 0,\n\t\t\t_es6Set: true\n\t\t});\n\n\t\t// 3. Set set.[[SetData]] to a new empty List.\n\t\t// Polyfill.io - This step was done as part of step two.\n\n\t\t// Some old engines do not support ES5 getters/setters.  Since Set only requires these for the size property, we can fall back to setting the size property statically each time the size of the set changes.\n\t\tif (!supportsGetters) {\n\t\t\tObject.defineProperty(set, 'size', {\n\t\t\t\tconfigurable: true,\n\t\t\t\tenumerable: false,\n\t\t\t\twritable: true,\n\t\t\t\tvalue: 0\n\t\t\t});\n\t\t}\n\n\t\t// 4. If iterable is not present, let iterable be undefined.\n\t\tvar iterable = arguments.length > 0 ? arguments[0] : undefined;\n\n\t\t// 5. If iterable is either undefined or null, return set.\n\t\tif (iterable === null || iterable === undefined) {\n\t\t\treturn set;\n\t\t}\n\n\t\t// 6. Let adder be ? Get(set, \"add\").\n\t\tvar adder = set.add;\n\t\t// 7. If IsCallable(adder) is false, throw a TypeError exception.\n\t\tif (!IsCallable(adder)) {\n\t\t\tthrow new TypeError(\"Set.prototype.add is not a function\");\n\t\t}\n\n\t\ttry {\n\t\t\t// 8. Let iteratorRecord be ? GetIterator(iterable).\n\t\t\tvar iteratorRecord = GetIterator(iterable);\n\t\t\t// 9. Repeat,\n\t\t\t// eslint-disable-next-line no-constant-condition\n\t\t\twhile (true) {\n\t\t\t\t// a. Let next be ? IteratorStep(iteratorRecord).\n\t\t\t\tvar next = IteratorStep(iteratorRecord);\n\t\t\t\t// b. If next is false, return set.\n\t\t\t\tif (next === false) {\n\t\t\t\t\treturn set;\n\t\t\t\t}\n\t\t\t\t// c. Let nextValue be ? IteratorValue(next).\n\t\t\t\tvar nextValue = IteratorValue(next);\n\t\t\t\t// d. Let status be Call(adder, set, « nextValue.[[Value]] »).\n\t\t\t\ttry {\n\t\t\t\t\tadder.call(set, nextValue);\n\t\t\t\t} catch (e) {\n\t\t\t\t\t// e. If status is an abrupt completion, return ? IteratorClose(iteratorRecord, status).\n\t\t\t\t\treturn IteratorClose(iteratorRecord, e);\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (e) {\n\t\t\t// Polyfill.io - For user agents which do not have iteration methods on argument objects or arrays, we can special case those.\n\t\t\tif (Array.isArray(iterable) ||\n\t\t\t\tObject.prototype.toString.call(iterable) === '[object Arguments]' ||\n\t\t\t\t// IE 7 & IE 8 return '[object Object]' for the arguments object, we can detect by checking for the existence of the callee property\n\t\t\t\t(!!iterable.callee)) {\n\t\t\t\tvar index;\n\t\t\t\tvar length = iterable.length;\n\t\t\t\tfor (index = 0; index < length; index++) {\n\t\t\t\t\tadder.call(set, iterable[index]);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthrow (e);\n\t\t\t}\n\t\t}\n\t\treturn set;\n\t};\n\n\t// 23.2.2.1. Set.prototype\n\t// The initial value of Set.prototype is the intrinsic %SetPrototype% object.\n\t// This property has the attributes { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }.\n\tObject.defineProperty(Set, 'prototype', {\n\t\tconfigurable: false,\n\t\tenumerable: false,\n\t\twritable: false,\n\t\tvalue: {}\n\t});\n\n\t// 23.2.2.2 get Set [ @@species ]\n\tif (supportsGetters) {\n\t\tObject.defineProperty(Set, Symbol.species, {\n\t\t\tconfigurable: true,\n\t\t\tenumerable: false,\n\t\t\tget: function () {\n\t\t\t\t// 1. Return the this value.\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\tset: undefined\n\t\t});\n\t} else {\n\t\tCreateMethodProperty(Set, Symbol.species, Set);\n\t}\n\n\t// 23.2.3.1. Set.prototype.add ( value )\n\tCreateMethodProperty(Set.prototype, 'add', function add(value) {\n\t\t\t// 1. Let S be the this value.\n\t\t\tvar S = this;\n\t\t\t// 2. If Type(S) is not Object, throw a TypeError exception.\n\t\t\tif (typeof S !== 'object') {\n\t\t\t\tthrow new TypeError('Method Set.prototype.add called on incompatible receiver ' + Object.prototype.toString.call(S));\n\t\t\t}\n\t\t\t// 3. If S does not have a [[SetData]] internal slot, throw a TypeError exception.\n\t\t\tif (S._es6Set !== true) {\n\t\t\t\tthrow new TypeError('Method Set.prototype.add called on incompatible receiver ' + Object.prototype.toString.call(S));\n\t\t\t}\n\t\t\t// 4. Let entries be the List that is S.[[SetData]].\n\t\t\tvar entries = S._values;\n\t\t\t// 5. For each e that is an element of entries, do\n\t\t\tfor (var i = 0; i < entries.length; i++) {\n\t\t\t\tvar e = entries[i];\n\t\t\t\t// a. If e is not empty and SameValueZero(e, value) is true, then\n\t\t\t\tif (e !== undefMarker && SameValueZero(e, value)) {\n\t\t\t\t\t// i. Return S.\n\t\t\t\t\treturn S;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// 6. If value is -0, let value be +0.\n\t\t\tif (value === 0 && 1/value === -Infinity) {\n\t\t\t\tvalue = 0;\n\t\t\t}\n\t\t\t// 7. Append value as the last element of entries.\n\t\t\tS._values.push(value);\n\n\t\t\tthis._size = ++this._size;\n\t\t\tif (!supportsGetters) {\n\t\t\t\tthis.size = this._size;\n\t\t\t}\n\t\t\t// 8. Return S.\n\t\t\treturn S;\n\t\t});\n\n\t// 23.2.3.2. Set.prototype.clear ( )\n\tCreateMethodProperty(Set.prototype, 'clear', function clear() {\n\t\t\t// 1. Let S be the this value.\n\t\t\tvar S = this;\n\t\t\t// 2. If Type(S) is not Object, throw a TypeError exception.\n\t\t\tif (typeof S !== 'object') {\n\t\t\t\tthrow new TypeError('Method Set.prototype.clear called on incompatible receiver ' + Object.prototype.toString.call(S));\n\t\t\t}\n\t\t\t// 3. If S does not have a [[SetData]] internal slot, throw a TypeError exception.\n\t\t\tif (S._es6Set !== true) {\n\t\t\t\tthrow new TypeError('Method Set.prototype.clear called on incompatible receiver ' + Object.prototype.toString.call(S));\n\t\t\t}\n\t\t\t// 4. Let entries be the List that is S.[[SetData]].\n\t\t\tvar entries = S._values;\n\t\t\t// 5. For each e that is an element of entries, do\n\t\t\tfor (var i = 0; i < entries.length; i++) {\n\t\t\t\t// a. Replace the element of entries whose value is e with an element whose value is empty.\n\t\t\t\tentries[i] = undefMarker;\n\t\t\t}\n\t\t\tthis._size = 0;\n\t\t\tif (!supportsGetters) {\n\t\t\t\tthis.size = this._size;\n\t\t\t}\n\t\t\t// 6. Return undefined.\n\t\t\treturn undefined;\n\t\t});\n\n\t// 23.2.3.3. Set.prototype.constructor\n\tCreateMethodProperty(Set.prototype, 'constructor', Set);\n\n\t// 23.2.3.4. Set.prototype.delete ( value )\n\tCreateMethodProperty(Set.prototype, 'delete', function (value) {\n\t\t\t// 1. Let S be the this value.\n\t\t\tvar S = this;\n\t\t\t// 2. If Type(S) is not Object, throw a TypeError exception.\n\t\t\tif (typeof S !== 'object') {\n\t\t\t\tthrow new TypeError('Method Set.prototype.delete called on incompatible receiver ' + Object.prototype.toString.call(S));\n\t\t\t}\n\t\t\t// 3. If S does not have a [[SetData]] internal slot, throw a TypeError exception.\n\t\t\tif (S._es6Set !== true) {\n\t\t\t\tthrow new TypeError('Method Set.prototype.delete called on incompatible receiver ' + Object.prototype.toString.call(S));\n\t\t\t}\n\t\t\t// 4. Let entries be the List that is S.[[SetData]].\n\t\t\tvar entries = S._values;\n\t\t\t// 5. For each e that is an element of entries, do\n\t\t\tfor (var i = 0; i < entries.length; i++) {\n\t\t\t\tvar e = entries[i];\n\t\t\t\t// a. If e is not empty and SameValueZero(e, value) is true, then\n\t\t\t\tif (e !== undefMarker && SameValueZero(e, value)) {\n\t\t\t\t\t// i. Replace the element of entries whose value is e with an element whose value is empty.\n\t\t\t\t\tentries[i] = undefMarker;\n\n\t\t\t\t\tthis._size = --this._size;\n\t\t\t\t\tif (!supportsGetters) {\n\t\t\t\t\t\tthis.size = this._size;\n\t\t\t\t\t}\n\t\t\t\t\t// ii. Return true.\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// 6. Return false.\n\t\t\treturn false;\n\t\t}\n\t);\n\n\t// 23.2.3.5. Set.prototype.entries ( )\n\tCreateMethodProperty(Set.prototype, 'entries', function entries() {\n\t\t\t// 1. Let S be the this value.\n\t\t\tvar S = this;\n\t\t\t// 2. Return ? CreateSetIterator(S, \"key+value\").\n\t\t\treturn CreateSetIterator(S, 'key+value');\n\t\t}\n\t);\n\n\t// 23.2.3.6. Set.prototype.forEach ( callbackfn [ , thisArg ] )\n\tCreateMethodProperty(Set.prototype, 'forEach', function forEach(callbackFn /*[ , thisArg ]*/) {\n\t\t\t// 1. Let S be the this value.\n\t\t\tvar S = this;\n\t\t\t// 2. If Type(S) is not Object, throw a TypeError exception.\n\t\t\tif (typeof S !== 'object') {\n\t\t\t\tthrow new TypeError('Method Set.prototype.forEach called on incompatible receiver ' + Object.prototype.toString.call(S));\n\t\t\t}\n\t\t\t// 3. If S does not have a [[SetData]] internal slot, throw a TypeError exception.\n\t\t\tif (S._es6Set !== true) {\n\t\t\t\tthrow new TypeError('Method Set.prototype.forEach called on incompatible receiver ' + Object.prototype.toString.call(S));\n\t\t\t}\n\t\t\t// 4. If IsCallable(callbackfn) is false, throw a TypeError exception.\n\t\t\tif (!IsCallable(callbackFn)) {\n\t\t\t\tthrow new TypeError(Object.prototype.toString.call(callbackFn) + ' is not a function.');\n\t\t\t}\n\t\t\t// 5. If thisArg is present, let T be thisArg; else let T be undefined.\n\t\t\tif (arguments[1]) {\n\t\t\t\tvar T = arguments[1];\n\t\t\t}\n\t\t\t// 6. Let entries be the List that is S.[[SetData]].\n\t\t\tvar entries = S._values;\n\t\t\t// 7. For each e that is an element of entries, in original insertion order, do\n\t\t\tfor (var i = 0; i < entries.length; i++) {\n\t\t\t\tvar e = entries[i];\n\t\t\t\t// a. If e is not empty, then\n\t\t\t\tif (e !== undefMarker) {\n\t\t\t\t\t// i. Perform ? Call(callbackfn, T, « e, e, S »).\n\t\t\t\t\tcallbackFn.call(T, e, e, S);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// 8. Return undefined.\n\t\t\treturn undefined;\n\t\t}\n\t);\n\n\t// 23.2.3.7. Set.prototype.has ( value )\n\tCreateMethodProperty(Set.prototype, 'has', function has(value) {\n\t\t\t// 1. Let S be the this value.\n\t\t\tvar S = this;\n\t\t\t// 2. If Type(S) is not Object, throw a TypeError exception.\n\t\t\tif (typeof S !== 'object') {\n\t\t\t\tthrow new TypeError('Method Set.prototype.forEach called on incompatible receiver ' + Object.prototype.toString.call(S));\n\t\t\t}\n\t\t\t// 3. If S does not have a [[SetData]] internal slot, throw a TypeError exception.\n\t\t\tif (S._es6Set !== true) {\n\t\t\t\tthrow new TypeError('Method Set.prototype.forEach called on incompatible receiver ' + Object.prototype.toString.call(S));\n\t\t\t}\n\t\t\t// 4. Let entries be the List that is S.[[SetData]].\n\t\t\tvar entries = S._values;\n\t\t\t// 5. For each e that is an element of entries, do\n\t\t\tfor (var i = 0; i < entries.length; i++) {\n\t\t\t\tvar e = entries[i];\n\t\t\t\t// a. If e is not empty and SameValueZero(e, value) is true, return true.\n\t\t\t\tif (e !== undefMarker && SameValueZero(e, value)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// 6. Return false.\n\t\t\treturn false;\n\t\t}\n\t);\n\n\t// Polyfill.io - We need to define Set.prototype.values before Set.prototype.keys because keys is a reference to values.\n\t// 23.2.3.10. Set.prototype.values()\n\tvar values = function values() {\n\t\t// 1. Let S be the this value.\n\t\tvar S = this;\n\t\t// 2. Return ? CreateSetIterator(S, \"value\").\n\t\treturn CreateSetIterator(S, \"value\");\n\t};\n\tCreateMethodProperty(Set.prototype, 'values', values);\n\n\t// 23.2.3.8 Set.prototype.keys ( )\n\t// The initial value of the keys property is the same function object as the initial value of the values property.\n\tCreateMethodProperty(Set.prototype, 'keys', values);\n\n\t// 23.2.3.9. get Set.prototype.size\n\tif (supportsGetters) {\n\t\tObject.defineProperty(Set.prototype, 'size', {\n\t\t\tconfigurable: true,\n\t\t\tenumerable: false,\n\t\t\tget: function () {\n\t\t\t\t// 1. Let S be the this value.\n\t\t\t\tvar S = this;\n\t\t\t\t// 2. If Type(S) is not Object, throw a TypeError exception.\n\t\t\t\tif (typeof S !== 'object') {\n\t\t\t\t\tthrow new TypeError('Method Set.prototype.size called on incompatible receiver ' + Object.prototype.toString.call(S));\n\t\t\t\t}\n\t\t\t\t// 3. If S does not have a [[SetData]] internal slot, throw a TypeError exception.\n\t\t\t\tif (S._es6Set !== true) {\n\t\t\t\t\tthrow new TypeError('Method Set.prototype.size called on incompatible receiver ' + Object.prototype.toString.call(S));\n\t\t\t\t}\n\t\t\t\t// 4. Let entries be the List that is S.[[SetData]].\n\t\t\t\tvar entries = S._values;\n\t\t\t\t// 5. Let count be 0.\n\t\t\t\tvar count = 0;\n\t\t\t\t// 6. For each e that is an element of entries, do\n\t\t\t\tfor (var i = 0; i < entries.length; i++) {\n\t\t\t\t\tvar e = entries[i];\n\t\t\t\t\t// a. If e is not empty, set count to count+1.\n\t\t\t\t\tif (e !== undefMarker) {\n\t\t\t\t\t\tcount = count + 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// 7. Return count.\n\t\t\t\treturn count;\n\t\t\t},\n\t\t\tset: undefined\n\t\t});\n\t}\n\n\t// 23.2.3.11. Set.prototype [ @@iterator ] ( )\n\t// The initial value of the @@iterator property is the same function object as the initial value of the values property.\n\tCreateMethodProperty(Set.prototype, Symbol.iterator, values);\n\n\t// 23.2.3.12. Set.prototype [ @@toStringTag ]\n\t// The initial value of the @@toStringTag property is the String value \"Set\".\n\t// This property has the attributes { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: true }.\n\n\t// Polyfill.io - Safari 8 implements Set.name but as a non-configurable property, which means it would throw an error if we try and configure it here.\n\tif (!('name' in Set)) {\n\t\t// 19.2.4.2 name\n\t\tObject.defineProperty(Set, 'name', {\n\t\t\tconfigurable: true,\n\t\t\tenumerable: false,\n\t\t\twritable: false,\n\t\t\tvalue: 'Set'\n\t\t});\n\t}\n\n\t// 23.2.5.1. CreateSetIterator ( set, kind )\n\tfunction CreateSetIterator(set, kind) {\n\t\t// 1. If Type(set) is not Object, throw a TypeError exception.\n\t\tif (typeof set !== 'object') {\n\t\t\tthrow new TypeError('createSetIterator called on incompatible receiver ' + Object.prototype.toString.call(set));\n\t\t}\n\t\t// 2. If set does not have a [[SetData]] internal slot, throw a TypeError exception.\n\t\tif (set._es6Set !== true) {\n\t\t\tthrow new TypeError('createSetIterator called on incompatible receiver ' + Object.prototype.toString.call(set));\n\t\t}\n\t\t// 3. Let iterator be ObjectCreate(%SetIteratorPrototype%, « [[IteratedSet]], [[SetNextIndex]], [[SetIterationKind]] »).\n\t\tvar iterator = Object.create(SetIteratorPrototype);\n\t\t// 4. Set iterator.[[IteratedSet]] to set.\n\t\tObject.defineProperty(iterator, '[[IteratedSet]]', {\n\t\t\tconfigurable: true,\n\t\t\tenumerable: false,\n\t\t\twritable: true,\n\t\t\tvalue: set\n\t\t});\n\t\t// 5. Set iterator.[[SetNextIndex]] to 0.\n\t\tObject.defineProperty(iterator, '[[SetNextIndex]]', {\n\t\t\tconfigurable: true,\n\t\t\tenumerable: false,\n\t\t\twritable: true,\n\t\t\tvalue: 0\n\t\t});\n\t\t// 6. Set iterator.[[SetIterationKind]] to kind.\n\t\tObject.defineProperty(iterator, '[[SetIterationKind]]', {\n\t\t\tconfigurable: true,\n\t\t\tenumerable: false,\n\t\t\twritable: true,\n\t\t\tvalue: kind\n\t\t});\n\t\t// 7. Return iterator.\n\t\treturn iterator;\n\t}\n\n\t// 23.2.5.2. The %SetIteratorPrototype% Object\n\tvar SetIteratorPrototype = {};\n\t//Polyfill.io - We add this property to help us identify what is a set iterator.\n\tObject.defineProperty(SetIteratorPrototype, 'isSetIterator', {\n\t\tconfigurable: false,\n\t\tenumerable: false,\n\t\twritable: false,\n\t\tvalue: true\n\t});\n\n\t// 23.2.5.2.1. %SetIteratorPrototype%.next ( )\n\tCreateMethodProperty(SetIteratorPrototype, 'next', function next() {\n\t\t// 1. Let O be the this value.\n\t\tvar O = this;\n\t\t// 2. If Type(O) is not Object, throw a TypeError exception.\n\t\tif (typeof O !== 'object') {\n\t\t\tthrow new TypeError('Method %SetIteratorPrototype%.next called on incompatible receiver ' + Object.prototype.toString.call(O));\n\t\t}\n\t\t// 3. If O does not have all of the internal slots of a Set Iterator Instance (23.2.5.3), throw a TypeError exception.\n\t\tif (!O.isSetIterator) {\n\t\t\tthrow new TypeError('Method %SetIteratorPrototype%.next called on incompatible receiver ' + Object.prototype.toString.call(O));\n\t\t}\n\t\t// 4. Let s be O.[[IteratedSet]].\n\t\tvar s = O['[[IteratedSet]]'];\n\t\t// 5. Let index be O.[[SetNextIndex]].\n\t\tvar index = O['[[SetNextIndex]]'];\n\t\t// 6. Let itemKind be O.[[SetIterationKind]].\n\t\tvar itemKind = O['[[SetIterationKind]]'];\n\t\t// 7. If s is undefined, return CreateIterResultObject(undefined, true).\n\t\tif (s === undefined) {\n\t\t\treturn CreateIterResultObject(undefined, true);\n\t\t}\n\t\t// 8. Assert: s has a [[SetData]] internal slot.\n\t\tif (!s._es6Set) {\n\t\t\tthrow new Error(Object.prototype.toString.call(s) + ' does not have [[SetData]] internal slot.');\n\t\t}\n\t\t// 9. Let entries be the List that is s.[[SetData]].\n\t\tvar entries = s._values;\n\t\t// 10. Let numEntries be the number of elements of entries.\n\t\tvar numEntries = entries.length;\n\t\t// 11. NOTE: numEntries must be redetermined each time this method is evaluated.\n\t\t// 12. Repeat, while index is less than numEntries,\n\t\twhile (index < numEntries) {\n\t\t\t// a. Let e be entries[index].\n\t\t\tvar e = entries[index];\n\t\t\t// b. Set index to index+1.\n\t\t\tindex = index + 1;\n\t\t\t// c. Set O.[[SetNextIndex]] to index.\n\t\t\tO['[[SetNextIndex]]'] = index;\n\t\t\t// d. If e is not empty, then\n\t\t\tif (e !== undefMarker) {\n\t\t\t\t// i. If itemKind is \"key+value\", then\n\t\t\t\tif (itemKind === 'key+value') {\n\t\t\t\t\t// 1. Return CreateIterResultObject(CreateArrayFromList(« e, e »), false).\n\t\t\t\t\treturn CreateIterResultObject([e, e], false);\n\t\t\t\t}\n\t\t\t\t// ii. Return CreateIterResultObject(e, false).\n\t\t\t\treturn CreateIterResultObject(e, false);\n\t\t\t}\n\t\t}\n\t\t// 13. Set O.[[IteratedSet]] to undefined.\n\t\tO['[[IteratedSet]]'] = undefined;\n\t\t// 14. Return CreateIterResultObject(undefined, true).\n\t\treturn CreateIterResultObject(undefined, true);\n\t});\n\n\t// 23.2.5.2.2. %SetIteratorPrototype% [ @@toStringTag ]\n\t// The initial value of the @@toStringTag property is the String value \"Set Iterator\".\n\t// This property has the attributes { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: true }.\n\n\tCreateMethodProperty(SetIteratorPrototype, Symbol.iterator, function iterator() {\n\t\t\treturn this;\n\t\t}\n\t);\n\n\t// Export the object\n\ttry {\n\t\tCreateMethodProperty(global, 'Set', Set);\n\t} catch (e) {\n\t\t// IE8 throws an error here if we set enumerable to false.\n\t\t// More info on table 2: https://msdn.microsoft.com/en-us/library/dd229916(v=vs.85).aspx\n\t\tglobal.Set = Set;\n\t}\n\n}(self));\n\n}\n\nif (!(\"from\"in Array&&function(){try{return Array.from({length:-Infinity}),\"a\"===Array.from(new self.Set([\"a\"]))[0]&&\"a\"===Array.from(new self.Map([[\"a\",\"one\"]]))[0][0]}catch(r){return!1}}()\n)) {\n\n// Array.from\n/* globals\n\tIsCallable, GetMethod, Symbol, IsConstructor, Construct, ArrayCreate, GetIterator, IteratorClose,\n\tToString, IteratorStep, IteratorValue, Call, CreateDataPropertyOrThrow, ToObject, ToLength, Get, CreateMethodProperty\n*/\n(function () {\n\tvar toString = Object.prototype.toString;\n\tvar stringMatch = String.prototype.match;\n\t// A cross-realm friendly way to detect if a value is a String object or literal.\n\tfunction isString(value) {\n\t\tif (typeof value === 'string') { return true; }\n\t\tif (typeof value !== 'object') { return false; }\n\t\treturn toString.call(value) === '[object String]';\n\t}\n\n\t// 22.1.2.1. Array.from ( items [ , mapfn [ , thisArg ] ] )\n\tCreateMethodProperty(Array, 'from', function from(items /* [ , mapfn [ , thisArg ] ] */) { // eslint-disable-line no-undef\n\t\t// 1. Let C be the this value.\n\t\tvar C = this;\n\t\t// 2. If mapfn is undefined, let mapping be false.\n\t\tvar mapfn = arguments.length > 1 ? arguments[1] : undefined;\n\t\tif (mapfn === undefined) {\n\t\t\tvar mapping = false;\n\t\t\t// 3. Else,\n\t\t} else {\n\t\t\t// a. If IsCallable(mapfn) is false, throw a TypeError exception.\n\t\t\tif (IsCallable(mapfn) === false) {\n\t\t\t\tthrow new TypeError(Object.prototype.toString.call(mapfn) + ' is not a function.');\n\t\t\t}\n\t\t\t// b. If thisArg is present, let T be thisArg; else let T be undefined.\n\t\t\tvar thisArg = arguments.length > 2 ? arguments[2] : undefined;\n\t\t\tif (thisArg !== undefined) {\n\t\t\t\tvar T = thisArg;\n\t\t\t} else {\n\t\t\t\tT = undefined;\n\t\t\t}\n\t\t\t// c. Let mapping be true.\n\t\t\tmapping = true;\n\n\t\t}\n\t\t// 4. Let usingIterator be ? GetMethod(items, @@iterator).\n\t\tvar usingIterator = GetMethod(items, Symbol.iterator);\n\t\t// 5. If usingIterator is not undefined, then\n\t\tif (usingIterator !== undefined) {\n\t\t\t// a. If IsConstructor(C) is true, then\n\t\t\tif (IsConstructor(C)) {\n\t\t\t\t// i. Let A be ? Construct(C).\n\t\t\t\tvar A = Construct(C);\n\t\t\t\t// b. Else,\n\t\t\t} else {\n\t\t\t\t// i. Let A be ! ArrayCreate(0).\n\t\t\t\tA = ArrayCreate(0);\n\t\t\t}\n\t\t\t// c. Let iteratorRecord be ? GetIterator(items, usingIterator).\n\t\t\tvar iteratorRecord = GetIterator(items, usingIterator);\n\t\t\t// d. Let k be 0.\n\t\t\tvar k = 0;\n\t\t\t// e. Repeat,\n\t\t\t// eslint-disable-next-line no-constant-condition\n\t\t\twhile (true) {\n\t\t\t\t// i. If k ≥ 2^53-1, then\n\t\t\t\tif (k >= (Math.pow(2, 53) - 1)) {\n\t\t\t\t\t// 1. Let error be Completion{[[Type]]: throw, [[Value]]: a newly created TypeError object, [[Target]]: empty}.\n\t\t\t\t\tvar error = new TypeError('Iteration count can not be greater than or equal 9007199254740991.');\n\t\t\t\t\t// 2. Return ? IteratorClose(iteratorRecord, error).\n\t\t\t\t\treturn IteratorClose(iteratorRecord, error);\n\t\t\t\t}\n\t\t\t\t// ii. Let Pk be ! ToString(k).\n\t\t\t\tvar Pk = ToString(k);\n\t\t\t\t// iii. Let next be ? IteratorStep(iteratorRecord).\n\t\t\t\tvar next = IteratorStep(iteratorRecord);\n\t\t\t\t// iv. If next is false, then\n\t\t\t\tif (next === false) {\n\t\t\t\t\t// 1. Perform ? Set(A, \"length\", k, true).\n\t\t\t\t\tA.length = k;\n\t\t\t\t\t// 2. Return A.\n\t\t\t\t\treturn A;\n\t\t\t\t}\n\t\t\t\t// v. Let nextValue be ? IteratorValue(next).\n\t\t\t\tvar nextValue = IteratorValue(next);\n\t\t\t\t// vi. If mapping is true, then\n\t\t\t\tif (mapping) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\t// Polyfill.io - The try catch accounts for step 2.\n\t\t\t\t\t\t// 1. Let mappedValue be Call(mapfn, T, « nextValue, k »).\n\t\t\t\t\t\tvar mappedValue = Call(mapfn, T, [nextValue, k]);\n\t\t\t\t\t\t// 2. If mappedValue is an abrupt completion, return ? IteratorClose(iteratorRecord, mappedValue).\n\t\t\t\t\t\t// 3. Let mappedValue be mappedValue.[[Value]].\n\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\treturn IteratorClose(iteratorRecord, e);\n\t\t\t\t\t}\n\n\t\t\t\t\t// vii. Else, let mappedValue be nextValue.\n\t\t\t\t} else {\n\t\t\t\t\tmappedValue = nextValue;\n\t\t\t\t}\n\t\t\t\ttry {\n\t\t\t\t\t// Polyfill.io - The try catch accounts for step ix.\n\t\t\t\t\t// viii. Let defineStatus be CreateDataPropertyOrThrow(A, Pk, mappedValue).\n\t\t\t\t\tCreateDataPropertyOrThrow(A, Pk, mappedValue);\n\t\t\t\t\t// ix. If defineStatus is an abrupt completion, return ? IteratorClose(iteratorRecord, defineStatus).\n\t\t\t\t} catch (e) {\n\t\t\t\t\treturn IteratorClose(iteratorRecord, e);\n\t\t\t\t}\n\t\t\t\t// x. Increase k by 1.\n\t\t\t\tk = k + 1;\n\t\t\t}\n\t\t}\n\t\t// 6. NOTE: items is not an Iterable so assume it is an array-like object.\n\t\t// 7. Let arrayLike be ! ToObject(items).\n\t\t// Polyfill.io - For Strings we need to split astral symbols into surrogate pairs.\n\t\tif (isString(items)) {\n\t\t\tvar arrayLike = stringMatch.call(items, /[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]?|[^\\uD800-\\uDFFF]|./g) || [];\n\t\t} else {\n\t\t\tarrayLike = ToObject(items);\n\t\t}\n\t\t// 8. Let len be ? ToLength(? Get(arrayLike, \"length\")).\n\t\tvar len = ToLength(Get(arrayLike, \"length\"));\n\t\t// 9. If IsConstructor(C) is true, then\n\t\tif (IsConstructor(C)) {\n\t\t\t// a. Let A be ? Construct(C, « len »).\n\t\t\tA = Construct(C, [len]);\n\t\t\t// 10. Else,\n\t\t} else {\n\t\t\t// a. Let A be ? ArrayCreate(len).\n\t\t\tA = ArrayCreate(len);\n\t\t}\n\t\t// 11. Let k be 0.\n\t\tk = 0;\n\t\t// 12. Repeat, while k < len\n\t\twhile (k < len) {\n\t\t\t// a. Let Pk be ! ToString(k).\n\t\t\tPk = ToString(k);\n\t\t\t// b. Let kValue be ? Get(arrayLike, Pk).\n\t\t\tvar kValue = Get(arrayLike, Pk);\n\t\t\t// c. If mapping is true, then\n\t\t\tif (mapping === true) {\n\t\t\t\t// i. Let mappedValue be ? Call(mapfn, T, « kValue, k »).\n\t\t\t\tmappedValue = Call(mapfn, T, [kValue, k]);\n\t\t\t\t// d. Else, let mappedValue be kValue.\n\t\t\t} else {\n\t\t\t\tmappedValue = kValue;\n\t\t\t}\n\t\t\t// e. Perform ? CreateDataPropertyOrThrow(A, Pk, mappedValue).\n\t\t\tCreateDataPropertyOrThrow(A, Pk, mappedValue);\n\t\t\t// f. Increase k by 1.\n\t\t\tk = k + 1;\n\t\t}\n\t\t// 13. Perform ? Set(A, \"length\", len, true).\n\t\tA.length = len;\n\t\t// 14. Return A.\n\t\treturn A;\n\t});\n}());\n\n}\n\n})\n('object' === typeof window && window || 'object' === typeof self && self || 'object' === typeof global && global || {});\n"],"names":[],"sourceRoot":""}